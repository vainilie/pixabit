Hello! I'm working on a Python project called Pixabit, which is a command-line tool for interacting with the Habitica v3 API. I'm currently refactoring it from a synchronous Rich-based CLI into an asynchronous **Textual TUI application**.

**Current Status:**

- I have refactored the core data handling layer. This includes:
  - An asynchronous `HabiticaAPI` client (`api.py`) using `httpx`.
  - Data model classes (`models/`) for entities like `Task`, `User`, `Challenge`, `Tag`, etc., and container classes like `TaskList`, `ChallengeList`.
  - A `TaskProcessor` (`data_processor.py`) that takes raw data and outputs processed data model objects.
  - A `GameContent` manager (`game_content.py`) for lazy-loading cached content.
  - A central `PixabitDataStore` (`data_store.py`) acting as a facade to manage state (using the model objects/containers), orchestrate API calls via the async `HabiticaAPI`, and coordinate processing via `TaskProcessor`.
- I have a basic Textual app shell (`tui/app.py`) and CSS (`tui/pixabit.tcss`).
- I have supporting utility modules (`utils/`) and configuration files (`config.py`, `config_auth.py`, `config_tags.py`, `pyproject.toml`, `styles`).

**Goal:**

My next major step is to **build out the Textual TUI components** (widgets for displaying stats, menus, lists like tasks/challenges/tags) and **connect them to the `PixabitDataStore`**. I then need to implement the user actions (like scoring tasks, leaving challenges, managing tags, etc., based on my project's TODO list found in the README) within this new TUI architecture.

**Request:**

I will provide you with the complete code for all the current modules. Could you please help me with the following:

1.  **Code Review:** Check the provided files for any obvious mistakes, inconsistencies, logical errors, or areas where the async/await handling might be incorrect, particularly in the `PixabitDataStore` and its interaction with the `HabiticaAPI`.    I want my code to be _pythonic_ and not loop into confusing functions when there are easier approaches. I like my code organized, aesthetic and clear.
2.  **Python 3.10+ Typing:** Ensure all type hints are standardized and idiomatic for Python 3.10 or later (using `|` for Union/Optional, built-in generics like `list[str]`, `dict[str, Any]` where appropriate, but ensuring necessary `typing` imports like `Optional`, `Any`, `List`, `Dict` are still present if needed for clarity or compatibility) - my linter mark this as an error.
3.  **Comment Anchor Consistency:** Apply the comment anchor style we established (`# SECTION:`, `# KLASS:`, `# FUNC:`) consistently across **all** provided Python files for better navigation and readability.
4.  **Clear DocStrings** Generate well-descriptive DocStrings to perfect implementation of arguments. Also, keep comments that guide or describe each step.
5.  **Action Logic Integration Strategy:** Explain and show _how_ I should take the logic that was previously embedded directly within my old Rich `CliApp`'s action methods (like handling broken tasks, replicating challenge setups, scoring tasks, managing tags) and correctly implement it within the new Textual TUI structure. Specifically, how should the TUI widgets, the `PixabitTUIApp`, the `PixabitDataStore`, and potentially new `tui/actions/` modules work together to handle user input, trigger asynchronous API calls via the `DataStore`, manage state updates (including potential optimistic UI), handle errors, and trigger necessary data refreshes? Please provide practical examples based on my existing code or TODO list items.
    Essentially, I want to keep the TUI layer separate from the data/action logic layer, with PixabitDataStore serving as the primary interface and orchestrator for that logic layer, rather than creating many separate tui/actions/\*.py files at this stage.
    But I don't want to mix everything, the modules should do different actions with the data: structuring the clases of the data, getting the data, processing data, showing data and doing actions should be separated. The data processing should not be completely mixed with the TUI. I can't handle executing many things at the same time or I get distracted/confused.


I will now paste the content of my project files, marking the start and end of each file this way: --- START OF FILE filename.py --- / --- END OF FILE filename.py ---

--- START OF FILE main.py ---
#!/usr/bin/env python3

# main.py

# MARK: - MODULE DOCSTRING

"""Main entry point script for the Pixabit CLI application.

This script initializes the necessary components, sets up error handling,
and starts the main application loop defined in the `CliApp` class.
"""

# MARK: - IMPORTS

import os
import sys
import traceback

# For fallback error printing

# --- Add project root to path if necessary ---

# This ensures that 'import pixabit' works correctly even if the script

# is run from a different directory, though often not needed if run from root.

# try:

# project_root = Path(**file**).resolve().parent

# if str(project_root) not in sys.path:

# sys.path.insert(0, str(project_root))

# except NameError:

# **file** might not be defined in some contexts

# if str(Path.cwd()) not in sys.path:

# sys.path.insert(0, str(Path.cwd()))

# --- Import Core Application Components ---

# Attempt to import after potentially modifying path

try:
from pixabit.cli.app import CliApp

    # Import the themed console for top-level messages/errors
    from pixabit.utils.display import Rule, console, print

except ImportError as import_err:

    # Use standard print for this critical error
    import builtins

    builtins.print("FATAL ERROR: Could not import Pixabit application modules.")
    builtins.print(
        "Ensure the script is run from the project root directory containing the 'pixabit' folder."
    )
    builtins.print(f"Import Error: {import_err}")
    sys.exit(1)

except Exception as general_err:

    # Catch other potential errors during import (rare)
    import builtins

    builtins.print("FATAL ERROR: An unexpected error occurred during initial imports.")
    builtins.print(f"Error: {general_err}")
    traceback.print_exc()
    # Print full traceback for unexpected import errors
    sys.exit(1)

# MARK: - MAIN EXECUTION BLOCK

if **name** == "**main**":

    # --- Welcome Message ---

    # Use the themed console if available
    try:
        console.print(
            "\nğŸš€ Welcome to Pixabit - Habitica CLI Assistant ğŸš€",
            style="highlight",
            justify="center",
        )
        console.print(Rule(style="rp_overlay"))
    # Themed separator
    except Exception:
        # Fallback if console failed somehow
        print("\n--- Welcome to Pixabit ---")

    # --- Instantiate and Run App ---
    try:
        app = CliApp()
        app.run()
    # Start the main application loop

    # --- Graceful Exit on Ctrl+C ---
    except KeyboardInterrupt:
        try:

            # Use themed console for exit message
            console.print(
                "\n\n[bold yellow]âŒ¨ï¸ Ctrl+C detected. Exiting Pixabit gracefully.[/bold yellow]"
            )
        except Exception:
            print("\n\nExiting Pixabit (Ctrl+C).")

        # Attempt a clean exit
        try:
            sys.exit(0)
        except SystemExit:
            os._exit(0)
    # Force exit if sys.exit is blocked

    # --- Catch-All for Unexpected Errors ---
    except Exception as e:

        # Try using the themed console first for a nice traceback
        try:
            console.print("\n\n[error]âŒ An unexpected critical error occurred:[/error]")

            # Show detailed traceback using Rich
            console.print_exception(show_locals=True, word_wrap=False)
        except Exception as fallback_e:

            # Fallback to standard printing if console fails
            print("\n\nFATAL UNEXPECTED ERROR (Console failed):")
            print(f"Original Error Type: {type(e).__name__}")
            print(f"Original Error: {e}")
            print("\n--- Traceback ---")
            traceback.print_exc()
            print("-----------------")
            print(f"Console fallback error: {fallback_e}")

        # Exit with a non-zero code to indicate failure
        try:
            sys.exit(1)
        except SystemExit:
            os._exit(1)

# Force exit

# --- Final Exit Message (if loop broken normally) ---

# The exit message is typically handled within app.run() when the user chooses Exit.

# Adding one here might be redundant unless app.run() can return without printing.

# try:

# console.print("\nPixabit finished.", style="info")

# except Exception:

# print("\nPixabit finished.")

--- END OF FILE main.py ---

--- START OF FILE Migration.md ---
**4. Updated TODO List & Migration Steps:**

Here's a revised TODO list focusing on the Textual migration:

**Pixabit Textual TUI TODO List:**

**Phase 1: Basic Structure (Mostly Done)**

- [âœ…] Set up Textual App (`PixabitTUIApp`).
- [âœ…] Define basic CSS (`pixabit.tcss`).
- [âœ…] Implement Header/Footer.
- [âœ…] Create placeholder content areas.
- [âœ…] Implement basic keybindings (Quit, Refresh).

**Phase 2: Async API & Data Layer (Mostly Done)**

- [âœ…] Convert `HabiticaAPI` to async using `httpx`.
- [âœ…] Define Data Models (`models/`).
- [âœ…] Implement `GameContent` manager (lazy loading cache).
- [âœ…] Refine `TaskProcessor` to use context/models and calculate status/damage.
- [âœ…] Refine `get_user_stats` function.
- [âœ…] Implement `PixabitDataStore` facade.
- [âœ…] Implement `DataStore.refresh_all_data` (async fetch, sync process, state update, UI notification).

**Phase 3: Core UI Widget Implementation**

- [ğŸš§ In Progress] **Implement `StatsPanel` Widget:** Create and integrate `widgets/stats_panel.py`. Ensure it updates correctly via `on_data_refreshed` using `store.get_user_stats()`.
- [â³ To Do] **Implement `MainMenu` Widget:** Use `ListView` or `OptionList`. Populate with main categories. Handle selection events (`on_list_view_selected` or `on_option_list_option_selected`).
- [â³ To Do] **Implement `TaskList` Widget:** Use `DataTable`. Populate using `store.get_tasks(**filters)`. Handle row selection (to show details later). Add filtering controls (e.g., Input widget connected to `ListViewer`).
- [â³ To Do] **Implement `ChallengeList` Widget:** Similar to `TaskList`, using `store.get_challenges(**filters)`.
- [â³ To Do] **Implement `TagList` Widget:** Similar, using `store.get_tags()`.

**Phase 4: Navigation & Content Switching**

- [â³ To Do] **Implement Main App Navigation:** In `PixabitTUIApp`, handle `MainMenu` selection events to mount/unmount the appropriate list widget (`TaskListWidget`, `ChallengeListWidget`, etc.) into the main `#content-panel` area.
- [â³ To Do] **Implement Detail Views:** When a user selects an item in a list (e.g., a task in `TaskListWidget`), mount/update a detail widget (e.g., `TaskDetailWidget`) in the `#content-panel` or perhaps a dedicated side panel.

**Phase 5: Action Implementation (Async)**

- [â³ To Do] **Refactor Action Helpers:** Create `tui/actions/` modules (e.g., `task_actions.py`). Move logic into `async` functions taking `store: PixabitDataStore` as an argument.
- [ğŸš§ In Progress] **Connect UI to Actions:** Add `Button`s or keybindings in relevant widgets/screens. Event handlers in the App or Widget will call `app.run_worker(store.action_method(...))`.
- [â³ To Do] **Implement TUI Confirmations:** Replace Rich `Confirm` with Textual modal screens (`app.push_screen(ConfirmDialog(...))`) within action functions where needed.
- [â³ To Do] **Implement TUI Progress:** Adapt `TagManager._confirm_and_execute_actions` (and similar batch processes) to update a Textual `ProgressBar` via callbacks/messages instead of Rich `Progress`.
- [â³ To Do] **Implement Specific Actions:**
  - Toggle Sleep (`store.toggle_sleep`) - _Done in example_
  - Score Task (`store.score_task`) - _Done in example_
  - Handle Broken Tasks (needs UI for selection, calls `store.unlink_task`/`store.unlink_all_tasks`)
  - Leave Challenge (needs UI, calls `store.leave_challenge`)
  - Delete Unused Tags (needs UI, calls `store.delete_tag` via TagManager logic)
  - Set CDS (needs UI input, calls `store.set_cds`)
  - Task CRUD (major: needs forms/inputs, calls `store.create/update/delete_task`)
  - Checklist actions (needs UI in task detail, calls `store.checklist_*` methods)
  - Pin/Unpin (needs UI, calls `store.move_task`)
  - Banking (needs UI, calls `store.score_task` with specific IDs)
  - Inbox (needs UI, calls `store.get_inbox`/`store.send_pm`, etc.)
  - Exports (needs UI trigger, calls `export_*.py` functions - can often remain sync or use `run_in_thread` for file I/O).

**Phase 6: Styling & Refinement**

- [â³ To Do] Flesh out `pixabit.tcss` extensively.
- [â³ To Do] Refine layouts for different screen sizes.
- [â³ To Do] Add more robust error display in the UI.

Focus on getting the `StatsPanel` displaying correctly first (completing Phase 2), then build the main menu and task list widgets (Phase 3).

--- END OF FILE Migration.md ---

--- START OF FILE Readme.md ---

# Pixabit - Habitica CLI Assistant

A personal command-line interface (CLI) tool written in Python to interact with the Habitica API (v3) for managing tasks, tags, challenges, stats, and performing various account actions. Uses the Rich library for enhanced terminal output.

#

# Features (Implemented/Refined)

- **Data Refresh & Display:** Fetches and displays user stats (Dashboard), tags (all/unused), and broken tasks. Optimized data fetching via central `refresh_data` passing data down to components. Caches game content data (`content_cache.json`).
- **Tag Management:**
  - Interactively configure optional tags (`Configure Special Tags` menu option).
  - Display all tags and unused tags.
  - Interactively delete unused tags globally (requires confirmation).
  - Interactively add/replace tags on tasks based on other existing tags.
  - _Optional Feature Syncing (Conditional based on `.env` config):_
    - Sync challenge vs. personal tags.
    - Ensure poison status tags (poisoned/not poisoned).
    - Sync attribute tags (STR/INT/CON/PER/None) with task's attribute field.
- **Challenge Management:**
  - Backup challenges (including associated, cleaned tasks) to individual JSON files.
  - Leave a joined challenge (prompts for task handling, updates local cache).
- **Task Management:**
  - Handle broken tasks: View tasks grouped by broken challenge, unlink individually or in bulk per challenge (with keep/remove option).
  - Replicate setup (attributes, tags, optionally position) from an old/broken challenge's tasks to a new challenge's tasks via fuzzy text matching.
- **User Actions:**
  - Toggle sleep status (Inn/Tavern).
- **Data Export:**
  - Save raw user data (`/user` endpoint).
  - Save raw tasks (`/tasks/user` endpoint, with emoji processing).
  - Save processed tasks dictionary (from `TaskProcessor`).
  - Save all tags (categorized by challenge/personal).
- **Configuration:**
  - Interactive setup for mandatory credentials (`.env` file creation/check).
  - Interactive setup for optional Tag IDs.
- **UI:**
  - Rich-based themed console output (using Catppuccin/RosÃ© Pine inspired theme defined in `styles` file).
  - Progress bars for lengthy operations (refresh, batch API calls).
  - Clear menus, prompts, and confirmations.

#

# Requirements

- Python 3.9+
- Libraries listed in `requirements.txt`. Key dependencies:
  - `requests`
  - `rich`
  - `python-dotenv`
  - `python-dateutil`
  - `tzlocal`
  - `emoji-data-python`
  - `pathvalidate`
  - `timeago`
  - `art` (Optional, for potential future ASCII art headers)

#

# Installation & Setup

1.  **Clone Repository:**
    ```bash
    git clone <your-repository-url>
    cd pixabit
    ```
2.  **Create & Activate Virtual Environment:**
    ```bash
    python -m venv .venv
    ```

# Windows:

# .venv\Scripts\activate

# macOS/Linux:

# source .venv/bin/activate

    ```

3.  **Install Dependencies:**
    ```bash
    pip install -r requirements.txt
    ```
4.  **Initial Configuration (Mandatory Credentials):**
    - Run the application once. It will detect if `.env` is missing.
      ```bash
      python main.py
      ```

# Or however you plan to run the app

      ```
    - Follow the prompts to interactively create the `.env` file and enter your **Habitica User ID** and **API Token**.
    - Alternatively, manually create a `.env` file in the project root with:
      ```dotenv
      HABITICA_USER_ID="YOUR_USER_ID_HERE"
      HABITICA_API_TOKEN="YOUR_API_TOKEN_HERE"
      ```
    - **Security:** Ensure `.env` is added to your `.gitignore` file!

5.  **Configure Optional Tags (Recommended):**
    - Run the interactive tag setup via the application menu:
      - Start the app: `python main.py`
      - Navigate to: `Application` -> `Configure Special Tags`
    - This will fetch your existing Habitica tags and guide you through assigning them to roles like "Challenge Tag", "Strength Attribute Tag", etc., saving the selections to your `.env` file. You can skip features you don't use.

#

# Usage

1.  Ensure your virtual environment is active (`source .venv/bin/activate` or equivalent).
2.  Run the main application script from the project root directory:
    ```bash
    python main.py
    ```
    _(Replace `main.py` with your actual entry point script name if different)._
3.  Use the number keys to navigate the menus and follow the on-screen prompts.

#

# `.env` Configuration Variables

- `HABITICA_USER_ID` **(Mandatory)**: Your Habitica User ID (from Settings -> API).
- `HABITICA_API_TOKEN` **(Mandatory)**: Your Habitica API Token (from Settings -> API).
- `CHALLENGE_TAG_ID` (Optional): Tag ID used by `TagManager` to identify challenge tasks.
- `PERSONAL_TAG_ID` (Optional): Tag ID used by `TagManager` for non-challenge tasks.
- `PSN_TAG_ID` (Optional): Tag ID for "Poisoned" status.
- `NOT_PSN_TAG_ID` (Optional): Tag ID for "Not Poisoned" status.
- `NO_ATTR_TAG_ID` (Optional): Tag ID for tasks with no specific attribute or conflicting attribute tags.
- `ATTR_TAG_STR_ID` (Optional): Tag ID representing the Strength attribute.
- `ATTR_TAG_INT_ID` (Optional): Tag ID representing the Intelligence attribute.
- `ATTR_TAG_CON_ID` (Optional): Tag ID representing the Constitution attribute.
- `ATTR_TAG_PER_ID` (Optional): Tag ID representing the Perception attribute.

_(Note: Optional Tag IDs are typically set via the interactive "Configure Special Tags" menu.)_

#

# License

_(Choose a license - e.g., MIT License, Apache 2.0, or specify if it's for personal use only)_

Example: MIT License

---

# Consolidated TODO List for Pixabit (Updated Based on Refinement)

_(Reflects current state after implementing code structure)_

#

# Core API & Processing

- [âœ… Done] Optimize `refresh_data` to fetch data centrally and pass down.
- [âœ… Done] Implement content caching (`_get_content_cached`).
- [âœ… Done] Implement challenge caching (`_fetch_challenges_cached`).
- [âœ… Done] Calculate potential daily damage in `TaskProcessor`.
- [âœ… Done] Calculate effective CON in `TaskProcessor`.
- [âœ… Done] Implement `get_user_stats` using processed/fetched data.

#

# Tag Management (`TagManager`)

- [âœ… Done] Implement `sync_challenge_personal_tags` (conditional on config).
- [âœ… Done] Implement `ensure_poison_status_tags` (conditional on config).
- [âœ… Done] Implement `sync_attributes_to_tags` (conditional on config).
- [âœ… Done] Implement `find_unused_tags`.
- [âœ… Done] Implement `delete_unused_tags_interactive` (uses hypothetical `delete_tag_global` action).
- [âœ… Done] Implement `add_or_replace_tag_based_on_other`.
- [âœ… Done] Add logging for configured tag features in `__init__`.

#

# Challenge Management (`ChallengeBackupper`, `CliApp`)

- [âœ… Done] Implement challenge backup (`ChallengeBackupper`, `CliApp` action).
- [âœ… Done] Implement "Leave Challenge" feature (`CliApp._leave_challenge_action`, uses `api.leave_challenge`, updates cache).
- [â³ To Do] **Implement Challenge Import:** Create `ChallengeImporter` class? Needs logic to parse backup JSON, call `api.create_challenge`, then iterate through `_tasks` in JSON and call `api.create_task` (potentially linking them via challenge parameters if API supports). Add CLI action.
- [â³ To Do] **List Joined Challenges:** Add CLI action. Fetch using `api.get_challenges(member_only=True)` (can use cache `self.all_challenges_cache`), filter out _owned_ challenges (check `challenge['leader']['_id'] == self.user_id`), display results in a `rich.Table`.

#

# Task Management (`CliApp`, `api.py`)

- [âœ… Done] Implement "Handle Broken Tasks" (bulk/individual unlink) (`CliApp._handle_broken_tasks_action`).
- [âœ… Done] Implement "Replicate Monthly Setup" (`CliApp._replicate_monthly_setup_action`).
- [â³ To Do] **Implement Task CRUD via CLI:** (Major Feature)
  - **Display Task Details:** Add action to select task (maybe from filtered list), fetch full task data `api.get_task(task_id)` (needs adding to `api.py` -> `GET /tasks/{taskId}`), display nicely.
  - **Score Task:** Add action, prompt task selection, prompt direction ('up'/'down'), call `api.score_task`.
  - **Edit Task:** Add action, prompt task selection, prompt field(s) to edit (text, notes, priority, due date?), call `api.update_task`.
  - **Create Task:** Add action, prompt for text, type, notes, priority, etc., call `api.create_task`.
  - **Delete Task:** Add action, prompt task selection, confirm, call `api.delete_task`.
- [â³ To Do] **Manage Checklist Items via CLI:** Add actions within Task viewing/editing:
  - Add item: Prompt text, call `api.add_checklist_item`.
  - Score item (toggle): Prompt item selection, call `api.score_checklist_item`.
  - Edit item text: Prompt item selection, prompt new text, call `api.update_checklist_item`.
  - Delete item: Prompt item selection, call `api.delete_checklist_item`.
- [â³ To Do] **Implement "Pin/Unpin Task" feature:** Add CLI action. List tasks (e.g., Todos), prompt selection, call `api.move_task_to_position(task_id, 0)` to pin (move to top). Unpin might move to bottom (`-1`) or require more complex position tracking.

#

# User Actions (`CliApp`, `api.py`)

- [âœ… Done] Implement "Toggle Sleep Status".
- [â³ To Do] **Set Custom Day Start:** Add CLI action. Prompt for hour (0-23), call `api.set_custom_day_start`.

#

# Inbox Features (`CliApp`, `api.py`)

- [â³ To Do] **Display Inbox:** Add CLI action. Call `api.get_inbox_messages` (handle pagination - maybe show first page or prompt for page?), display messages.
- [â³ To Do] **Send Private Message:** Add CLI action. Prompt recipient username/ID, prompt message text, call `POST /members/send-private-message` (needs adding to `api.py`).

#

# Banking Simulation (Requires Config)

- [â³ To Do] **Implement Deposit/Withdraw:** Add CLI actions. Requires `DEPOSIT_REWARD_ID` and `WITHDRAW_HABIT_ID` in `.env`. Prompt for amount/times, call `api.score_task` repeatedly for the appropriate ID.

#

# Export Features (`exports.py`, `CliApp`)

- [âœ… Done] Implement exports for raw user data, raw tasks, processed tasks, categorized tags.
- [â³ To Do] **Review/Refine Tasker/KLWP Export:** Evaluate if `tasks_processed.json` is suitable. If not, create a new function in `exports.py` that transforms `self.processed_tasks` into the desired flat list/JSON structure for Tasker/KLWP. Add a corresponding `CliApp` action.

#

# Project & Code Quality

- [âœ… Done] Use `Path` objects for file paths.
- [âœ… Done] Standardize docstrings and type hinting.
- [âœ… Done] Integrate themed Rich components (`display.py`).
- [âœ… Done] Centralize JSON saving (`save_json.py`).
- [âœ… Done] Improve error handling and user feedback.
- [âœ… Done] Add comment anchors (`

# MARK:`, `

# & -`) for navigation.

- [â³ To Do] **Add Unit/Integration Tests:** Crucial for reliability, especially for API interactions and data processing logic.
- [â³ To Do] **Refactor Large Methods:** Some methods in `CliApp` (`_replicate_monthly_setup_action`, `_handle_broken_tasks_action`) are quite long. Consider breaking them into smaller helper methods for readability and testing.
- [â³ To Do] **Implement Debug Mode:** Add a global flag (e.g., environment variable `PIXABIT_DEBUG=true` checked in `config.py`) that enables more verbose logging (e.g., uncommenting `console.log` calls in `api.py`, potentially showing more traceback info).

--- END OF FILE Readme.md ---

--- START OF FILE Utils/clean_name.py ---
"""pixabit/utils/clean_name.py

# â”€â”€â”€ CLEAN NAME â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Provides utility functions for cleaning filenames by replacing characters that
are illegal in many file systems, typically using full-width Unicode variants or
underscores.

Modified: 2025.04.17 by vainilie.
"""

import re

CHARACTER_TRANSLATION_TABLE = str.maketrans(
'"\*/:<>?\\|\t\n\v\f\r', # Illegal characters + whitespace variants
"ï¼‚ï¼Šï¼ï¼šï¼œï¼ï¼Ÿï¼¼ï¿¨ ", # Replacements (full-width + spaces)
)
LEADING_SPACE_PATTERN = re.compile(r"^\s+")

# FUNC â”€â”€â”€ Replace Illegal Filename Charecters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def replace_illegal_filename_characters(input_filename: str) -> str:
r"""Replaces illegal filename characters with full-width variants."""
return input_filename.translate(CHARACTER_TRANSLATION_TABLE).strip()

# FUNC â”€â”€â”€ Replace Illegal Filename Charecters With Leading Underscores â”€â”€â”€â”€â”€â”€â”€â”€

def replace_illegal_filename_characters_leading_underscores(
input_filename: str,
) -> str:
r"""Replaces illegal chars; replaces leading whitespace with underscores."""
output_filename = input_filename.translate(CHARACTER_TRANSLATION_TABLE)

    # Replace any sequence of leading spaces with the same number of underscores
    output_filename = re.sub(
        LEADING_SPACE_PATTERN,
        lambda match: "_" * len(match.group(0)),
        output_filename,
    )

    return output_filename.strip()

# FUNC â”€â”€â”€ Replace Illegal Filename Charecters Keeping Leading Underscores â”€â”€â”€â”€â”€

def replace*illegal_filename_characters_prefix_underscore(
input_filename: str,
) -> str:
r"""Replaces illegal chars; adds '*' prefix if original started with space."""
output_filename = input_filename.translate(CHARACTER_TRANSLATION_TABLE)

    # Check the *original* string for leading space before adding prefix
    result = (
        "_" + output_filename
        if input_filename.lstrip() != input_filename
        else output_filename
    )

    return result.strip()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

--- END OF FILE Utils/clean_name.py ---

--- START OF FILE Utils/dates.py ---
"""pixabit/utils/dates.py

# â”€â”€â”€ DATE MANAGER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Provides utility functions for date and time manipulation, specifically for
handling timestamps from the Habitica API. Includes functions for converting
timestamps to UTC or local time, and checking if a timestamp represents a
date/time in the past. Requires dateutil and tzlocal.

Modified: 2025.04.17 by vainilie.
"""

from datetime import datetime, timedelta, timezone
from typing import Optional

import dateutil.parser
from tzlocal import get_localzone

# Use themed console/print if available

try:
from .display import console, print

except ImportError: # Fallback
import builtins

    print = builtins.print

    # Provide a dummy console object to avoid AttributeErrors
    class DummyConsole:

        def print(self, *args, **kwargs):
            builtins.print(*args)

        def log(self, *args, **kwargs):
            builtins.print(*args)

    console = DummyConsole()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# FUNC â”€â”€â”€ Convert Timestamp To UTC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def convert_timestamp_to_utc(timestamp: Optional[str]) -> Optional[datetime]:
"""Converts an ISO 8601 timestamp string to a timezone-aware datetime object in UTC.

    Args:
        timestamp: The timestamp string  (e.g.,  "2023-10-27T10:00:00.000Z")  or None.

    Returns:
        A timezone-aware datetime object in UTC, or None  if  parsing  fails  or input is None.
    """
    if not timestamp:
        return None

    try:
        dt_object = dateutil.parser.isoparse(timestamp)

        # Ensure timezone-aware and converted to UTC
        return dt_object.astimezone(timezone.utc)

    except (ValueError, TypeError) as e:

        console.print(
            f"Invalid timestamp format '{timestamp}': {e}", style="warning"
        )
        return None

# FUNC â”€â”€â”€ Has Date Passed? â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def is_date_passed(timestamp: Optional[str]) -> Optional[bool]:
"""Checks if the date/time represented by the timestamp string is in the past.

    Args:
        timestamp: The timestamp string to check, or None.

    Returns:
        True if the timestamp is in the past, False if it's now or in the future.
        Returns None if the timestamp is invalid or None.
    """
    if not timestamp:
        return None

    utc_time = convert_timestamp_to_utc(timestamp)
    if utc_time is None:
        return None  # Invalid timestamp

    now_utc = datetime.now(timezone.utc)
    return utc_time < now_utc

# FUNC â”€â”€â”€ Convert UTF Into Local Time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def convert_to_local_time(utc_dt_str: Optional[str]) -> Optional[datetime]:
"""Converts a UTC timestamp string to a timezone-aware datetime object in
the local system timezone.

    Args:
        utc_dt_str: The timestamp string (assumed UTC or ISO 8601 with  tzinfo), or None.

    Returns:
        A  timezone-aware  datetime  object  in  local  timezone,   microseconds removed, or None on error/None input.
    """
    if not utc_dt_str:
        return None

    try:

        utc_time = dateutil.parser.isoparse(utc_dt_str)
        if utc_time.tzinfo is None:  # If naive, assume UTC
            utc_time = utc_time.replace(tzinfo=timezone.utc)

        local_timezone = get_localzone()
        return utc_time.astimezone(local_timezone).replace(microsecond=0)

    except (ValueError, TypeError) as e:

        console.print(
            f"Invalid timestamp format '{utc_dt_str}' for local conversion: {e}",
            style="warning",
        )
        return None

# FUNC â”€â”€â”€ Format Dimedelta Into Human-Readable â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def format_timedelta(delta: timedelta) -> str:
"""Formats a timedelta into a human-readable string (e.g., "in 2d 03:15:30"
or "1d 10:05:00 ago").
"""
is_past = delta.total_seconds() < 0

    if is_past:
        delta = -delta
        # Work with positive duration
        suffix = "ago"
    else:
        suffix = "in"

    days = delta.days
    total_seconds = delta.seconds
    hours, remainder = divmod(total_seconds, 3600)
    minutes, seconds = divmod(remainder, 60)

    parts = []
    if days > 0:
        parts.append(f"{days}d")

    # Always show H:M:S for consistency, even if days > 0
    parts.append(f"{hours:02}:{minutes:02}:{seconds:02}")

    if not parts:
        # Should not happen with H:M:S always present
        return "now"

    if is_past:
        return f"{' '.join(parts)} {suffix}"

    else:
        return f"{suffix} {' '.join(parts)}"

# FUNC â”€â”€â”€ Convert And Check Timestamp â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# & - def convert_and_check_timestamp(timestamp: str) -> Optional[str]:

def convert_and_check_timestamp(timestamp: Optional[str]) -> Optional[str]:
"""Converts timestamp to local time, checks if past/future, returns
formatted string.

    Args:
        timestamp: The timestamp to check (ISO 8601 format) or None.

    Returns:
        A string like "YYYY-MM-DD HH:MM:SS (in Xd HH:MM:SS)" or  "...  ago",  or None on error.
    """
    if not timestamp:
        return None

    local_time = convert_to_local_time(timestamp)

    if local_time is None:
        return f"Invalid Timestamp ({timestamp})"  # Return indication of error

    now_local = datetime.now(get_localzone()).replace(microsecond=0)
    time_difference = local_time - now_local
    formatted_diff = format_timedelta(time_difference)
    local_time_str = local_time.strftime("%Y-%m-%d %H:%M:%S")

    return f"{local_time_str} ({formatted_diff})"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

--- END OF FILE Utils/dates.py ---

--- START OF FILE Utils/display.py ---
"""pixabit/utils/display.py

# â”€â”€â”€ DISPLAY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Initializes and configures the Rich Console instance with a custom theme. Loads
theme definitions from a specified file ('styles' by default) and handles
potential loading errors by falling back to a default theme. Exports the
configured 'console' instance and commonly used Rich components for consistent
UI elements across the application.

Modified: 2025.04.17 by vainilie.
"""

import builtins
from pathlib import Path
from typing import Optional

from rich import box
from rich.columns import Columns
from rich.console import Console
from rich.layout import Layout
from rich.live import Live
from rich.markdown import Markdown
from rich.panel import Panel
from rich.progress import (
BarColumn,
Progress,
Spinner,
SpinnerColumn,
TaskProgressColumn,
TextColumn,
TimeElapsedColumn,
TimeRemainingColumn,
track,
)
from rich.prompt import Confirm, IntPrompt, Prompt
from rich.rule import Rule
from rich.syntax import Syntax
from rich.table import Table
from rich.text import Text
from rich.theme import Theme
from rich.traceback import install as install_traceback

try:
from art import text2art

    ART_AVAILABLE = True

except ImportError:
ART_AVAILABLE = False

# Assumes display.py is in utils/, styles file is at project root

try: # Go up two levels from utils/display.py to project root
base_dir = Path(**file**).resolve().parent
theme_file_path = base_dir / "styles"

except NameError: # Fallback if **file** is not defined (e.g. interactive testing)
theme_file_path = Path("styles")

# Look in CWD relative to execution

# Default theme dictionary (simplified fallback based on names in styles.txt)

default_theme_dict = {
"regular": "default",
"highlight": "bold #eb6f92",
"subtle": "dim #908caa",
"file": "underline #b4bdf8",
"info": "#cba6f7",
"warning": "bold #f6c177",
"danger": "bold #eb6f92 on #e0def4",
"error": "bold #f38ba8",
"success": "bold #a6e3a1",
"keyword": "bold #c4a7e7",
"link_style": "underline #89b4fa", # â”€â”€â”€ Component Styles â”€â”€â”€
"dim": "dim",
"rule.line": "#45475A",
"prompt.choices": "#94e2d5",
"prompt.default": "#7f849c",
"prompt.invalid": "#f38ba8",
"log.level.warning": "bold #f6c177",
"log.level.error": "bold #f38ba8",
"log.level.info": "#cba6f7",
"log.level.debug": "dim #908caa",
"repr.number": "#fab387",
"repr.str": "#a6e3a1",
"repr.bool_true": "bold #a6e3a1",
"repr.bool_false": "bold #f38ba8",
"repr.none": "dim #908caa",
"repr.url": "underline #89b4fa",
"progress.description": "#e0def4",
"progress.percentage": "#9ccfd8",
"progress.remaining": "#f6c177",
"bar.complete": "#a6e3a1",
"bar.finished": "#74c7ec",
"bar.pulse": "#f5c2e7",
"table.header": "bold #cba6f7", # â”€â”€â”€ RosÃ© Pine Colors â”€â”€â”€ # Add specific RosÃ© Pine theme colors if used directly
"rp_text": "#e0def4",
"rp_iris": "#c4a7e7",
"rp_foam": "#9ccfd8",
"rp_rose": "#ebbcba",
"rp_gold": "#f6c177",
"rp_pine": "#31748f",
"rp_love": "#eb6f92",
"rp_muted": "#6e6a86",
"rp_subtle_color": "#908caa",
"rp_surface": "#1f1d2e",
"rp_overlay": "#26233a", # â”€â”€â”€ Field Style â”€â”€â”€ # Added field style used in config_tags review table",
"field": "dim",
}
custom_theme: Optional[Theme] = None
console: Console
print_func = builtins.print # Default to standard print

if theme_file_path.exists(): # Check if the theme file exists and load it

    try:  # Load theme using Rich's Theme.from_file method

        with open(theme_file_path, encoding="utf-8") as tf:
            custom_theme = Theme.from_file(tf, source=str(theme_file_path))

        console = Console(theme=custom_theme)
        print_func = console.print  # Use console.print if theme loaded

        console.log(
            f"Successfully loaded theme from [file]{theme_file_path}[/]",
            style="success",
        )

    except Exception as e:

        builtins.print(f"â›” Error loading theme from {theme_file_path}: {e}")
        builtins.print("â›” Falling back to basic default theme.")
        custom_theme = Theme(default_theme_dict)  # Use basic dict fallback
        console = Console(theme=custom_theme)

else:

    builtins.print(
        f"â›” Theme file not found at {theme_file_path}. Using basic default theme."
    )

    custom_theme = Theme(default_theme_dict)  # Use basic dict fallback
    console = Console(theme=custom_theme)

# â”€â”€â”€ Pretty Tracebacks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Installs a handler to format tracebacks using Rich

install_traceback(
console=console,
show_locals=False, # Set show_locals=True for more detailed debugging
)

# â”€â”€â”€ Convenience Print â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Allows using `print` instead of `console.print` in other modules

\_print = console.print

def print(*args, \*\*kwargs):
"""Wrapper for console.print using the themed console."""
return \_print(*args, \*\*kwargs)

# â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Export the configured console instance and commonly used Rich components

# Other modules can import these directly from pixabit.utils.display

**all** = [
"console",
"print_func", # Keep original name for clarity if needed elsewhere
"print", # Export the wrapper function as 'print'
"Confirm",
"IntPrompt",
"Prompt",
"Table",
"Panel",
"Columns",
"Layout",
"Rule",
"box",
"Progress",
"track",
"Live",
"Spinner",
"BarColumn",
"TextColumn",
"TimeElapsedColumn",
"TimeRemainingColumn",
"TaskProgressColumn",
"SpinnerColumn",
"Markdown",
"Text",
"ART_AVAILABLE",
"text2art",
"Syntax",
]

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

--- END OF FILE Utils/display.py ---

--- START OF FILE Utils/generic_repr.py ---
"""pixabit/utils/generic_rep.py

# â”€â”€â”€ GENERIC REPR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Generates a string representation for any object, with its class name and
attributes.

Modified: 2025.04.17 by vainilie.
"""

import inspect
from typing import Any, get_type_hints

def generic_repr(obj: Any) -> str:
"""Generates a string representation of an object, including its class name
and attributes.

    Args:
        obj: The object to represent.

    Returns:
        A string representation of the object.
    """
    class_name = obj.__class__.__name__
    attributes = []
    type_hints = get_type_hints(obj.__class__)  # Get type hints for attributes

    for name, value in inspect.getmembers(obj):

        if (
            name.startswith("_")
            or inspect.ismethod(value)
            or inspect.isfunction(value)
        ):
            continue  # Skip private attributes and methods

        if name in type_hints:
            hint = type_hints[name]

        else:
            hint = None

        try:  # Handle different data types for better representation

            if isinstance(value, str):
                attributes.append(f"{name}='{value}'")

            elif isinstance(value, (list, tuple)):
                attributes.append(f"{name}={value}")

            elif isinstance(value, dict):
                attributes.append(f"{name}={value}")

            else:
                attributes.append(
                    f"{name}={repr(value)}"
                )  # Use repr for other types

        except Exception:
            attributes.append(f"{name}=<unknown>")  # Safe fallback

    return f"{class_name}({', '.join(attributes)})"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

""" class MyClass:
def **init**(self, name: str, age: int, data: Optional[list[str]] = None):
self.name = name
self.age = age
self.data = data
self.\_private = "secret" # Private attribute (will be skipped)

    def my_method(self):
        pass  # Method (will be skipped)

if **name** == "**main**":
my_object = MyClass("Alice", 30, ["a", "b"])
print(generic_repr(my_object))
"""

--- END OF FILE Utils/generic_repr.py ---

--- START OF FILE Utils/save_json.py ---
"""pixabit/utils/save_json.py

# â”€â”€â”€ SAVE JSON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Provides a utility function for saving Python data structures (dictionaries or
lists) into JSON files with pretty printing and proper encoding. Includes
directory creation and error handling.

Modified: 2025.04.17 by vainilie.
"""

import builtins
import json
from pathlib import Path
from typing import Any, Union

# Import console/print if needed for messages, assuming from .display

try:

    # Use the themed console instance if available
    from .display import console

    LOG_FUNC = console.print

except ImportError:

    # Fallback if display utils are missing or run standalone
    builtins.print(
        "Warning: Console/theme not found, using standard print for messages."
    )
    LOG_FUNC = builtins.print
    console = None  # Indicate console is not available

# FUNC â”€â”€â”€ Save Json â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def save_json(
data: Union[dict[str, Any], list[Any]], filepath: Union[str, Path]
) -> bool:
"""Saves Python data (dict or list) to a JSON file with pretty printing.

    Ensures the output directory exists. Handles  potential  JSON  serialization
    errors and file I/O errors, printing messages using the  themed  console  if
    available, otherwise standard print.

    Args:
        data: The Python dictionary or list to save.
        filepath: The full path (including filename and .json extension) for the output file, as a string or Path object.

    Returns:
        bool: True if saving was successful, False otherwise.
    """
    if not isinstance(filepath, Path):
        filepath = Path(filepath)  # Convert string path to Path object

    try:

        # Create parent directory(ies) if they don't exist
        filepath.parent.mkdir(parents=True, exist_ok=True)

        # Write the file with UTF-8 encoding and indentation
        with open(filepath, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=4, ensure_ascii=False)

        if console:  # Use LOG_FUNC (either console.print or builtins.print)

            LOG_FUNC(
                f"[success]Successfully saved data to:[/success] [file]'{filepath}'[/]"
            )

        else:
            LOG_FUNC(f"Successfully saved data to: '{filepath}'")

        return True

    except TypeError as e:  # Handle non-serializable data
        msg = f"Data structure not JSON serializable for '{filepath}'. {e}"

        if console:
            LOG_FUNC(f"[error]Error:[/error] {msg}", style="error")

        else:
            LOG_FUNC(f"ERROR: {msg}")

        return False

    except OSError as e:  # Handle file system errors
        msg = f"Could not write file '{filepath}': {e}"

        if console:
            LOG_FUNC(f"[error]Error:[/error] {msg}", style="error")

        else:
            LOG_FUNC(f"ERROR: {msg}")

        return False

    except Exception as e:  # Catch any other unexpected errors

        msg = f"An unexpected error occurred saving to '{filepath}': {e}"

        if console:
            LOG_FUNC(f"[error]Error:[/error] {msg}", style="error")

        # Optional: Print traceback for unexpected errors if console exists
        # console.print_exception(show_locals=False)

        else:
            LOG_FUNC(f"ERROR: {msg}")

        return False

# MARK: - LOAD JSON FUNCTION

# & - def load_json(...) -> Optional[Union[Dict, List]]: - ADDED/REFINED

def load_json(filepath: Union[str, Path]) -> Optional[Union[Dict, List]]:
"""Loads data from a JSON file. Returns None on error or if file not found."""
if not isinstance(filepath, Path):
filepath = Path(filepath)
if not filepath.exists():
if console:
console.log(
f"Cache file not found: [file]'{filepath}'[/]", style="subtle"
)
return None
try:
with filepath.open("r", encoding="utf-8") as f:
data = json.load(f)
if isinstance(data, (dict, list)):
if console:
console.log(
f"Loaded data from cache: [file]'{filepath}'[/]",
style="info",
)
return data
else: # Invalid data type in file
if console:
console.log(
f"Invalid data type ({type(data)}) in cache file: [file]'{filepath}'[/]",
style="warning",
)
return None
except (OSError, json.JSONDecodeError, Exception) as e:
msg = f"Failed to load/parse cache file '{filepath}': {e}"
if console:
LOG_FUNC(f"[warning]Warning:[/warning] {msg}")
else:
LOG_FUNC(f"WARNING: {msg}")
return None

--- END OF FILE Utils/save_json.py ---

--- START OF FILE Utils/styles ---

# pixabit/utils/styles

# â”€â”€â”€ STYLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Modified: 2025.04.17 by vainilie.

[styles]

# â”€â”€â”€ Base Palette â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Catppuccin Macchiato / RosÃ© Pine inspired.

# Not directly used as styles, but for reference.

# crust = #11111B

# mantle = #181825

# base = #1E1E2E

# surface0 = #313244

# surface1 = #45475A

# surface2 = #585B70

# overlay0 = #6C7086

# overlay1 = #7F849C

# overlay2 = #9399B2

# text = #CDD6F4

# subtext0 = #A6ADC8

# subtext1 = #BAC2DE

# rosewater = #F5E0DC

# flamingo = #F2CDCD

# pink = #F5C2E7

# mauve = #CBA6F7

# red = #F38BA8

# maroon = #EBA0AC

# peach = #FAB387

# yellow = #F9E2AF

# green = #A6E3A1

# teal = #94E2D5

# sky = #89DCEB

# sapphire = #74C7EC

# blue = #89B4FA

# lavender = #B4BDF8

# rp_base = #191724

# rp_surface = #1f1d2e

# rp_overlay = #26233a

# rp_highlightLow = #21202e

# rp_highlightMed = #403d52

# rp_highlightHigh = #524f67

# rp_muted = #6e6a86

# rp_subtle_color = #908caa

# rp_text = #e0def4

# rp_love = #eb6f92

# rp_gold = #f6c177

# rp_rose = #ebbcba

# rp_pine = #31748f

# rp_foam = #9ccfd8

# rp_iris = #c4a7e7

# â”€â”€â”€ Semantic Styles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

regular = default
highlight = bold #eb6f92
subtle = dim #908caa
file = underline #b4bdf8
info = #cba6f7
warning = bold #f6c177
danger = bold #eb6f92 on #e0def4
error = bold #f38ba8
success = bold #a6e3a1
keyword = bold #c4a7e7
link_style = underline #89b4fa

# â”€â”€â”€ Component Styles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

dim = dim
rule.line = #45475A
prompt.choices = #94e2d5
prompt.default = #7f849c
prompt.invalid = #f38ba8
log.level.warning = bold #f6c177
log.level.error = bold #f38ba8
log.level.info = #cba6f7
log.level.debug = dim #908caa
repr.number = #fab387
repr.str = #a6e3a1
repr.bool_true = bold #a6e3a1
repr.bool_false = bold #f38ba8
repr.none = dim #908caa
repr.url = underline #89b4fa
progress.description = #e0def4
progress.percentage = #9ccfd8
progress.remaining = #f6c177
bar.complete = #a6e3a1
bar.finished = #74c7ec
bar.pulse = #f5c2e7
table.header = bold #cba6f7

# â”€â”€â”€ RosÃ© Pine Colors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Add specific RosÃ© Pine theme colors if used directly

rp_text = #e0def4
rp_iris = #c4a7e7
rp_foam = #9ccfd8
rp_rose = #ebbcba
rp_gold = #f6c177
rp_pine = #31748f
rp_love = #eb6f92
rp_muted = #6e6a86
rp_subtle_color = #908caa
rp_surface = #1f1d2e
rp_overlay = #26233a

# â”€â”€â”€ Field Style â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Added field style used in config_tags review table

field = dim

--- END OF FILE Utils/styles ---

--- START OF FILE models/challenge.py ---

# pixabit/models/challenge.py

"""Defines data class for representing Habitica Challenges and a container class."""

# MARK: - IMPORTS

from datetime import datetime
from typing import Any, Optional

import emoji_data_python

# Assuming utility function exists

from ..utils.dates import convert_timestamp_to_utc

# Assuming Task class and TaskList class are defined elsewhere and imported

# Use placeholder classes if running standalone

try:
from .task import ( # Make sure ChallengeData is also available if used
ChallengeData,
Task,
TaskList,
)
except ImportError: # Placeholder classes for standalone execution/testing
print("Warning: Using placeholder Task/TaskList classes.")

    class ChallengeData:
        def __init__(self, data):
            self.id = data.get("id")

    class Task:
        def __init__(self, data):
            self.id = data.get("_id")
            self.type = data.get("type")
            self.text = data.get("text", "")
            challenge_info = data.get("challenge", {})
            self.challenge: Optional[ChallengeData] = (
                ChallengeData(challenge_info) if challenge_info else None
            )

        def __repr__(self):
            return f"Task(id={self.id})"

    class TaskList:
        def __init__(self, raw_tasks, **kwargs):
            self.tasks = [Task(t) for t in raw_tasks]

        def __iter__(self):
            return iter(self.tasks)

# --- Challenge Data Class ---

# KLASS: - Challenge (Reviewed and Cleaned)

class Challenge:
"""Represents a Habitica Challenge."""

    def __init__(self, challenge_data: dict[str, Any]):
        """Initializes a Challenge object from API data. Tasks are added separately."""
        if not isinstance(challenge_data, dict):
            # Or return None, or handle differently
            raise TypeError("challenge_data must be a dictionary.")

        self.id: Optional[str] = challenge_data.get("id") or challenge_data.get(
            "_id"
        )
        self.name: str = emoji_data_python.replace_colons(
            challenge_data.get("name", "Unnamed Challenge")
        )
        self.short_name: Optional[str] = emoji_data_python.replace_colons(
            challenge_data.get("shortName")
        )  # Can be None
        self.summary: str = emoji_data_python.replace_colons(
            challenge_data.get("summary", "")
        )
        self.description: str = emoji_data_python.replace_colons(
            challenge_data.get("description", "")
        )

        # Leader Info
        leader_info = emoji_data_python.replace_colons(
            challenge_data.get("leader")
        )  # API might just send ID string
        self.leader_id: Optional[str] = (
            leader_info
            if isinstance(leader_info, str)
            else (
                leader_info.get("_id")
                if isinstance(leader_info, dict)
                else None
            )
        )
        # TODO: Consider storing leader name if available in leader_info dict

        # Group Info
        group_info = challenge_data.get("group", {})
        self.group_id: Optional[str] = (
            group_info.get("_id") if isinstance(group_info, dict) else None
        )
        self.group_name: Optional[str] = (
            emoji_data_python.replace_colons(group_info.get("name"))
            if isinstance(group_info, dict)
            else None
        )
        self.group_type: Optional[str] = (
            group_info.get("type")
            if isinstance(group_info, dict)
            else None  # 'party', 'guild', 'tavern'
        )

        # Other Attributes
        self.prize: int = int(challenge_data.get("prize", 0))
        self.member_count: int = challenge_data.get("memberCount", 0)
        self.official: bool = challenge_data.get("official", False)
        self.created_at: Optional[datetime] = convert_timestamp_to_utc(
            challenge_data.get("createdAt")
        )
        self.updated_at: Optional[datetime] = convert_timestamp_to_utc(
            challenge_data.get("updatedAt")
        )
        self.broken: Optional[str] = challenge_data.get(
            "broken"
        )  # e.g., "CHALLENGE_DELETED"
        self.owned: Optional[bool] = challenge_data.get(
            "owned"
        )  # If fetched for a specific user context

        # Determine if legacy (example logic, adjust if needed)
        # Tavern challenges aren't really 'legacy', maybe check creation date?
        self.is_legacy: bool = (
            self.group_type != "tavern" and self.group_id != "habiticatesters"
        )  # Example logic

        # Task container - populated externally by ChallengeList._link_tasks
        self.tasks: list[Task] = []

    def add_tasks(self, tasks_to_add: list[Task]) -> None:
        """Adds a list of Task objects associated with this challenge."""
        # Basic check to add only Task instances
        self.tasks.extend(
            task for task in tasks_to_add if isinstance(task, Task)
        )
        # Optionally sort tasks after adding
        # self.tasks.sort(key=lambda t: (t.type, getattr(t, 'position', 0)))

    def get_tasks_by_type(self, task_type: str) -> list[Task]:
        """Returns a list of tasks belonging to this challenge of a specific type."""
        return [task for task in self.tasks if task.type == task_type]

    def __repr__(self) -> str:
        """Developer-friendly representation."""
        status = f" ({self.broken})" if self.broken else ""
        task_count = len(self.tasks)
        return f"Challenge(id='{self.id}', name='{self.name[:30]}'..., tasks={task_count}{status})"

# --- Challenge List Container ---

# KLASS: - ChallengeList

class ChallengeList:
"""Container for managing a list of Challenge objects with filtering and task linking."""

    def __init__(
        self,
        raw_challenge_list: list[dict[str, Any]],
        task_list: Optional[TaskList] = None,
    ):
        """Initializes the ChallengeList by processing raw challenge dictionaries
        and optionally linking tasks from a TaskList.

        Args:
            raw_challenge_list: List of dictionaries (raw challenge data from API).
            task_list: An optional TaskList instance containing processed Task objects.
                       If provided, tasks will be linked to their respective challenges.
        """
        self.challenges: list[Challenge] = []
        self._process_list(raw_challenge_list)

        # Link tasks if a TaskList was provided
        if task_list is not None:
            self._link_tasks(task_list)

    def _process_list(self, raw_challenge_list: list[dict[str, Any]]) -> None:
        """Processes the raw list, creating Challenge instances."""
        processed_challenges: list[Challenge] = []
        for raw_challenge in raw_challenge_list:
            if not isinstance(raw_challenge, dict):
                continue  # Skip invalid entries
            try:
                challenge_instance = Challenge(raw_challenge)
                if challenge_instance.id:  # Only add valid challenges with ID
                    processed_challenges.append(challenge_instance)
            except Exception as e:
                print(
                    f"Error processing challenge data: {raw_challenge.get('id', 'N/A')}. Error: {e}"
                )
        self.challenges = processed_challenges

    def _link_tasks(self, task_list: TaskList) -> None:
        """Links Task objects from the provided TaskList to the corresponding Challenge objects.
        Assumes Task objects have a 'challenge' attribute with challenge ID info.
        """
        # Create a map for faster challenge lookup
        challenges_by_id: dict[str, Challenge] = {
            chal.id: chal for chal in self.challenges if chal.id
        }

        # Clear existing tasks lists in challenges before linking
        for challenge in self.challenges:
            challenge.tasks = []

        # Iterate through all tasks in the TaskList
        for task in task_list:  # Assuming TaskList is iterable
            # Check if the task belongs to a challenge and has the necessary info
            if task.challenge and task.challenge.id:
                challenge_id = task.challenge.id
                # Find the corresponding challenge object in our list
                target_challenge = challenges_by_id.get(challenge_id)
                if target_challenge:
                    # Add the task object to that challenge's task list
                    target_challenge.tasks.append(task)  # Directly append

        # Optional: Sort tasks within each challenge after linking all of them
        # for challenge in self.challenges:
        #     challenge.tasks.sort(key=lambda t: (t.type, getattr(t, 'position', 0)))

    # --- Access and Filtering Methods ---

    def __len__(self) -> int:
        """Returns the number of challenges."""
        return len(self.challenges)

    def __iter__(self):
        """Allows iterating over the challenges."""
        return iter(self.challenges)

    def __getitem__(self, index: int) -> Challenge:
        """Allows accessing challenges by index."""
        return self.challenges[index]

    def get_by_id(self, challenge_id: str) -> Optional[Challenge]:
        """Finds a challenge by its ID."""
        for challenge in self.challenges:
            if challenge.id == challenge_id:
                return challenge
        return None

    def filter_by_name(
        self, name_part: str, case_sensitive: bool = False
    ) -> list[Challenge]:
        """Filters challenges by name containing name_part."""
        if not case_sensitive:
            name_part = name_part.lower()
            return [c for c in self.challenges if name_part in c.name.lower()]
        else:
            return [c for c in self.challenges if name_part in c.name]

    def filter_by_short_name(self, short_name: str) -> list[Challenge]:
        """Filters challenges by exact short name."""
        return [c for c in self.challenges if c.short_name == short_name]

    def filter_by_leader(self, leader_id: str) -> list[Challenge]:
        """Filters challenges by leader's user ID."""
        return [c for c in self.challenges if c.leader_id == leader_id]

    def filter_by_group(
        self, group_id: Optional[str] = None, group_type: Optional[str] = None
    ) -> list[Challenge]:
        """Filters challenges by group ID and/or group type."""
        filtered = self.challenges
        if group_id is not None:
            filtered = [c for c in filtered if c.group_id == group_id]
        if group_type is not None:
            filtered = [c for c in filtered if c.group_type == group_type]
        return filtered

    def filter_by_official(self, official: bool = True) -> list[Challenge]:
        """Filters for official or unofficial challenges."""
        return [c for c in self.challenges if c.official == official]

    def filter_broken(self, is_broken: bool = True) -> list[Challenge]:
        """Filters challenges based on whether they have a 'broken' status."""
        if is_broken:
            return [c for c in self.challenges if c.broken is not None]
        else:
            return [c for c in self.challenges if c.broken is None]

    def filter_owned(self, owned: bool = True) -> list[Challenge]:
        """Filters challenges based on the 'owned' flag (if available)."""
        return [c for c in self.challenges if c.owned == owned]

    def filter_legacy(self, is_legacy: bool = True) -> list[Challenge]:
        """Filters challenges based on the calculated 'is_legacy' flag."""
        return [c for c in self.challenges if c.is_legacy == is_legacy]

    def filter_by_task_count(
        self, min_tasks: int = 1, max_tasks: float = float("inf")
    ) -> list[Challenge]:
        """Filters challenges by the number of linked tasks."""
        return [
            c for c in self.challenges if min_tasks <= len(c.tasks) <= max_tasks
        ]

    def filter_containing_task_id(self, task_id: str) -> list[Challenge]:
        """Filters challenges that contain a specific task ID in their linked tasks."""
        # Ensure tasks are linked before calling this
        return [
            c
            for c in self.challenges
            if any(task.id == task_id for task in c.tasks)
        ]

# --- Example Usage ---

if **name** == "**main**": # --- Example Raw Data --- # 1. Raw Task Data (including challenge info within tasks)
raw_task_data = [
{
"_id": "task1_c1",
"type": "daily",
"text": "Daily Task for Challenge 1",
"challenge": {"id": "chall1", "taskId": "task1_c1"},
},
{
"_id": "task2_c1",
"type": "habit",
"text": "Habit Task for Challenge 1",
"challenge": {"id": "chall1", "taskId": "task2_c1"},
},
{
"_id": "task3_c2",
"type": "todo",
"text": "Todo Task for Challenge 2",
"challenge": {"id": "chall2", "taskId": "task3_c2"},
},
{
"_id": "task4_orphan",
"type": "reward",
"text": "Reward not in a challenge",
"challenge": {},
}, # Task not linked or challenge info missing
{
"_id": "task5_c1",
"type": "daily",
"text": "Another Daily for Challenge 1",
"challenge": {"id": "chall1", "taskId": "task5_c1"},
},
]

    # 2. Raw Challenge Data
    raw_challenge_data = [
        {
            "id": "chall1",
            "name": "My First Awesome Challenge",
            "shortName": "first-chall",
            "leader": "user-leader-1",
            "group": {
                "_id": "group1",
                "name": "The Adventurers",
                "type": "party",
            },
            "memberCount": 15,
            "official": False,
        },
        {
            "id": "chall2",
            "name": "Official Habitica Workout",
            "shortName": "habitica-workout",
            "leader": "habitica",
            "group": {
                "_id": "habiticaguild",
                "name": "Habitica Official",
                "type": "guild",
            },
            "memberCount": 1050,
            "official": True,
            "prize": 5,
        },
        {
            "id": "chall3",
            "name": "Broken Test Challenge",
            "shortName": "broken-test",
            "leader": "user-leader-2",
            "group": {"_id": "group2", "name": "Test Group", "type": "party"},
            "memberCount": 3,
            "official": False,
            "broken": "CHALLENGE_DELETED",
        },
        {
            "id": "chall4",
            "name": "Tavern Challenge",
            "shortName": "tavern-fun",
            "leader": "user-leader-3",
            "group": {"_id": "tavern", "name": "Tavern", "type": "tavern"},
            "memberCount": 999,
            "official": False,
        },  # Example Tavern challenge
    ]

    # --- Processing ---
    # 1. Create the TaskList (processes raw task data)
    task_list = TaskList(raw_task_data)

    # 2. Create the ChallengeList, passing the TaskList to link tasks
    challenge_list = ChallengeList(raw_challenge_data, task_list=task_list)

    print(f"--- Processed Challenges ({len(challenge_list)}) ---")
    for challenge in challenge_list:
        # Print challenge repr (which now includes task count)
        print(f"  {challenge}")
        # Optionally print linked tasks for verification
        # print(f"    Tasks: {challenge.tasks}")
    print("-" * 20)

    # --- Filtering Examples ---
    print("\n--- Filtering Examples ---")

    official_challenges = challenge_list.filter_by_official(True)
    print(
        f"Official Challenges ({len(official_challenges)}): {official_challenges}"
    )

    party_challenges = challenge_list.filter_by_group(group_type="party")
    print(f"Party Challenges ({len(party_challenges)}): {party_challenges}")

    broken_challenges = challenge_list.filter_broken(True)
    print(f"Broken Challenges ({len(broken_challenges)}): {broken_challenges}")

    challenge1 = challenge_list.get_by_id("chall1")
    if challenge1:
        print(f"\nChallenge 'chall1' found: {challenge1}")
        dailies_in_chall1 = challenge1.get_tasks_by_type("daily")
        print(
            f"  Dailies in Challenge 1 ({len(dailies_in_chall1)}): {dailies_in_chall1}"
        )

    challenges_with_2plus_tasks = challenge_list.filter_by_task_count(
        min_tasks=2
    )
    print(
        f"\nChallenges with >= 2 tasks ({len(challenges_with_2plus_tasks)}): {challenges_with_2plus_tasks}"
    )

    challenges_with_task1 = challenge_list.filter_containing_task_id("task1_c1")
    print(
        f"\nChallenges containing task 'task1_c1' ({len(challenges_with_task1)}): {challenges_with_task1}"
    )

    # legacy_challenges = challenge_list.filter_legacy(True)
    # print(f"\nLegacy Challenges ({len(legacy_challenges)}): {legacy_challenges}")

--- END OF FILE models/challenge.py ---

--- START OF FILE models/message.py ---

# pixabit/models/message.py

# MARK: - MODULE DOCSTRING

"""Defines data classes for representing Habitica messages and a container class."""

# MARK: - IMPORTS

from collections import defaultdict # Import defaultdict
from datetime import datetime, timezone # Added timezone
from typing import Any, Optional

import emoji_data_python

# Assuming utility function exists

# from ..utils.dates import convert_timestamp_to_utc

def convert_timestamp_to_utc(ts: Optional[Any]) -> Optional[datetime]: # Placeholder implementation - use your actual function
if isinstance(ts, str):
try:
if ts.endswith("Z"):
ts = ts[:-1] + "+00:00"
dt = datetime.fromisoformat(ts)
if dt.tzinfo is None:
return dt.replace(tzinfo=datetime.timezone.utc)
else:
return dt.astimezone(datetime.timezone.utc)
except ValueError:
return None
elif isinstance(ts, (int, float)): # Handle timestamps
try:
if ts > 1e10:
ts /= 1000.0 # Assume ms if large
return datetime.fromtimestamp(ts, tz=datetime.timezone.utc)
except (ValueError, TypeError, OSError):
return None
return None

# --- Message Data Class ---

# KLASS: - Message (Refined)

class Message:
"""Represents an individual message in Habitica (Inbox or Group Chat).

    Attributes are parsed from Habitica API responses, with some ambiguity noted.
    """

    def __init__(
        self,
        message_data: dict[str, Any],
        current_user_id: Optional[str] = None,
    ):
        """Initializes a Message object from API data."""
        if not isinstance(message_data, dict):
            raise TypeError("message_data must be a dictionary.")

        # Core IDs
        self.id: Optional[str] = message_data.get("_id") or message_data.get(
            "id"
        )  # Document/Message ID
        self.sender_id: Optional[str] = message_data.get(
            "uuid"
        )  # Sender's User ID (usually 'uuid' in API)
        self.sent_by_me: Optional[bool] = message_data.get("sent")
        # Content and Timestamp
        self.text: str = emoji_data_python.replace_colons(
            message_data.get("text", "")
        )
        self.unformatted_text: Optional[str] = emoji_data_python.replace_colons(
            message_data.get("unformattedText")
        )
        self.timestamp: Optional[datetime] = convert_timestamp_to_utc(
            message_data.get("timestamp")
        )

        # Engagement
        self.likes: dict[str, bool] = message_data.get(
            "likes", {}
        )  # Keys are user IDs
        self.flags: dict[str, bool] = message_data.get(
            "flags", {}
        )  # Keys are user IDs
        self.flag_count: int = message_data.get("flagCount", 0)

        # Context: Group or PM?
        self.group_id: Optional[str] = message_data.get(
            "groupId"
        )  # 'party', 'tavern', guild ID

        # Sender Info (often included directly in message objects)
        self.sender_display_name: Optional[str] = (
            emoji_data_python.replace_colons(message_data.get("user"))
        )
        self.sender_username: Optional[str] = message_data.get("username")
        self.sender_styles: Optional[dict[str, Any]] = message_data.get(
            "userStyles"
        )
        self.sender_class: Optional[str] = (
            message_data.get("userStyles", {})
            .get("stats", {})
            .get("class", "civil")
        )
        # System Message Info (for spells, quests, etc.)
        self.info: Optional[dict[str, Any]] = message_data.get("info")
        # class, spell, times, type, user, quest, bossDamage, userDamage, target, items (cancerRune, moonRune, silverIngot)
        # --- Calculated/Derived Attributes ---
        self.is_system_message: bool = bool(
            self.info
        )  # True if 'info' field exists/is populated

        # Conversation ID (for grouping PMs or identifying group chat)
        self.conversation_id: Optional[str] = None
        self._determine_conversation_id(message_data, current_user_id)

        # Recipient ID (mainly relevant for PMs, potentially in 'ownerId')
        # 'ownerId' might represent the owner of the inbox copy, i.e., the recipient.
        self.recipient_id: Optional[str] = message_data.get("ownerId")

    def _determine_conversation_id(
        self, message_data: dict[str, Any], current_user_id: Optional[str]
    ):
        """Calculates a consistent ID for the conversation this message belongs to."""
        if self.group_id:
            # For group messages, the group ID is the conversation ID
            self.conversation_id = self.group_id
        else:
            # Assume Private Message (PM) if no group_id
            # The conversation ID is typically the *other* user's ID.
            # We need the current user's ID to determine the 'other'.
            sender = self.sender_id
            # Potential recipient ID might be in ownerId if fetched from user's inbox
            recipient_in_data = message_data.get("ownerId")

            if current_user_id:
                if sender == current_user_id:
                    # Current user sent it, conversation is with recipient
                    # If recipient isn't explicitly known, this might be tricky.
                    # Let's assume 'ownerId' might hold the recipient if available.
                    # If ownerId is also the current user (their copy), we need another way.
                    # This logic heavily depends on the API endpoint source.
                    # Fallback: Use a unique message ID if conversation cannot be inferred.
                    # A common PM key is often the other user's ID. If ownerId is recipient, use it.
                    self.conversation_id = (
                        recipient_in_data
                        if recipient_in_data != current_user_id
                        else sender
                    )  # Default to sender if recipient unclear
                elif sender:
                    # Someone else sent it, conversation is with the sender
                    self.conversation_id = sender
                else:
                    # Cannot determine other party without sender and context
                    # Fallback: Use unique message ID if available
                    self.conversation_id = message_data.get("id")  # Or _id
            else:
                # No current user context, cannot reliably determine PM conversation ID
                # Fallback: Use unique message ID if available
                self.conversation_id = message_data.get("id")  # Or _id

    def __repr__(self) -> str:
        """Developer-friendly representation."""
        sender = (
            self.sender_username or self.sender_id or "System"
            if self.is_system_message
            else "Unknown"
        )
        ts = (
            self.timestamp.strftime("%Y-%m-%d %H:%M")
            if self.timestamp
            else "No Timestamp"
        )
        conv_id_str = (
            f" (Conv: {self.conversation_id})" if self.conversation_id else ""
        )
        text_preview = self.text[:30].replace("\n", " ") + (
            "..." if len(self.text) > 30 else ""
        )
        return f"Message(id={self.id}, from='{sender}', time='{ts}{conv_id_str}', text='{text_preview}')"

# --- Message List Container ---

# KLASS: - MessageList

class MessageList:
"""Container for managing a list of Message objects with processing and filtering."""

    def __init__(
        self,
        raw_message_list: list[dict[str, Any]],
        current_user_id: Optional[str] = None,
    ):
        """Initializes the MessageList, processing raw message dictionaries.

        Args:
            raw_message_list: List of dictionaries (raw message data from API).
            current_user_id: The UUID of the user viewing the messages. Needed
                             to correctly determine conversation IDs for PMs.
        """
        self.messages: list[Message] = []
        self.current_user_id = current_user_id
        self._process_list(raw_message_list)

    def _process_list(self, raw_message_list: list[dict[str, Any]]) -> None:
        """Processes the raw list, creating Message instances."""
        processed_messages: list[Message] = []
        for raw_message in raw_message_list:
            if not isinstance(raw_message, dict):
                continue
            try:
                # Pass current_user_id for conversation ID calculation
                message_instance = Message(raw_message, self.current_user_id)
                if message_instance.id:  # Require an ID
                    processed_messages.append(message_instance)
            except Exception as e:
                print(
                    f"Error processing message data: {raw_message.get('id', 'N/A')}. Error: {e}"
                )

        # Sort messages chronologically
        processed_messages.sort(
            key=lambda m: m.timestamp
            or datetime.min.replace(tzinfo=timezone.utc)
        )
        self.messages = processed_messages

    # --- Access and Filtering Methods ---

    def __len__(self) -> int:
        """Returns the number of messages."""
        return len(self.messages)

    def __iter__(self):
        """Allows iterating over the messages."""
        return iter(self.messages)

    def __getitem__(self, index: int) -> Message:
        """Allows accessing messages by index."""
        return self.messages[index]

    def get_by_id(self, message_id: str) -> Optional[Message]:
        """Finds a message by its ID."""
        for message in self.messages:
            if message.id == message_id:
                return message
        return None

    def filter_by_sender(self, sender_id: str) -> list[Message]:
        """Returns messages sent by a specific user ID."""
        return [m for m in self.messages if m.sender_id == sender_id]

    def filter_by_conversation(self, conversation_id: str) -> list[Message]:
        """Returns messages belonging to a specific conversation.
        For groups, this is the group_id.
        For PMs, this is usually the other user's ID.
        """
        return [
            m for m in self.messages if m.conversation_id == conversation_id
        ]

    def filter_by_group(self, group_id: str) -> list[Message]:
        """Returns messages belonging to a specific group ID."""
        # Same as filter_by_conversation if conversation_id is group_id for groups
        return [m for m in self.messages if m.group_id == group_id]

    def filter_private_messages(self) -> list[Message]:
        """Returns messages that are likely Private Messages (no group_id)."""
        return [m for m in self.messages if m.group_id is None]

    def filter_system_messages(self, is_system: bool = True) -> list[Message]:
        """Returns system messages (or non-system messages)."""
        return [m for m in self.messages if m.is_system_message == is_system]

    def filter_by_text(
        self, text_part: str, case_sensitive: bool = False
    ) -> list[Message]:
        """Filters messages containing specific text."""
        if not case_sensitive:
            text_part = text_part.lower()
            return [m for m in self.messages if text_part in m.text.lower()]
        else:
            return [m for m in self.messages if text_part in m.text]

    def filter_by_date_range(
        self, start: Optional[datetime] = None, end: Optional[datetime] = None
    ) -> list[Message]:
        """Filters messages within a specific date/time range (inclusive)."""
        # Ensure start/end are timezone-aware (assume UTC if naive)
        start_utc = None
        if start:
            start_utc = (
                start if start.tzinfo else start.replace(tzinfo=timezone.utc)
            )
        end_utc = None
        if end:
            end_utc = end if end.tzinfo else end.replace(tzinfo=timezone.utc)

        filtered = []
        for m in self.messages:
            if not m.timestamp:
                continue  # Skip messages without timestamp
            ts_utc = m.timestamp  # Already UTC

            if start_utc and ts_utc < start_utc:
                continue
            if end_utc and ts_utc > end_utc:
                continue
            filtered.append(m)
        return filtered

    def filter_liked_by(self, user_id: str) -> list[Message]:
        """Returns messages liked by a specific user ID."""
        return [m for m in self.messages if user_id in m.likes]

    def filter_flagged(self, min_flags: int = 1) -> list[Message]:
        """Returns messages flagged at least min_flags times."""
        return [m for m in self.messages if m.flag_count >= min_flags]

    def get_conversations(self) -> dict[str, list[Message]]:
        """Groups all messages by their calculated conversation ID.

        Returns:
            A dictionary where keys are conversation IDs and values are lists
            of Message objects belonging to that conversation, sorted by time.
        """
        convos: dict[str, list[Message]] = defaultdict(list)
        for msg in self.messages:
            if msg.conversation_id:
                convos[msg.conversation_id].append(msg)
        # Messages within each convo are already sorted overall by timestamp
        return dict(convos)  # Return standard dict

# --- Example Usage ---

if **name** == "**main**": # --- Example Raw Data --- # Assume MY_USER_ID is the ID of the user whose messages these are
MY_USER_ID = "user-me"

    raw_data = [
        # PM from user-friend-1
        {
            "_id": "pm1",
            "uuid": "user-friend-1",
            "ownerId": MY_USER_ID,
            "text": "Hey, how are you?",
            "timestamp": "2025-04-17T10:00:00.000Z",
            "likes": {},
        },
        # PM reply to user-friend-1
        {
            "_id": "pm2",
            "uuid": MY_USER_ID,
            "ownerId": "user-friend-1",
            "text": "Doing great! You?",
            "timestamp": "2025-04-17T10:05:00.000Z",
            "likes": {"user-friend-1": True},
        },
        # Group chat message in 'party'
        {
            "_id": "gc1",
            "groupId": "party",
            "uuid": "user-party-member",
            "user": "Party Pal",
            "username": "partypal",
            "text": "Let's do the quest!",
            "timestamp": "2025-04-17T11:00:00.000Z",
            "likes": {MY_USER_ID: True},
        },
        # Another PM from user-friend-1
        {
            "_id": "pm3",
            "uuid": "user-friend-1",
            "ownerId": MY_USER_ID,
            "text": "Want to join the challenge?",
            "timestamp": "2025-04-17T11:15:00.000Z",
            "likes": {},
            "flagCount": 1,
            "flags": {"user-someone": True},
        },
        # System message in party
        {
            "_id": "sys1",
            "groupId": "party",
            "text": "`System message: Quest started!`",
            "timestamp": "2025-04-17T11:01:00.000Z",
            "likes": {},
            "info": {"type": "quest_start", "quest": "quest_key"},
        },
        # Group chat message from me in 'party'
        {
            "_id": "gc2",
            "groupId": "party",
            "uuid": MY_USER_ID,
            "user": "Me Myself",
            "username": "me_user",
            "text": "Okay, joining now.",
            "timestamp": "2025-04-17T11:02:00.000Z",
            "likes": {},
        },
        # PM from another user
        {
            "_id": "pm4",
            "uuid": "user-another",
            "ownerId": MY_USER_ID,
            "text": "Quick question about...",
            "timestamp": "2025-04-17T12:00:00.000Z",
            "likes": {},
        },
    ]

    # --- Processing ---
    message_list = MessageList(raw_data, current_user_id=MY_USER_ID)

    print(f"--- Processed Messages ({len(message_list)}) ---")
    for msg in message_list:
        print(msg)
    print("-" * 20)

    # --- Filtering Examples ---
    print("\n--- Filtering Examples ---")

    party_chat = message_list.filter_by_group("party")
    print(f"Party Chat Messages ({len(party_chat)}): {party_chat}")

    friend1_pm_thread = message_list.filter_by_conversation("user-friend-1")
    print(
        f"\nPM Conversation with user-friend-1 ({len(friend1_pm_thread)}): {friend1_pm_thread}"
    )

    my_sent_messages = message_list.filter_by_sender(MY_USER_ID)
    print(
        f"\nMessages Sent By Me ({len(my_sent_messages)}): {my_sent_messages}"
    )

    messages_with_quest = message_list.filter_by_text(
        "quest", case_sensitive=False
    )
    print(
        f"\nMessages containing 'quest' ({len(messages_with_quest)}): {messages_with_quest}"
    )

    system_messages = message_list.filter_system_messages(True)
    print(f"\nSystem Messages ({len(system_messages)}): {system_messages}")

    flagged_messages = message_list.filter_flagged(min_flags=1)
    print(f"\nFlagged Messages ({len(flagged_messages)}): {flagged_messages}")

    # --- Getting Conversations ---
    print("\n--- All Conversations ---")
    all_conversations = message_list.get_conversations()
    for convo_id, messages in all_conversations.items():
        print(f"Conversation ID: {convo_id} ({len(messages)} messages)")
        # for msg in messages[:3]: # Print first few messages
        #     print(f"  {msg}")

--- END OF FILE models/message.py ---

--- START OF FILE models/party.py ---

# pixabit/models/party.py

# MARK: - MODULE DOCSTRING

"""Defines data classes for representing a Habitica Party and its quest status."""

# MARK: - IMPORTS

from typing import Any, Optional # Added Union

import emoji_data_python

# Assuming MessageList is defined elsewhere and can be imported

from .message import MessageList

# Placeholder if running standalone

try:
from .message import MessageList
except ImportError:
print("Warning: Using placeholder MessageList class.")

    class MessageList:
        def __init__(self, raw_messages, **kwargs):
            self.messages_raw = raw_messages

        def __len__(self):
            return 0  # Simplified length

# --- Nested Quest Data Classes ---

# KLASS: - QuestProgress

class QuestProgress:
"""Represents the progress within an active party quest."""

    def __init__(self, progress_data: Optional[dict[str, Any]]):
        if not progress_data:
            progress_data = {}  # Use empty dict if data is None

        # Boss quest damage or positive habit progress
        self.up: float = float(progress_data.get("up", 0.0))
        # Damage taken by party or negative habit progress
        self.down: float = float(progress_data.get("down", 0.0))
        # Item collection quest goal (dictionary of item keys and counts)
        self.collect_goal: dict[str, int] = progress_data.get("collect", {})
        # Number of items collected so far for collection quests
        self.items_collected: int = int(progress_data.get("collectedItems", 0))

# KLASS: - QuestInfo

class QuestInfo:
"""Represents the information about the party's current quest.

    "quest.active":                "Boolean",
    "quest.extra":                 "Mixed",
    "quest.leader":                "String",
    "quest.members":               "Mixed",
    "quest.progress.hp":           "Number",
    "quest.progress.rage":         "Number",
    """

    def __init__(self, quest_data: Optional[dict[str, Any]]):
        if not quest_data:
            quest_data = {}

        self.key: Optional[str] = quest_data.get("key")
        self.rsvp_needed: bool = quest_data.get("RSVPNeeded", False)
        # Quest 'completed' field might be a status string or completion date string
        self.completed_status: Optional[str] = quest_data.get("completed")
        # Active status could be inferred (e.g., if key exists but not completed)
        self.is_active: bool = bool(self.key and not self.completed_status)

        # Nested progress object
        self.progress: QuestProgress = QuestProgress(quest_data.get("progress"))

# KLASS: - Party

class Party:
"""Represents a Habitica Party group."""

    def __init__(self, party_data: dict[str, Any]):
        """Initializes a Party object from API data."""
        if not isinstance(party_data, dict):
            raise TypeError("party_data must be a dictionary.")

        # Core Party Info
        self.id: Optional[str] = party_data.get("id") or party_data.get("_id")
        self.name: str = emoji_data_python.replace_colons(
            party_data.get("name", "Unnamed Party")
        )
        self.description: Optional[str] = emoji_data_python.replace_colons(
            party_data.get("description")
        )

        self.summary: Optional[str] = emoji_data_python.replace_colons(
            party_data.get("summary")
        )
        self.leader: Optional[str] = emoji_data_python.replace_colons(
            party_data.get("leader")
        )
        # Member Sorting Info (Needs careful parsing)
        self.member_sort_order: Optional[str] = party_data.get(
            "order"
        )  # e.g., "stats.lvl"
        raw_order_asc = party_data.get("orderAscending")
        self.member_sort_ascending: Optional[bool] = (
            str(raw_order_asc).lower() == "true"
            if raw_order_asc is not None
            else None
        )

        # Quest Info (using nested QuestInfo class)
        self.quest: Optional[QuestInfo] = QuestInfo(party_data.get("quest"))

        # --- Placeholders for related data (populate separately) ---
        # Chat messages (assuming fetched/added later)
        self.chat: Optional[MessageList] = None
        # Party members (assuming fetched/added later)
        # Replace 'Any' with your Member class if you create one
        self.members: list[Any] = []

    def set_chat(self, message_list: MessageList) -> None:
        """Assigns a MessageList containing the party's chat."""
        if isinstance(message_list, MessageList):
            self.chat = message_list
        else:
            print(
                "Warning: Invalid type provided to set_chat. Expected MessageList."
            )

    # Add methods to add/manage members if needed

    def __repr__(self) -> str:
        """Developer-friendly representation."""
        quest_str = (
            f", quest={self.quest.key}"
            if self.quest and self.quest.key
            else ", quest=None"
        )
        chat_str = (
            f", chat={len(self.chat)} msgs"
            if self.chat is not None
            else ", chat=N/A"
        )
        return f"Party(id='{self.id}', name='{self.name}'{quest_str}{chat_str})"

# --- Example Usage ---

if **name** == "**main**": # Example Raw Party Data (simulating API response)
raw_party_data_with_quest = {
"\_id": "party-doc-id-1",
"id": "party-id-1",
"name": "The Seekers",
"description": "Seeking adventure!",
"order": "profile.name",
"orderAscending": "true",
"quest": {
"key": "basilisk",
"RSVPNeeded": False,
"completed": None, # Quest is active
"progress": {
"up": 150.75,
"down": 25.5,
"collect": {},
"collectedItems": 0,
},
}, # Chat data might be here or fetched separately # "chat": [...]
}

    raw_party_data_no_quest = {
        "id": "party-id-2",
        "name": "Chill Zone",
        "order": "stats.hp",
        "orderAscending": "False",  # Example string 'False'
        "quest": None,  # No active quest
    }

    # --- Processing ---
    party1 = Party(raw_party_data_with_quest)
    party2 = Party(raw_party_data_no_quest)

    print("--- Processed Parties ---")
    print(party1)
    print(
        f"  Quest Active: {party1.quest.is_active if party1.quest else 'N/A'}"
    )
    if party1.quest:
        print(f"  Quest Progress: {party1.quest.progress}")
    print(
        f"  Member Sort: {party1.member_sort_order} {'ASC' if party1.member_sort_ascending else 'DESC' if party1.member_sort_ascending is False else 'N/A'}"
    )
    print("-" * 10)
    print(party2)
    print(
        f"  Quest Active: {party2.quest.is_active if party2.quest else 'N/A'}"
    )
    print(
        f"  Member Sort: {party2.member_sort_order} {'ASC' if party2.member_sort_ascending else 'DESC' if party2.member_sort_ascending is False else 'N/A'}"
    )

    # Example: Setting chat data later (assuming you have raw chat data)
    # raw_chat_for_party1 = [ ... list of message dicts ... ]
    # party1_chat = MessageList(raw_chat_for_party1, current_user_id="some_user_id")
    # party1.set_chat(party1_chat)
    # print(f"\nParty 1 after setting chat: {party1}")

--- END OF FILE models/party.py ---
--- START OF FILE models/spell.py ---
"""pixabit/models/spell.py

# â”€â”€â”€ SPELL Object â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Defines data classes related to Habitica spells.
Modified: 2025.04.17 by vainilie.
"""

from typing import Any, Optional # Added list import

import emoji_data_python

# KLASS â”€â”€â”€Spell â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class Spell:
"""Represents a single Habitica spell definition (e.g., from game content)."""

    def __init__(
        self,
        spell_key: str,
        spell_data: dict[str, Any],
        spell_class: Optional[str] = None,
    ):
        """Initializes Spell object with spell key, data, and optionally a class.

        Args:
            self(Spell): The Spell object instance.
            spell_key(str): The unique key identifying the spell.
            spell_data(dict[str, Any]): A dictionary containing the spell's data.
            spell_class(Optional[str]): Optional class or type of spell.

        Returns:
            None: No return value.

        Raises:
            ValueError: If spell_key is empty or spell_data is missing essential information.
            TypeError: If input types are invalid.
        """
        if not isinstance(spell_data, dict):
            raise TypeError("spell_data must be a dictionary.")

        self.key: str = spell_key  # Use the provided key
        self.klass: Optional[str] = spell_class  # Assign the class

        # Map content fields to attributes
        self.name: Optional[str] = emoji_data_python.replace_colons(
            spell_data.get("text")
        )
        self.description: Optional[str] = emoji_data_python.replace_colons(
            spell_data.get("notes")
        )
        self.mana_cost: Optional[float] = spell_data.get("mana")
        self.target: Optional[str] = spell_data.get("target")
        self.level_required: Optional[int] = spell_data.get("lvl")

        # Other potentially useful flags from content
        self.is_bulk: Optional[bool] = spell_data.get("bulk")
        self.is_immediate_use: Optional[bool] = spell_data.get("immediateUse")
        self.is_limited: Optional[bool] = spell_data.get("limited")
        self.is_previous_purchase: Optional[bool] = spell_data.get(
            "previousPurchase"
        )
        self.purchase_type: Optional[str] = spell_data.get("purchaseType")
        self.is_silent: Optional[bool] = spell_data.get("silent")
        self.value: Optional[int] = spell_data.get("value")

# KLASS â”€â”€â”€SpellList â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class SpellList:
"""Container for managing a list of Spell objects, typically from game content."""

    def __init__(
        self,
        raw_content_spells: dict[str, dict[str, dict[str, Any]]],
        current_user_class: Optional[str] = None,
    ):
        """Initializes the SpellList by processing the spells section from game content.

        Args:
            raw_content_spells([dict]): The dictionary representing `content['spells'].
            current_user_class([str]): The class ('warrior', 'rogue', etc.) of the current user.
        """
        self.spells: list[Spell] = []
        self.current_user_class: Optional[str] = current_user_class
        self._process_list(raw_content_spells)

    def _process_list(
        self, raw_content_spells: dict[str, dict[str, dict[str, Any]]]
    ) -> None:
        """Process the raw content dictionary, creating Spell instances.

        Args:
            self(Any): The object instance.
            raw_content_spells(dict[str, dict[str, dict[str, Any]]]): A dictionary containing raw spell data.

        Returns:
            None: This function does not return a value.

        Raises:
            KeyError: Raised if a key is not found in the input dictionary.
            TypeError: Raised if the input data is not in the expected format.
        """
        processed_spells: list[Spell] = []

        if not isinstance(raw_content_spells, dict):
            print("Error: raw_content_spells data must be a dictionary.")
            self.spells = processed_spells
            return

        # Iterate through each class ('rogue', 'warrior', 'special', etc.)
        for klass, class_spells_dict in raw_content_spells.items():

            if not isinstance(class_spells_dict, dict):
                continue  # Skip if not a dict

            # Iterate through each spell within that class
            for spell_key, raw_spell_data in class_spells_dict.items():

                if not isinstance(raw_spell_data, dict):
                    continue  # Skip if not a dict

                try:
                    # Create the Spell instance, passing key, data, and class
                    spell_instance = Spell(
                        spell_key, raw_spell_data, spell_class=klass
                    )
                    processed_spells.append(spell_instance)

                except Exception as e:
                    print(
                        f"Error processing spell data: Key='{spell_key}', Class='{klass}'. Error: {e}"
                    )

        self.spells = processed_spells

    # FUNC â”€â”€â”€ Filtering Methods â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def __len__(self) -> int:
        """Returns the total number of spells processed."""
        return len(self.spells)

    def __iter__(self):
        """Allows iterating over the spells."""
        return iter(self.spells)

    def __getitem__(self, index: int) -> Spell:
        """Allows accessing spells by index."""
        return self.spells[index]

    def get_by_key(self, spell_key: str) -> Optional[Spell]:
        """Finds a spell by its unique key (e.g., 'fireball')."""
        for spell in self.spells:
            if spell.key == spell_key:
                return spell

        return None

    def filter_by_class(self, klass: str) -> list[Spell]:
        """Returns all spells belonging to a specific class."""
        # Handle potential case mismatch if needed
        # klass_lower = klass.lower()
        # return [spell for spell in self.spells if spell.klass and spell.klass.lower() == klass_lower]
        return [spell for spell in self.spells if spell.klass == klass]

    def filter_by_target(self, target: str) -> list[Spell]:
        """Returns spells that affect a specific target type ('self', 'user', 'party', 'task')."""
        return [spell for spell in self.spells if spell.target == target]

    def filter_by_mana_cost(
        self, max_cost: float, min_cost: float = 0
    ) -> list[Spell]:
        """Returns spells within a specified mana cost range (inclusive)."""
        return [
            spell
            for spell in self.spells
            if spell.mana_cost is not None
            and min_cost <= spell.mana_cost <= max_cost
        ]

    def filter_by_level(
        self, max_level: int, min_level: int = 0
    ) -> list[Spell]:
        """Returns spells within a specified level requirement range (inclusive)."""
        return [
            spell
            for spell in self.spells
            if spell.level_required is not None
            and min_level <= spell.level_required <= max_level
        ]

    def get_available_spells(
        self, user_level: int, user_class: Optional[str] = None
    ) -> list[Spell]:
        """Gets spells available to a user based on level and class.

        Args:
            user_level: The level of the user.
            user_class: The class of the user ('warrior', 'rogue', etc.). If None, uses the current_user_class set during SpellList initialization.

        Returns:
            A list of Spell objects the user can potentially cast.
        """
        target_class = user_class or self.current_user_class

        if not target_class:
            print(
                "Warning: Cannot determine available class spells without a user class."
            )

            return [
                spell
                for spell in self.spells
                if spell.klass
                == "special"  # Or however general spells are keyed
                and (
                    spell.level_required is None
                    or spell.level_required <= user_level
                )
            ]

        available = []
        for spell in self.spells:
            # Check level requirement
            level_ok = (
                spell.level_required is None
                or spell.level_required <= user_level
            )

            if not level_ok:
                continue

            # Check class requirement (spell must match user's class or be general/special)
            # Adjust 'special' if general spells have a different key or klass=None
            class_ok = spell.klass == target_class or spell.klass == "special"

            if class_ok:
                available.append(spell)

        return available

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

--- END OF FILE models/spell.py ---
--- START OF FILE models/tag.py ---
"""pixabit/models/tag.py

# â”€â”€â”€ TAG OBJECT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Modified: 2025.04.17 by vainilie.
"""

import re
from typing import Any, Optional

import emoji_data_python

from pixabit.cli.config import ATTRIBUTE_MAP, TAG_MAP

attribute_string = {
"ğŸœ„": "con",
"ğŸœ‚": "str",
"ğŸœ": "int",
"ğŸœƒ": "per",
"á›­": "legacy",
}

# KLASS â”€â”€â”€ Tag â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class Tag:
"""Represents a tag object with attributes for identification, type, and
hierarchical relationships.

    Attributes:
        id(Optional[str]): Unique identifier of the tag.
        name(Optional[str]): Name of the tag.
        challenge(bool): Indicates if the tag represents a challenge.
        position(Optional[int]): Position of the tag.
        tag_type(Optional[str]): Type of the tag (e.g., 'basic').
        attr(Optional[str]): Additional attribute of the tag.
        origin(Optional[str]): Origin of the tag.
        parent_id(Optional[str]): ID of the parent tag.
        children(list[Tag]): List of child tags.


    """

    def __init__(
        self,
        tag_data: dict[str, Any],
        tag_type: str = "basic",
        attr: Optional[str] = None,
        origin: Optional[str] = None,
        position: Optional[int] = None,
        parent_id: Optional[str] = None,
        children: Optional[list["Tag"]] = None,
    ) -> None:
        """Initialize a new Tag object.

        Args:
            self(Tag): The Tag object instance.
            tag_data(dict[str, Any]): A dictionary containing tag data.
            tag_type(str): The type of tag (default: "basic").
            attr(Optional[str]): An optional attribute string.
            origin(Optional[str]): An optional origin string.
            position(Optional[int]): An optional integer representing the position.
            parent_id(Optional[str]): An optional parent ID string.
            children(Optional[list[Tag]]): An optional list of child Tag objects.

        Returns:
            None: No return value.

        Raises:
            TypeError: Raised if input types are invalid.
            ValueError: Raised if tag data is missing required keys.
        """
        self.id: Optional[str] = tag_data.get("id")
        self.name: Optional[str] = emoji_data_python.replace_colons(
            tag_data.get("name")
        )
        self.challenge: bool = tag_data.get("challenge", False)
        self.position: Optional[int] = position
        self.tag_type: Optional[str] = tag_type
        self.attr: Optional[str] = attr
        self.origin: Optional[str] = origin
        self.parent_id: Optional[str] = parent_id
        self.children: list[Tag] = children if children is not None else []

# KLASS â”€â”€â”€ ListTag â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ListTag:
"""Represents a collection of tags, providing methods for filtering and
accessing tag information.

    Attributes:
        tags(list[Tag]): List of Tag objects representing the processed tags.
        _process_list(method): Processes a raw list of tag dictionaries  into  a list of Tag objects.
    """

    def __init__(
        self,
        raw_tag_list: list[dict[str, Any]],
    ) -> None:
        """Initialize self.  See help(type(self)) for accurate signature.

        Args:
            self(self): The instance of the class being initialized.
            raw_tag_list(list[dict[str, Any]]): A list  of  dictionaries,  where each dictionary represents a tag and its attributes.

        Returns:
            None: No return value.

        Raises:
            TypeError: Raised if the input is not a list of dictionaries.
            ValueError: Raised if any dictionary in the list is missing required keys or contains invalid data types.
        """
        self.tags: list[Tag] = []
        self._process_list(raw_tag_list)
        # Optional: Add linking step if you want parent objects, not just IDs
        # self._link_tags()

    # FUNC â”€â”€â”€ Process Single Tag â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _process_single_tag(
        self, i: int, tag_info: dict[str, Any]
    ) -> Optional[Tag]:
        """Process a single tag from the input list.

        Args:
            self(Any): The current instance of the class.
            i(int): Index of the current tag in the input list.
            tag_info(dict[str, Any]): Dictionary  containing  information  about the current tag.

        Returns:
            None: This function does not return any value.

        Raises:
            KeyError: Raised if a required key  is  missing  from  the  tag_info dictionary.
            ValueError: Raised if the tag information is invalid  or  cannot  be processed.
        """
        tag_map: dict[str, str] = TAG_MAP
        attr_map: dict[str, str] = ATTRIBUTE_MAP
        area_map: dict[str, str] = attribute_string

        # Tag creation
        tag = Tag(tag_info)
        tag.position = i
        tag_id = tag_info.get("id")
        tag_name = tag_info.get("name", "")

        # Get parent type.
        if tag_id in tag_map:
            tag.tag_type = "parent"
            tag.origin = tag_map[tag_id]

        elif tag_id in attr_map:
            tag.tag_type = "parent"
            tag.attr = attr_map[tag_id]

        # Use re.search on the actual name string
        symbol_match = re.search(r"([ğŸœ„ğŸœ‚ğŸœğŸœƒá›­])", tag_name)

        if symbol_match and symbol_match.group(1) in area_map:
            symbol = symbol_match.group(1)
            tag.tag_type = "child"
            tag.attr = area_map[symbol]

            # Find parent ID based on attribute match
            parent_id_found = None

            for p_id, p_attr in attr_map.items() or tag_map.items():
                if tag.attr == p_attr:
                    parent_id_found = p_id
                    break  # Found the attribute parent

            if parent_id_found:
                tag.parent_id = parent_id_found

        return tag

    # FUNC â”€â”€â”€ Process List Tag â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _process_list(self, raw_tag_list: list[dict[str, Any]]) -> None:
        """Process a list  of  raw  tag  dictionaries  and  updates  the  `tags` attribute.

        Args:
            self(Any): Instance of the class.
            raw_tag_list(list[dict[str, Any]]): A list  of  dictionaries,  where each dictionary represents a raw tag.

        Returns:
            None: This function does not return a value explicitly. It  modifies the instance attribute `tags`.

        Raises:
            Exception: Generic exception during tag processing. Could be due  to issues  in  `_process_single_tag`  or  data   format   problems   in `raw_tag_list`.
        """
        processed_tags: list[Tag] = []  # Use a local list first
        for i, tag_dict in enumerate(raw_tag_list):  # Correct iteration
            tag = self._process_single_tag(i, tag_dict)  # Call helper
            if tag:
                processed_tags.append(tag)
        self.tags = processed_tags  # Assign to instance attribute

    # FUNC â”€â”€â”€ Filtering Methods â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def by_id(self, tag_id: str) -> Optional[Tag]:
        """Retrieves a tag by its ID.

        Args:
            self(TagManager): The TagManager instance.
            tag_id(str): The ID of the tag to retrieve.

        Returns:
            Optional[Tag]: The tag with the matching ID, or None if not found.

        Raises:
            Exception: An unexpected error occurred during tag retrieval.
        """
        for tag in self.tags:
            if tag.id == tag_id:
                return tag
        return None

    def by_type(self, tag_type: str) -> list[Tag]:
        """Returns all tags of a given type.

        Args:
            tag_type(str): Type of tag to filter by.
            self(TagManager): Instance of the TagManager class.

        Returns:
            list[Tag]: List of tags matching the specified type.

        Raises:
            TypeError: Raised if tag_type is not a string.
        """
        return [tag for tag in self.tags if tag.tag_type == tag_type]

    def by_attr(self, attr: str) -> list[Tag]:
        """Returns a list of tags that match a given attribute.

        Args:
            attr(str): The attribute to match.

        Returns:
            list[Tag]: A list of tags that match the given attribute.

        Raises:
            Exception: If an error occurs during the process.
        """
        return [tag for tag in self.tags if tag.attr == attr]

    def by_origin(self, origin: str) -> list[Tag]:
        """Retrieve tags based on their origin.

        Args:
            self(TagContainer): The TagContainer instance.
            origin(str): The origin to filter tags by.

        Returns:
            list[Tag]: A list of tags matching the specified origin.

        Raises:
            TypeError: If input origin is not a string.
        """
        return [tag for tag in self.tags if tag.origin == origin]

    def by_challenge(self, is_challenge: bool = True) -> list[Tag]:
        """Returns tags filtered by challenge criteria.

        Args:
            is_challenge(bool): Filter by challenge status. True for challenge
            tags, False otherwise.

        Returns:
            list[Tag]: List of tags matching the challenge criteria.

        Raises:
            Exception: Generic error during tag filtering.
        """
        return [tag for tag in self.tags if tag.challenge == is_challenge]

    def get_children(self, parent_id: str) -> list[Tag]:
        """Retrieves all child tags associated with a given parent ID.

        Args:
            self(TagManager): Instance of the TagManager class.
            parent_id(str): The ID of the parent tag.

        Returns:
            list[Tag]: A list of Tag objects that are children of the parent tag
            with the given ID.

        Raises:
            ValueError: If the parent_id is invalid or not found.
        """
        return [tag for tag in self.tags if tag.parent_id == parent_id]

"""
--- Optional: Linking Parent/Child Objects ---
Uncomment and call this in **init** if needed, also change Tag.parent_id
back to Tag.parent

     def _link_tags(self) -> None:
         Tries to link parent Tag objects and update children lists.
         tag_map_by_id = {tag.id: tag for tag in self.tags if tag.id}
         for tag in self.tags:
              Reset children list before populating
             tag.children = []
             if tag.parent_id and tag.parent_id in tag_map_by_id:
                 parent_tag = tag_map_by_id[tag.parent_id]
                  Change Tag.parent type hint back to Optional["Tag"] for this
                 tag.parent = parent_tag
                  Add current tag to parent's children list
                 if tag not in parent_tag.children:  Avoid duplicates if run multiple times
                     parent_tag.children.append(tag)
              else:
                  Optional: Clear parent if ID exists but object not found?
                  tag.parent = None


    --- Example Usage ---
    if __name__ == "__main__":
        raw_data = ""
        tag_collection = ListTag(raw_data)

"""

--- END OF FILE models/tag.py ---
--- START OF FILE models/task.py ---
"""pixabit/models/task.py

# â”€â”€â”€ TASK OBJECT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Defines data classes for representing Habitica Tasks and a container for managing them.
Modified: 2025.04.17 by vainilie.
"""

import math
from collections import defaultdict
from datetime import datetime, timezone
from typing import Any, Optional

import emoji_data_python

from pixabit.utils.dates import convert_timestamp_to_utc

# from pixabit.models.tag import Tag, listTag

# KLASS: - ChecklistItem

class ChecklistItem: # FUNC: **init**
def **init**(self, item_data: dict[str, Any]):
"""Represents a single item within a Task's checklist."""
self.id: Optional[str] = item_data.get("id")
self.text: str = emoji_data_python.replace_colons(
item_data.get("text", "")
)
self.completed: bool = item_data.get("completed", False)

    def __repr__(self) -> str:
        """Developer-friendly representation including completion status."""
        status = "[X]" if self.completed else "[ ]"
        text_preview = self.text[:30] + ("..." if len(self.text) > 30 else "")
        return f"ChecklistItem(id={self.id}, status='{status}', text='{text_preview}')"

# KLASS: - ChallengeData

class ChallengeData: # FUNC: **init**
def **init**(self, challenge_data: dict[str, Any]):
"""Represents data about a challenge associated with a task.
Broken status: Can be 'CHALLENGE_DELETED', 'TASK_DELETED', 'UNSUBSCRIBED', 'CHALLENGE_CLOSED', 'CHALLENGE_TASK_NOT_FOUND'.
""" # Ensure challenge_data is a dict before accessing keys
if not isinstance(challenge_data, dict):
challenge_data = {}
self.task_id: Optional[str] = challenge_data.get("taskId")
self.id: Optional[str] = challenge_data.get("id")
self.name: Optional[str] = emoji_data_python.replace_colons(
challenge_data.get("shortName")
)
broken_raw = challenge_data.get(
"broken", ""
) # Get the raw status string
self.broken_status: Optional[str] = None # Initialize attribute
if (
broken_raw == "TASK_DELETED"
or broken_raw == "CHALLENGE_TASK_NOT_FOUND"
):
self.broken_status = "task"
elif (
broken_raw == "CHALLENGE_DELETED"
or broken_raw == "UNSUSCRIBED"
or broken_raw == "CHALLENGE_CLOSED"
):
self.broken_status = "challenge" # Else: self.broken_status remains None if not explicitly matched

        # Now use the assigned attribute
        self.is_broken: bool = bool(self.broken_status)
        # Handle broken level

        # Add group info if needed, parsing from challenge_data if structure is known

# KLASS: - Task (Base Class)

class Task:
"""Base representation of a Habitica Task."""

    # FUNC: __init__
    def __init__(self, task_data: dict[str, Any]):
        """Initializes the base Task object."""
        self.id: Optional[str] = task_data.get("_id")
        self.alias: Optional[str] = task_data.get("alias")
        self.user_id: Optional[str] = task_data.get("userId")
        self.text: str = emoji_data_python.replace_colons(
            task_data.get("text", "")
        )
        self.notes: str = emoji_data_python.replace_colons(
            task_data.get("notes", "")
        )
        self.type: Optional[str] = task_data.get("type")
        self.tags: list[str] = task_data.get("tags", [])
        self.value: float = float(task_data.get("value", 0.0))
        self.priority: float = float(task_data.get("priority", 1.0))
        self.attribute: str = task_data.get("attribute", "str")
        self.position: Optional[int] = None

        # Dates
        self.created_at: Optional[datetime] = convert_timestamp_to_utc(
            task_data.get("createdAt")
        )
        self.updated_at: Optional[datetime] = convert_timestamp_to_utc(
            task_data.get("updatedAt")
        )

        # Other common fields
        self.by_habitica: bool = task_data.get("byHabitica", False)
        self.reminders: list[dict[str, Any]] = task_data.get("reminders", [])

        # Challenge Integration
        challenge_info = task_data.get("challenge", {})
        self.challenge: Optional[ChallengeData] = (
            ChallengeData(challenge_info) if challenge_info else None
        )

        # Standardized Checklist (populated by specific types if applicable)
        self.checklist: list[ChecklistItem] = []  # Initialize empty

        # Processed/Calculated Fields (can be populated later)
        self.tag_names: list[str] = []
        self.value_color: str = "neutral"
        self._status: str = "unknown"
        self.damage_user: Optional[float] = None
        self.damage_party: Optional[float] = None

        self.origin_tag: Optional[Any] = None
        self.attribute_tag: Optional[Any] = None
        self.area_tag: Optional[Any] = None
        self._status: str = "unknown"  # <<< Initialize as regular attribute

    # FUNC: __repr__
    def __repr__(self) -> str:
        """Developer-friendly representation."""
        return f"{self.__class__.__name__}(id='{self.id}', text='{self.text[:30]}...', type='{self.type}')"

    # FUNC: update_from_processed
    def update_from_processed(self, processed_data: dict[str, Any]):
        """Updates task instance with fields calculated during processing."""
        self.tag_names = processed_data.get("tag_names", self.tags)
        self.value_color = processed_data.get("value_color", "neutral")
        self._status = processed_data.get("_status", "unknown")
        self.damage_user = processed_data.get("damage_to_user")
        self.damage_party = processed_data.get("damage_to_party")

        self.origin_tag = processed_data.get("origin_tag", self.origin_tag)
        self.attribute_tag = processed_data.get(
            "attribute_tag", self.attribute_tag
        )
        self.area_tag = processed_data.get("area_tag", self.area_tag)
        self._status = processed_data.get(
            "_status", "unknown"
        )  # <<< Assign directly

# KLASS: - Habit

class Habit(Task):
"""Represents a Habit task."""

    # FUNC: __init__
    def __init__(self, task_data: dict[str, Any]):
        """Habit."""
        super().__init__(task_data)
        self.type = "habit"
        self.up: bool = task_data.get("up", False)
        self.down: bool = task_data.get("down", False)
        self.counter_up: int = task_data.get("counterUp", 0)
        self.counter_down: int = task_data.get("counterDown", 0)
        self.frequency: str = task_data.get("frequency", "daily")
        self.history: list[dict[str, Any]] = task_data.get("history", [])

    def __repr__(self) -> str:
        """Developer-friendly representation including counters."""
        up_str = f"â¬†ï¸{self.counter_up}" if self.up else ""
        down_str = f"â¬‡ï¸{self.counter_down}" if self.down else ""
        sep = " / " if self.up and self.down else ""
        counters = (
            f"{up_str}{sep}{down_str}" if up_str or down_str else "No Counters"
        )
        text_preview = self.text[:30] + ("..." if len(self.text) > 30 else "")
        return f"Habit(id='{self.id}', text='{text_preview}', counters='{counters}')"

# KLASS: - Todo

class Todo(Task):
"""Represents a To-Do task."""

    # FUNC: __init__
    def __init__(self, task_data: dict[str, Any]):
        """Todo."""
        super().__init__(task_data)
        self.type = "todo"
        self.completed: bool = task_data.get("completed", False)
        self.completed_date: Optional[datetime] = convert_timestamp_to_utc(
            task_data.get("dateCompleted")
        )
        self.due_date: Optional[datetime] = convert_timestamp_to_utc(
            task_data.get("date")
        )
        self.collapse_checklist: bool = task_data.get(
            "collapseChecklist", False
        )

        # Populate checklist from data
        self.checklist: list[ChecklistItem] = [
            ChecklistItem(item)
            for item in task_data.get("checklist", [])
            if isinstance(item, dict)
        ]

    @property
    def is_past_due(self) -> bool:
        """Checks if the To-Do is past its due date and not completed."""
        # Status calculation should happen in TaskProcessor and stored in self._status
        # This property only checks the date condition
        if self.completed or not self.due_date:
            return False
        # Ensure comparison happens with timezone-aware datetime
        return self.due_date < datetime.now(timezone.utc)

    def _status(self) -> bool:
        """Checks if the To-Do is past its due date and not completed."""
        if self.completed:
            return "done"
        elif self.due_date:
            if self.due_date < datetime.now(timezone.utc):
                return "red"
            else:
                return "due"
        else:
            return "grey"

    def __repr__(self) -> str:
        """Developer-friendly representation including completion status."""
        status_char = (
            "[X]" if self.completed else "[ ]"
        )  # Determine status character
        due_str = (
            f", due={self.due_date.strftime('%Y-%m-%d')}"
            if self.due_date
            else ""
        )
        text_preview = self.text[:30] + ("..." if len(self.text) > 30 else "")
        # Include status_char in the output string
        return f"Todo(id='{self.id}', status='{status_char}', text='{text_preview}'{due_str})"

# KLASS: - Daily

class Daily(Task):
"""Represents a Daily task."""

    # FUNC: __init__
    def __init__(self, task_data: dict[str, Any]):
        """Daily."""
        super().__init__(task_data)
        self.type = "daily"
        self.completed: bool = task_data.get("completed", False)
        self.is_due: bool = task_data.get("isDue", False)
        self.streak: int = task_data.get("streak", 0)
        self.collapse_checklist: bool = task_data.get(
            "collapseChecklist", False
        )

        # Populate checklist from data
        self.checklist: list[ChecklistItem] = [
            ChecklistItem(item)
            for item in task_data.get("checklist", [])
            if isinstance(item, dict)
        ]

        # Scheduling properties
        self.frequency: str = task_data.get("frequency", "weekly")
        self.every_x: int = task_data.get("everyX", 1)  # e.g., every 3 days
        self.start_date: Optional[datetime] = convert_timestamp_to_utc(
            task_data.get("startDate")
        )
        self.days_of_month: list[int] = task_data.get("daysOfMonth", [])
        self.weeks_of_month: list[int] = task_data.get("weeksOfMonth", [])
        self.repeat: dict[str, bool] = task_data.get(
            "repeat", {}
        )  # {m:T, t:T, w:T, th:T, f:T, s:T, su:T}
        self.yesterday_completed: bool = task_data.get(
            "yesterDaily", False
        )  # If completed on its last due day
        self.next_due: list[datetime] = [  # Store parsed next due dates
            dt
            for ts in task_data.get("nextDue", [])
            if (dt := convert_timestamp_to_utc(ts)) is not None
        ]
        self.history: list[dict[str, Any]] = task_data.get("history", [])

# KLASS: - Reward

class Reward(Task):
"""Represents a Reward task."""

    # FUNC: __init__
    def __init__(self, task_data: dict[str, Any]):
        """Reward."""
        super().__init__(task_data)
        self.type = "reward"

# --- Task list Container ---

# KLASS: - TaskList

class TaskList:
"""Container for managing a list of Task objects with filtering."""

    _TASK_TYPE_MAP = {
        "habit": Habit,
        "daily": Daily,
        "todo": Todo,
        "reward": Reward,
    }

    # FUNC: __init__
    def __init__(
        self,
        raw_task_list: list[dict[str, Any]],
        tag_collection: Optional[Any] = None,
    ):
        """Initializes the TaskList by processing a list of raw task dictionaries.

        Args:
            raw_task_list: A list of dictionaries, each representing a task from Habitica API.
            tag_collection: An optional instance of listTag (or similar) to resolve tag names.
        """
        self.tasks: list[Task] = []
        self._process_list(raw_task_list)

        # Optional: Resolve tag names if a tag collection is provided
        if tag_collection:
            self._resolve_tag_names(tag_collection)
        self._process_and_calculate_task(raw_task_list)
        # You could add more linking here (origin_tag, etc.) if listTag/Tag support it
        # self._link_special_tags(tag_collection)

    # FUNC: _process_list
    def _process_list(self, raw_task_list: list[dict[str, Any]]) -> None:
        """Processes the raw list, creating specific Task subclass instances."""
        processed_tasks: list[Task] = []
        type_position_counters = defaultdict(int)
        default_type_key = "unknown"

        for raw_task in raw_task_list:
            if not isinstance(raw_task, dict):
                continue  # Skip invalid entries

            task_type = raw_task.get("type")
            counter_key = task_type if task_type else default_type_key

            task_class = self._TASK_TYPE_MAP.get(
                task_type, Task
            )  # Fallback to base Task

            try:
                task_instance = task_class(raw_task)
                current_position = type_position_counters[counter_key]
                task_instance.position = current_position
                type_position_counters[counter_key] += 1

                if task_instance.id:  # Only add tasks with an ID
                    processed_tasks.append(task_instance)
            except Exception as e:
                # Log error or handle specific exceptions
                print(
                    f"Error processing task data: {raw_task.get('_id', 'N/A')}, Type: {task_type}. Error: {e}"
                )
                # Optionally add the raw data or a basic Task instance on error
                # task_instance = Task(raw_task) # Create base task on error?
                # if task_instance.id: processed_tasks.append(task_instance)

        self.tasks = processed_tasks

    # FUNC: _resolve_tag_names
    def _resolve_tag_names(self, tag_collection: Any) -> None:
        """Populates the tag_names list for each task using the tag_collection."""
        # Check if tag_collection has the expected method (duck typing)
        if not hasattr(tag_collection, "get_by_id"):
            print(
                "Warning: tag_collection provided does not have 'get_by_id' method."
            )
            return

        for task in self.tasks:
            task.tag_names = []
            for tag_id in task.tags:
                tag_obj = tag_collection.get_by_id(tag_id)
                if tag_obj and hasattr(tag_obj, "name") and tag_obj.name:
                    task.tag_names.append(tag_obj.name)
                else:
                    task.tag_names.append(
                        tag_id
                    )  # Fallback to ID if not found or no name

    # & - def _process_and_calculate_task(...) - REVISED
    def _process_and_calculate_task(self, task_instance: Task) -> None:
        """Performs post-instantiation processing on a Task object:
        emoji, status, value_color, tag names, and damage (for Dailies).
        Modifies the task_instance directly.
        """
        # --- 1. Emoji Processing ---
        task_instance.text = emoji_data_python.replace_colons(
            task_instance.text or ""
        )
        task_instance.notes = emoji_data_python.replace_colons(
            task_instance.notes or ""
        )
        if hasattr(task_instance, "checklist") and isinstance(
            task_instance.checklist, list
        ):
            for item in task_instance.checklist:
                if isinstance(item, ChecklistItem):
                    item.text = emoji_data_python.replace_colons(
                        item.text or ""
                    )

        # --- 2. Tag Names Lookup ---
        task_instance.tag_names = [
            self.tags_lookup.get(tag_id, f"ID:{tag_id}")
            for tag_id in task_instance.tags
        ]

        # --- 3. Value Color ---
        task_instance.value_color = self._value_color(task_instance.value)

        # --- 4. Status Calculation & Damage (if Daily) ---
        dmg_user, dmg_party = 0.0, 0.0  # Initialize damage vars

        if isinstance(task_instance, Daily):
            # Calculate Daily status
            status = "grey"
            if task_instance.is_due:
                status = "success" if task_instance.completed else "due"
            task_instance._status = status

            # --- Calculate Damage ONLY if due, not completed, not sleeping, not stealthed ---
            if (
                task_instance.is_due
                and not task_instance.completed
                and not self.is_sleeping
                and self.user_stealth <= 0
            ):
                try:
                    # Use attributes from the task_instance object
                    task_value = task_instance.value or 0.0
                    checklist = task_instance.checklist
                    priority_val = task_instance.priority or 1.0

                    # a. Clamp Task Value
                    v_min, v_max = -47.27, 21.27
                    clamped_value = max(v_min, min(task_value, v_max))

                    # b. Base Delta Calculation (Habitica formula)
                    base_delta = abs(math.pow(0.9747, clamped_value))

                    # c. Checklist Mitigation
                    checklist_done_ratio = self._calculate_checklist_done(
                        checklist
                    )
                    checklist_mitigation = (
                        1.0 - checklist_done_ratio
                    )  # Multiplier (0.0 to 1.0)

                    # d. Effective Delta (after checklist)
                    effective_delta = base_delta * checklist_mitigation

                    # e. CON Mitigation (uses pre-calculated self.user_con)
                    con_mitigation = max(0.1, 1.0 - (self.user_con / 250.0))

                    # f. Priority Multiplier
                    prio_map = {0.1: 0.1, 1.0: 1.0, 1.5: 1.5, 2.0: 2.0}
                    try:  # Handle potential non-numeric priority safely
                        priority_multiplier = prio_map.get(
                            float(priority_val), 1.0
                        )
                    except (ValueError, TypeError):
                        priority_multiplier = 1.0

                    # g. Calculate User HP Damage
                    # Formula: effective_delta * con_mitigation * priority_multiplier * 2.0
                    hp_mod = (
                        effective_delta
                        * con_mitigation
                        * priority_multiplier
                        * 2.0
                    )
                    dmg_user = round(hp_mod, 1)  # Round to 1 decimal place

                    # h. Calculate Party Damage (Boss Quest Only)
                    if self.is_on_boss_quest and self.boss_str > 0:
                        # Boss delta might adjust slightly for trivial tasks
                        boss_delta = effective_delta
                        if (
                            priority_multiplier < 1.0
                        ):  # Reduce damage for trivial tasks
                            boss_delta *= priority_multiplier
                        # Formula: boss_delta * boss_strength
                        dmg_party_unrounded = boss_delta * self.boss_str
                        dmg_party = round(
                            dmg_party_unrounded, 1
                        )  # Round to 1 decimal

                except Exception as e_dmg:
                    self.console.log(
                        f"Error calculating damage for Daily {task_instance.id}: {e_dmg}",
                        style="error",
                    )
                    dmg_user, dmg_party = 0.0, 0.0  # Reset on error

        elif isinstance(task_instance, Todo):
            # Calculate Todo status
            status = "grey"
            if task_instance.completed:
                status = "done"  # Mark completed Todos distinctly if needed
            elif task_instance.due_date:  # Has a due date
                status = "red" if task_instance.is_past_due else "due"
            # Else status remains 'grey' (no due date, not completed)
            task_instance._status = status

        elif isinstance(task_instance, Habit):
            task_instance._status = "habit"  # Simple status for habits
        elif isinstance(task_instance, Reward):
            task_instance._status = "reward"  # Simple status for rewards
        else:
            task_instance._status = (
                "unknown"  # Fallback for base Task or others
            )

        # --- 5. Assign Calculated Damage to Task Object ---
        # These attributes exist on the base Task class now, initialized to None
        task_instance.damage_user = dmg_user if dmg_user > 0 else None
        task_instance.damage_party = dmg_party if dmg_party > 0 else None

    # --- Access and Filtering Methods ---

    # FUNC: __len__
    def __len__(self) -> int:
        """Returns the number of tasks in the list."""
        return len(self.tasks)

    # FUNC: __iter__
    def __iter__(self):
        """Allows iterating over the tasks."""
        return iter(self.tasks)

    # FUNC: __getitem__
    def __getitem__(self, index: int) -> Task:
        """Allows accessing tasks by index."""
        return self.tasks[index]

    # FUNC: get_by_id
    def get_by_id(self, task_id: str) -> Optional[Task]:
        """Finds a task by its ID."""
        for task in self.tasks:
            if task.id == task_id:
                return task
        return None

    # FUNC: filter_by_type
    def filter_by_type(self, task_type: str) -> list[Task]:
        """Returns tasks matching the given type ('habit', 'daily', 'todo', 'reward')."""
        # Return specific type if map exists, otherwise filter by string
        cls = self._TASK_TYPE_MAP.get(task_type)
        if cls:
            return [task for task in self.tasks if isinstance(task, cls)]
        else:
            # Fallback for potentially unknown types stored as base Task
            return [task for task in self.tasks if task.type == task_type]

    # FUNC: filter_by_tag_id
    def filter_by_tag_id(self, tag_id: str) -> list[Task]:
        """Returns tasks that have the given tag ID."""
        return [task for task in self.tasks if tag_id in task.tags]

    # FUNC: filter_by_tag_name
    def filter_by_tag_name(self, tag_name: str) -> list[Task]:
        """Returns tasks that have the given tag name (requires tag_names resolution)."""
        if not self.tasks or not self.tasks[0].tag_names:
            print(
                "Warning: Filtering by tag name requires tag names to be resolved first."
            )
        return [task for task in self.tasks if tag_name in task.tag_names]

    # FUNC: filter_by_priority
    def filter_by_priority(
        self,
        exact_priority: Optional[float] = None,
        min_priority: Optional[float] = None,
        max_priority: Optional[float] = None,
    ) -> list[Task]:
        """Returns tasks within a priority range or matching an exact priority.
        Habitica priorities: 0.1 (Trivial), 1 (Easy), 1.5 (Medium), 2 (Hard).
        """
        filtered = self.tasks
        if exact_priority is not None:
            # Use tolerance for float comparison
            tolerance = 0.01
            filtered = [
                task
                for task in filtered
                if abs(task.priority - exact_priority) < tolerance
            ]
        else:
            if min_priority is not None:
                filtered = [
                    task for task in filtered if task.priority >= min_priority
                ]
            if max_priority is not None:
                filtered = [
                    task for task in filtered if task.priority <= max_priority
                ]
        return filtered

    # FUNC: filter_by_attribute
    def filter_by_attribute(self, attribute: str) -> list[Task]:
        """Returns tasks matching the given attribute ('str', 'int', 'con', 'per')."""
        return [task for task in self.tasks if task.attribute == attribute]

    # FUNC: filter_completed
    def filter_completed(self, completed: bool = True) -> list[Task]:
        """Returns completed or uncompleted Dailies and Todos."""
        # Note: Habits don't have a simple 'completed' state.
        return [
            task
            for task in self.tasks
            if isinstance(task, (Daily, Todo)) and task.completed == completed
        ]

    # FUNC: filter_due_dailies
    def filter_due_dailies(self, due: bool = True) -> list[Daily]:
        """Returns Dailies that are marked as due (or not due) for today."""
        return [
            task
            for task in self.tasks
            if isinstance(task, Daily) and task.is_due == due
        ]

    # FUNC: filter_past_due_todos
    def filter_past_due_todos(self) -> list[Todo]:
        """Returns Todos that are past their due date and not completed."""
        return [
            task
            for task in self.tasks
            if isinstance(task, Todo) and task.is_past_due
        ]

    # FUNC: filter_by_challenge
    def filter_by_challenge(
        self,
        challenge_id: Optional[str] = None,
        is_broken: Optional[bool] = None,
    ) -> list[Task]:
        """Returns tasks associated with any challenge, a specific challenge ID,
        or based on their broken status within a challenge.
        """
        filtered = [task for task in self.tasks if task.challenge is not None]
        if challenge_id is not None:
            filtered = [
                task
                for task in filtered
                if task.challenge and task.challenge.id == challenge_id
            ]
        if is_broken is not None:
            filtered = [
                task
                for task in filtered
                if task.challenge and task.challenge.is_broken == is_broken
            ]
        return filtered

    # FUNC: filter_by_habitica
    def filter_by_habitica(self, by_habitica: bool = True) -> list[Task]:
        """Returns tasks created by Habitica (e.g., system tasks, tutorial tasks)."""
        return [task for task in self.tasks if task.by_habitica == by_habitica]

    # FUNC: filter_needs_action
    def filter_needs_action(self) -> list[Task]:
        """Returns Dailies due today and uncompleted, and Todos not completed (optionally past due)."""
        actionable = []
        for task in self.tasks:
            if isinstance(task, Daily) and task.is_due and not task.completed:
                actionable.append(task)
            elif isinstance(task, Todo) and not task.completed:
                # Optional: Only include past due Todos
                # if task.is_past_due:
                actionable.append(task)
            # Could potentially include positive Habits here too
            # elif isinstance(task, Habit) and task.up:
            #     actionable.append(task)
        return actionable

""" # --- Example Usage ---
if **name** == "**main**": # Example Raw Task Data (Simplified)
raw_data = []
mock_tags = ListTags()

    # --- Create and Use TaskList ---
    task_list = TaskList(raw_data, tag_collection=mock_tags)  # Provide mock tags to resolve names

    # --- Filtering Examples ---

    habits = task_list.filter_by_type("habit")
    dailies = task_list.filter_by_type("daily")
    home_tasks = task_list.filter_by_tag_id("home")
    fun_tasks = task_list.filter_by_tag_name("Fun")
    hard_tasks = task_list.filter_by_priority(exact_priority=2.0)
    medium_or_harder = task_list.filter_by_priority(min_priority=1.5)
    str_tasks = task_list.filter_by_attribute("str")
    completed_tasks = task_list.filter_completed(True)
    due_today = task_list.filter_due_dailies(True)
    overdue = task_list.filter_past_due_todos()
    challenge_tasks = task_list.filter_by_challenge()
    specific_challenge_tasks = task_list.filter_by_challenge(challenge_id="chall123")
    broken_challenge_tasks = task_list.filter_by_challenge(is_broken=True)
    action_items = task_list.filter_needs_action() """

--- END OF FILE models/task.py ---
--- START OF FILE models/user.py ---

# pixabit/models/user.py

# MARK: - MODULE DOCSTRING

"""Defines the main User data class, aggregating stats, preferences, timing, etc."""

# MARK: - IMPORTS

import math # For calculations like effective stats
from datetime import datetime # Added timezone
from typing import Any, Optional

import emoji_data_python

from pixabit.utils.dates import convert_timestamp_to_utc

# Placeholder for Gear Content structure (replace with actual import if available)

AllGearContent = dict[str, dict[str, Any]]

class UserProfile:
"""User's public profile information."""

    def __init__(self, profile_data: dict[str, Any]):
        self.name: Optional[str] = emoji_data_python.replace_colons(
            profile_data.get("name")
        )
        self.blurb: Optional[str] = emoji_data_python.replace_colons(
            profile_data.get("blurb")
        )
        self.image_url: Optional[str] = profile_data.get("imageUrl")

    def __repr__(self) -> str:
        return f"UserProfile(name='{self.name}')"

class UserAuth:
"""User authentication and related info."""

    def __init__(self, auth_data: dict[str, Any]):
        local_auth = auth_data.get("local", {})
        self.username: Optional[str] = local_auth.get("username")
        # Timestamps could also go here, but UserTimestamps handles them
        # Add other auth fields if needed (e.g., social IDs)

    def __repr__(self) -> str:  # noqa: D105
        return f"UserAuth(username='{self.username}')"

class UserTimestamps:
"""Various timestamps related to user activity."""

    def __init__(
        self, timestamps_data: dict[str, Any], user_root_data: dict[str, Any]
    ):
        """Initializes from 'auth.timestamps' and user root for lastCron."""
        self.created: Optional[datetime] = convert_timestamp_to_utc(
            timestamps_data.get("created")
        )
        self.updated: Optional[datetime] = convert_timestamp_to_utc(
            timestamps_data.get("updated")
        )
        self.logged_in: Optional[datetime] = convert_timestamp_to_utc(
            timestamps_data.get("loggedin")
        )
        # lastCron is often at the root of the user object
        self.last_cron: Optional[datetime] = convert_timestamp_to_utc(
            user_root_data.get("lastCron")
        )
        # needsCron might indicate if cron run is pending
        self.needs_cron: Optional[bool] = user_root_data.get("needsCron")

    def __repr__(self) -> str:
        login_str = (
            self.logged_in.strftime("%Y-%m-%d %H:%M")
            if self.logged_in
            else "None"
        )
        cron_str = (
            self.last_cron.strftime("%Y-%m-%d %H:%M")
            if self.last_cron
            else "None"
        )
        return (
            f"UserTimestamps(logged_in='{login_str}', last_cron='{cron_str}')"
        )

class UserPreferences:
"""User-configurable preferences influencing timing and display."""

    def __init__(self, preferences_data: dict[str, Any]):
        self.sleep: bool = preferences_data.get("sleep", False)
        self.day_start: int = int(
            preferences_data.get("dayStart", 0)
        )  # Custom Day Start hour (0-23)
        self.timezone_offset: Optional[int] = preferences_data.get(
            "timezoneOffset"
        )  # Offset from UTC in minutes
        self.timezone_offset_at_last_cron: Optional[int] = preferences_data.get(
            "timezoneOffsetAtLastCron"
        )

    def __repr__(self) -> str:
        return f"UserPreferences(sleep={self.sleep}, day_start={self.day_start}, tzOffset={self.timezone_offset})"

class UserStats:
"""Holds user core stats, buffs, training, and calculated values."""

    def __init__(
        self,
        stats_data: dict[str, Any],
        equipped_gear: dict[
            str, str
        ],  # e.g., {"weapon": "weapon_wizard_1", ...}
        all_gear_content: Optional[AllGearContent] = None,
    ):  # Game content for gear stats

        # --- Raw Stats from API ---
        self.hp: float = float(stats_data.get("hp", 0.0))
        self.mp: float = float(stats_data.get("mp", 0.0))
        self.exp: float = float(stats_data.get("exp", 0.0))
        self.gp: float = float(stats_data.get("gp", 0.0))
        self.level: int = stats_data.get("lvl", 0)
        self.klass: Optional[str] = stats_data.get("class")
        self.points: int = stats_data.get(
            "points", 0
        )  # Attribute points available to spend

        self.max_hp_base: int = stats_data.get(
            "maxHealth", 50
        )  # Base max health (usually 50)
        self.max_mp_base: int = stats_data.get("maxMP", 0)  # Base max mana
        self.exp_to_next_level: int = stats_data.get("toNextLevel", 0)

        # Base attributes (allocated points)
        self.strength: int = stats_data.get("str", 0)
        self.intelligence: int = stats_data.get("int", 0)
        self.constitution: int = stats_data.get("con", 0)
        self.perception: int = stats_data.get("per", 0)

        # Buffs (temporary increases/decreases)
        buffs = stats_data.get("buffs", {})
        self.buff_str: float = float(buffs.get("str", 0.0))
        self.buff_int: float = float(buffs.get("int", 0.0))
        self.buff_con: float = float(buffs.get("con", 0.0))
        self.buff_per: float = float(
            buffs.get("per", 0.0)
        )  # Mark of Shiny Seed active?
        self.buff_stealth: int = buffs.get(
            "stealth", 0
        )  # Stealth count (Rogue)

        # Training (permanent increases from leveling)
        training = stats_data.get("training", {})
        self.train_str: int = training.get("str", 0)
        self.train_int: int = training.get("int", 0)
        self.train_con: int = training.get("con", 0)
        self.train_per: int = training.get("per", 0)

        # --- Calculated Effective Stats ---
        # Store equipped gear keys for calculations
        self._equipped_gear_keys = equipped_gear or {}
        self._all_gear_content = all_gear_content or {}

        # Calculate effective stats (base + train + gear + buff + level bonus)
        self.effective_strength: float = self.calculate_total_stat("str")
        self.effective_intelligence: float = self.calculate_total_stat("int")
        self.effective_constitution: float = self.calculate_total_stat("con")
        self.effective_perception: float = self.calculate_total_stat("per")

        # Calculate Max HP/MP based on effective stats
        self.max_hp: float = self._calculate_max_hp()
        self.max_mp: float = self._calculate_max_mp()

    def _get_gear_stat_bonus(self, stat_name: str) -> float:
        """Helper to calculate total stat bonus from equipped gear."""
        total_gear_stat = 0.0
        class_bonus_stat = 0.0

        for (
            gear_key
        ) in (
            self._equipped_gear_keys.values()
        ):  # Iterate through equipped item keys
            if not gear_key:
                continue
            item_data = self._all_gear_content.get(gear_key)
            if item_data:
                stat_value = item_data.get(
                    stat_name, 0.0
                )  # Get base stat for the item
                total_gear_stat += stat_value
                # Add class bonus (50% of item stat) if item matches user class
                if item_data.get("klass") == self.klass:
                    class_bonus_stat += stat_value * 0.5

        return total_gear_stat + class_bonus_stat

    def calculate_total_stat(self, stat_name: str) -> float:
        """Calculates total effective stat (base + train + gear + buff + level)."""
        base_stat = getattr(self, stat_name, 0)  # e.g., self.strength
        train_stat = getattr(
            self, f"train_{stat_name}", 0
        )  # e.g., self.train_str
        buff_stat = getattr(
            self, f"buff_{stat_name}", 0.0
        )  # e.g., self.buff_str
        gear_stat = self._get_gear_stat_bonus(stat_name)

        # Level bonus: 1 point per 2 levels, max 50 points (at level 100)
        level_bonus = min(50.0, math.floor(self.level / 2.0))

        return base_stat + gear_stat + buff_stat + level_bonus

    def _calculate_max_hp(self) -> float:
        """Calculates maximum HP based on Constitution."""
        # Formula: Base Max HP (50) + Effective CON * 2
        # Ensure effective CON calculation happened first
        return float(
            self.max_hp_base + math.floor(self.effective_constitution * 2.0)
        )

    def _calculate_max_mp(self) -> float:
        """Calculates maximum MP based on Intelligence."""
        # Formula: Base Max MP + Effective INT * 2, Max possible 200 + Base Max MP? Check specifics.
        # Let's use a simpler formula first: Base + Eff INT * 2
        # Note: Different sources might have slightly different formulas.
        return float(
            self.max_mp_base + math.floor(self.effective_intelligence * 2.0)
        )

    def __repr__(self) -> str:
        return (
            f"UserStats(lvl={self.level}, class='{self.klass}', "
            f"hp={self.hp:.1f}/{self.max_hp:.1f}, mp={self.mp:.1f}/{self.max_mp:.1f}, "
            f"exp={self.exp:.1f}/{self.exp_to_next_level}, gp={self.gp:.2f})"
        )

class UserAchievements:
"""User's achievements progress."""

    def __init__(self, achievements_data: dict[str, Any]):
        # list of earned achievement keys
        self.earned_list: list[str] = list(
            achievements_data.keys()
        )  # If structure is {key: true}
        # Or parse specific known achievements if structure varies
        self.challenges: list[str] = achievements_data.get("challenges", [])
        self.perfect_days: int = achievements_data.get(
            "perfect", 0
        )  # Count of perfect days
        self.streak: int = achievements_data.get(
            "streak", 0
        )  # Max perfect day streak
        self.all_days: int = achievements_data.get("loginIncentives", 0)
        # Add ultimate gear achievements, quest counts etc. if needed

    def __repr__(self) -> str:
        return f"UserAchievements(earned={len(self.earned_list)}, streak={self.streak}, perfect={self.perfect_days})"

class UserItems:
"""User's inventory: gear, items, pets, mounts etc."""

    def __init__(self, items_data: dict[str, Any]):
        gear = items_data.get("gear", {})
        # Store equipped item keys
        self.gear_equipped: dict[str, str] = gear.get("equipped", {})
        # Store costume item keys

class UserPartyInfo:
"""Information about the user's party."""

    def __init__(self, party_data: dict[str, Any]):
        # The party object might just contain the ID when fetched via /user
        self.party_id: Optional[str] = party_data.get(
            "_id"
        )  # Often just {'_id': '...'}
        # Add other party details if the API includes more here (unlikely for /user)

    def __repr__(self) -> str:
        return f"UserPartyInfo(party_id='{self.party_id}')"

class UserInboxInfo:
"""Information about the user's inbox status."""

    def __init__(self, inbox_data: dict[str, Any]):
        self.new_messages: int = inbox_data.get("newMessages", 0)
        self.opt_out: bool = inbox_data.get(
            "optOut", False
        )  # Has user opted out of PMs?
        # Note: Actual messages are fetched separately. 'messages' key here might just be a placeholder.
        self.blocks: list[str] = inbox_data.get(
            "blocks", []
        )  # list of blocked user IDs
        self.messages: list[str] = inbox_data.get("messages", [])

    def __repr__(self) -> str:
        opt = " (Opted Out)" if self.opt_out else ""
        return f"UserInboxInfo(new={self.new_messages}{opt}, blocks={len(self.blocks)})"

# KLASS: - User (Main Class)

class User:
"""Represents the core Habitica User data, aggregating related info
from various sections of the API user object.
"""

    def __init__(
        self,
        user_data: dict[str, Any],
        all_gear_content: Optional[AllGearContent] = None,
    ):
        """Initializes a User object from the full API user data response.

        Args:
            user_data: The dictionary representing the user object from the API.
            all_gear_content: Optional dictionary containing game content definitions
                              for all gear items (needed for stat calculations).
        """
        if not isinstance(user_data, dict):
            raise TypeError("user_data must be a dictionary.")

        # --- Core User Identifier ---
        self.id: Optional[str] = user_data.get("id") or user_data.get("_id")

        # --- Balance and Login ---
        # Balance is currency for gems (1 balance = 4 gems)
        self.balance: float = float(user_data.get("balance", 0.0))
        self.gems: int = int(self.balance * 4) if self.balance > 0 else 0
        self.login_incentives: int = user_data.get(
            "loginIncentives", 0
        )  # Consecutive check-ins

        # --- Instantiate Nested Data Classes ---
        # Extract sub-dictionaries first for clarity
        profile_data = user_data.get("profile", {})
        auth_data = user_data.get("auth", {})
        stats_data = user_data.get("stats", {})
        preferences_data = user_data.get("preferences", {})
        timestamps_data = auth_data.get(
            "timestamps", {}
        )  # Timestamps are nested under auth
        items_data = user_data.get("items", {})
        achievements_data = user_data.get("achievements", {})
        party_data = user_data.get(
            "party", {}
        )  # Might just be {'_id': ...} or empty {}
        inbox_data = user_data.get("inbox", {})

        # Create instances of the nested classes
        self.profile: UserProfile = UserProfile(profile_data)
        self.auth: UserAuth = UserAuth(auth_data)
        self.preferences: UserPreferences = UserPreferences(preferences_data)
        self.timestamps: UserTimestamps = UserTimestamps(
            timestamps_data, user_data
        )  # Pass root for lastCron
        self.items: UserItems = UserItems(items_data)
        self.achievements: UserAchievements = UserAchievements(
            achievements_data
        )
        self.party_info: UserPartyInfo = UserPartyInfo(party_data)
        self.inbox_info: UserInboxInfo = UserInboxInfo(inbox_data)

        # UserStats requires stats_data, equipped_gear, and all_gear_content
        equipped_gear = self.items.gear_equipped  # Get from UserItems instance
        self.stats: UserStats = UserStats(
            stats_data, equipped_gear, all_gear_content
        )

        # --- Convenience Accessors (Optional) ---
        # Provide direct access to frequently used attributes from nested objects
        self.username: Optional[str] = self.auth.username
        self.display_name: Optional[str] = self.profile.name
        self.level: int = self.stats.level
        self.klass: Optional[str] = self.stats.klass
        self.hp: float = self.stats.hp
        self.max_hp: float = self.stats.max_hp
        self.mp: float = self.stats.mp
        self.max_mp: float = self.stats.max_mp
        self.exp: float = self.stats.exp
        self.exp_to_next_level: int = self.stats.exp_to_next_level
        self.gp: float = self.stats.gp
        self.party_id: Optional[str] = self.party_info.party_id

    def __repr__(self) -> str:
        """Developer-friendly representation."""
        return (
            f"User(id='{self.id}', username='{self.username}', "
            f"class='{self.klass}', level={self.level})"
        )

# --- Example Usage ---

if **name** == "**main**": # --- Example Gear Content (Simplified) ---
mock_gear_content = {
"weapon_warrior_1": {
"text": "Rusty Sword",
"notes": "",
"str": 2,
"con": 1,
"klass": "warrior",
},
"armor_warrior_1": {
"text": "Leather Jerkin",
"notes": "",
"con": 3,
"klass": "warrior",
},
"head_warrior_0": {
"text": "Basic Helm",
"notes": "",
"con": 1,
}, # No class req
"shield_warrior_1": {
"text": "Wooden Shield",
"notes": "",
"con": 2,
"klass": "warrior",
},
"weapon_wizard_1": {
"text": "Cracked Wand",
"notes": "",
"int": 3,
"klass": "wizard",
},
"armor_wizard_1": {
"text": "Simple Robe",
"notes": "",
"int": 1,
"con": 1,
"klass": "wizard",
},
}

    # --- Example Raw User Data (Simplified) ---
    raw_user = {
        "_id": "user-test-123",
        "id": "user-test-123",  # Often same as _id
        "balance": 10.5,  # 10.5 * 4 = 42 gems
        "loginIncentives": 5,
        "lastCron": "2025-04-17T12:00:00.000Z",
        "needsCron": False,
        "auth": {
            "local": {"username": "tester"},
            "timestamps": {
                "created": "2024-01-01T10:00:00.000Z",
                "updated": "2025-04-17T18:30:00.000Z",
                "loggedin": "2025-04-17T18:00:00.000Z",
            },
        },
        "profile": {"name": "Test User", "blurb": "Just testing things."},
        "preferences": {
            "sleep": False,
            "dayStart": 4,  # 4 AM CDS
            "timezoneOffset": -300,  # Example offset (EST)
        },
        "party": {"_id": "party-abc-456"},  # User is in a party
        "inbox": {
            "newMessages": 2,
            "optOut": False,
            "blocks": ["user-blocked-789"],
        },
        "items": {
            "gear": {
                "equipped": {
                    "weapon": "weapon_warrior_1",
                    "armor": "armor_warrior_1",
                    "head": "head_warrior_0",
                    "shield": "shield_warrior_1",
                    # Other slots empty
                },
                "costume": {},
                "owned": {
                    "weapon_warrior_1": True,
                    "armor_warrior_1": True,
                    "head_warrior_0": True,
                    "shield_warrior_1": True,
                },
            },
            "pets": {"Wolf-Base": 5},
            "mounts": {"Wolf-Base": True},
            # ... other items ...
        },
        "achievements": {
            "streak": 15,
            "perfect": 30,
            "challenges": ["challenge-id-1"],
            # Other achievements flags...
        },
        "stats": {
            "hp": 45.5,
            "mp": 30.0,
            "exp": 100.0,
            "gp": 150.25,
            "lvl": 10,
            "class": "warrior",
            "points": 2,  # Unspent attribute points
            "maxHealth": 50,  # Base max health
            "maxMP": 30,  # Base max mana
            "toNextLevel": 250,
            "str": 5,  # Allocated points
            "int": 2,
            "con": 8,
            "per": 3,
            "buffs": {
                "str": 0,
                "int": 0,
                "con": 5,
                "per": 0,
                "stealth": 0,  # Example CON buff active
            },
            "training": {  # Permanent increases from leveling
                "str": 2,
                "int": 0,
                "con": 4,
                "per": 1,
            },
        },
    }

    # --- Processing ---
    # Pass the raw user data AND the gear content definitions
    user = User(raw_user, all_gear_content=mock_gear_content)

    # --- Accessing Data ---
    print("--- Processed User ---")
    print(user)  # Uses User.__repr__
    print(f"  Username: {user.username}")
    print(f"  Display Name: {user.display_name}")
    print(f"  Gems: {user.gems}")
    print(f"  Party ID: {user.party_id}")
    print(f"  Last Cron: {user.timestamps.last_cron}")
    print(f"  Sleep?: {user.preferences.sleep}")
    print(f"  Inbox New: {user.inbox_info.new_messages}")
    print(f"  Achievements Streak: {user.achievements.streak}")
    print(f"  Equipped Weapon Key: {user.items.gear_equipped.get('weapon')}")

    print("\n--- Stats ---")
    print(f"  Raw Stats Object: {user.stats}")
    print(f"  Base CON: {user.stats.constitution}")
    print(f"  Train CON: {user.stats.train_con}")
    print(f"  Buff CON: {user.stats.buff_con}")
    # Access calculated stats:
    print(f"  Effective CON: {user.stats.effective_constitution:.2f}")
    print(f"  Effective STR: {user.stats.effective_strength:.2f}")
    print(f"  Calculated Max HP: {user.stats.max_hp:.1f}")
    print(f"  Calculated Max MP: {user.stats.max_mp:.1f}")

--- END OF FILE models/user.py ---

--- START OF FILE tui/api.py ---

# pixabit/api.py

# SECTION: - MODULE DOCSTRING

"""Provides an asynchronous HabiticaAPI client for interacting with the Habitica API v3.

This module contains the `HabiticaAPI` class, which simplifies making calls
to the Habitica API (v3) using `httpx` for non-blocking network operations.
It handles authentication using User ID and API Token (read from config),
implements automatic rate limiting, and offers async wrappers for standard
HTTP methods (GET, POST, PUT, DELETE) and convenience methods for common
endpoints like user data, tasks, tags, challenges, party, inbox, and content.
"""

# SECTION: - IMPORTS

import asyncio
import json
import time
from typing import ( # Use Dict, List etc. for Python 3.9
Any,
Optional,
Union,
)

import httpx

# Local Imports

# Assume config.py provides HABITICA_USER_ID, HABITICA_API_TOKEN

from pixabit.cli import config

# Use themed console for logging/errors if available

try:
from pixabit.utils.display import console, print
except ImportError:
import builtins

    print = builtins.print

    # Define a simple fallback console if Rich isn't available during import
    class DummyConsole:
        def print(self, *args, **kwargs):
            builtins.print(*args)

        def log(self, *args, **kwargs):
            builtins.print("LOG:", *args)  # Add LOG prefix

        def print_exception(self, *args, **kwargs):
            import traceback

            traceback.print_exc()

    console = DummyConsole()
    print("Warning: pixabit.utils.display not found, using basic print/log.")

# SECTION: - CONSTANTS

DEFAULT_BASE_URL = "https://habitica.com/api/v3"
REQUESTS_PER_MINUTE = 29 # Stay under 30/min limit
MIN_REQUEST_INTERVAL = 60.0 / REQUESTS_PER_MINUTE # ~2.07 seconds

# Type hint for the data payload within a successful Habitica API response

# Can be None (e.g., for 204 No Content or if 'data' field is missing)

HabiticaApiResponsePayload = Optional[
Union[dict[str, Any], list[dict[str, Any]]]
]

# KLASS: - HabiticaAPIError

class HabiticaAPIError(Exception):
"""Custom exception for Habitica API specific errors or request failures.

    Attributes:
        message (str): The error message.
        status_code (Optional[int]): The HTTP status code, if available.
        error_type (Optional[str]): The error type string from the Habitica API response, if available.
        response_data (Optional[Any]): The raw response data, if available.
    """

    def __init__(
        self,
        message: str,
        status_code: Optional[int] = None,
        error_type: Optional[str] = None,
        response_data: Optional[Any] = None,
    ):
        """Initializes the HabiticaAPIError."""
        super().__init__(message)
        self.status_code = status_code
        self.error_type = error_type
        self.response_data = response_data

    def __str__(self) -> str:
        """String representation of the error."""
        details = []
        if self.status_code is not None:
            details.append(f"Status={self.status_code}")
        if self.error_type:
            details.append(f"Type='{self.error_type}'")
        base_msg = super().__str__()
        return f"HabiticaAPIError: {base_msg}" + (
            f" ({', '.join(details)})" if details else ""
        )

# KLASS: - HabiticaAPI

class HabiticaAPI:
"""Asynchronous client for interacting with the Habitica API v3 using httpx.

    Handles authentication, rate limiting, standard HTTP requests (GET, POST,
    PUT, DELETE), and provides convenience methods for common Habitica operations.
    Credentials are loaded via the `config` module by default.

    Attributes:
        user_id: Habitica User ID.
        api_token: Habitica API Token.
        base_url: Base URL for the API (default: v3).
        headers: Standard request headers including auth & client ID.
        request_interval: Min seconds between requests for rate limiting.
        last_request_time: Monotonic timestamp of the last request initiation.
    """

    BASE_URL: str = DEFAULT_BASE_URL

    # FUNC: - __init__
    def __init__(
        self,
        user_id: Optional[str] = None,
        api_token: Optional[str] = None,
        base_url: str = DEFAULT_BASE_URL,
    ):
        """Initializes the asynchronous HabiticaAPI client.

        Args:
            user_id: Habitica User ID. Defaults to config.HABITICA_USER_ID.
            api_token: Habitica API Token. Defaults to config.HABITICA_API_TOKEN.
            base_url: The base URL for the Habitica API.

        Raises:
            ValueError: If User ID or API Token is missing after checking args/config.
        """
        self.user_id: str = user_id or config.HABITICA_USER_ID
        self.api_token: str = api_token or config.HABITICA_API_TOKEN
        self.base_url: str = base_url

        if not self.user_id or not self.api_token:
            # This check ensures required credentials are present upon instantiation.
            raise ValueError("Habitica User ID and API Token are required.")

        self.headers: dict[str, str] = {
            "x-api-user": self.user_id,
            "x-api-key": self.api_token,
            "Content-Type": "application/json",
            "x-client": "pixabit-tui-v0.1.0",  # Identify your client (update version as needed)
        }

        # Rate limiting attributes
        self.last_request_time: float = 0.0  # Uses time.monotonic()
        self.request_interval: float = MIN_REQUEST_INTERVAL

        # Consider creating the client once if making frequent calls
        # self._http_client = httpx.AsyncClient(headers=self.headers, timeout=120)
        # Remember to handle closing the client gracefully on app exit if you do this.

    # SECTION: - Internal Helper Methods
    # FUNC: - _wait_for_rate_limit
    async def _wait_for_rate_limit(self) -> None:
        """Asynchronously waits if necessary to enforce the request rate limit."""
        current_time = time.monotonic()
        time_since_last = current_time - self.last_request_time
        if time_since_last < self.request_interval:
            wait_time = self.request_interval - time_since_last
            await asyncio.sleep(wait_time)
        # Record the time just before the request is actually sent
        self.last_request_time = time.monotonic()

    # FUNC: - _request
    async def _request(
        self, method: str, endpoint: str, **kwargs: Any
    ) -> HabiticaApiResponsePayload:
        """Internal async method for making API requests with rate limiting & error handling.

        Args:
            method: HTTP method string ('GET', 'POST', 'PUT', 'DELETE').
            endpoint: API endpoint path (e.g., '/user').
            kwargs: Additional arguments for `httpx.AsyncClient.request` (e.g., json, params).

        Returns:
            The JSON payload (dict or list) on success, or None for 204 No Content.

        Raises:
            HabiticaAPIError: For API-specific errors or network/request issues.
            ValueError: For unexpected non-JSON or invalid JSON structure responses.
            Exception: For other unexpected errors during the request lifecycle.
        """
        await self._wait_for_rate_limit()
        url = f"{self.base_url.rstrip('/')}/{endpoint.lstrip('/')}"
        response: Optional[httpx.Response] = None
        # console.log(f"API Request: {method} {url}", style="subtle")

        try:
            # Create a new client per request for simplicity. Use instance client for performance.
            async with httpx.AsyncClient(timeout=120) as client:
                response = await client.request(
                    method, url, headers=self.headers, **kwargs
                )

            response.raise_for_status()  # Raise httpx.HTTPStatusError for 4xx/5xx

            # Handle successful 204 No Content or empty body
            if response.status_code == 204 or not response.content:
                return None

            response_data = response.json()  # Parse JSON body

            # Check for Habitica's standard {success, data, ...} wrapper
            if isinstance(response_data, dict) and "success" in response_data:
                if response_data["success"]:
                    return response_data.get(
                        "data"
                    )  # Return the 'data' payload
                else:
                    # API indicated failure in the wrapper
                    error_type = response_data.get(
                        "error", "Unknown Habitica Error"
                    )
                    message = response_data.get(
                        "message", "No message provided."
                    )
                    raise HabiticaAPIError(
                        f"{error_type} - {message}",
                        status_code=response.status_code,
                        error_type=error_type,
                        response_data=response_data,
                    )
            # Handle successful responses (2xx) *without* the standard wrapper (e.g., /content)
            elif isinstance(response_data, (dict, list)):
                return response_data  # Return the raw JSON dict or list
            else:
                # Unexpected JSON type (e.g., string, number) for a successful response
                raise ValueError(
                    f"Unexpected JSON structure received: {type(response_data)}"
                )

        # --- Specific Exception Handling ---
        except httpx.TimeoutException as timeout_err:
            msg = f"Request timed out for {method} {endpoint}"
            console.print(f"{msg}: {timeout_err}", style="error")
            raise HabiticaAPIError(msg, status_code=408) from timeout_err

        except httpx.HTTPStatusError as http_err:
            response = http_err.response
            status_code = response.status_code
            error_details = f"HTTP Error {status_code} for {method} {url}"
            try:
                # Attempt to parse Habitica error details from JSON body
                err_data = response.json()
                error_type = err_data.get("error", f"HTTP{status_code}")
                message = err_data.get(
                    "message",
                    response.reason_phrase or f"HTTP {status_code} Error",
                )
                error_details += f" | API: '{error_type}' - '{message}'"
                raise HabiticaAPIError(
                    f"{error_type} - {message}",
                    status_code=status_code,
                    error_type=error_type,
                    response_data=err_data,
                ) from http_err
            except json.JSONDecodeError:  # Response wasn't JSON
                body_preview = response.text[:200].replace("\n", "\\n")
                error_details += f" | Response Body (non-JSON): {body_preview}"
                console.print(f"Request Failed: {error_details}", style="error")
                raise HabiticaAPIError(
                    f"HTTP Error {status_code} with non-JSON body",
                    status_code=status_code,
                ) from http_err

        except (
            httpx.RequestError
        ) as req_err:  # Other network errors (connection, DNS)
            msg = f"Network/Request Error for {method} {endpoint}"
            console.print(f"{msg}: {req_err}", style="error")
            raise HabiticaAPIError(msg) from req_err

        except (
            json.JSONDecodeError
        ) as json_err:  # Parsing failed on a 2xx response
            msg = f"Could not decode successful JSON response from {method} {endpoint}"
            status = response.status_code if response else "N/A"
            body = (
                response.text[:200].replace("\n", "\\n") if response else "N/A"
            )
            console.print(
                f"{msg} (Status: {status}, Body: {body})", style="error"
            )
            raise ValueError(
                f"Invalid JSON received from {method} {endpoint}"
            ) from json_err

        except (
            ValueError
        ) as val_err:  # Catch ValueErrors raised internally (e.g., unexpected structure)
            console.print(
                f"Data Error for {method} {endpoint}: {val_err}", style="error"
            )
            raise  # Re-raise ValueError

        except Exception as e:  # Catch-all for other unexpected errors
            console.print(
                f"Unexpected error during API request ({method} {endpoint}): {type(e).__name__} - {e}",
                style="error",
            )
            console.print_exception(show_locals=False)
            raise HabiticaAPIError(f"Unexpected error: {e}") from e

    # SECTION: - Core HTTP Request Methods
    # FUNC: - get
    async def get(
        self, endpoint: str, params: Optional[dict[str, Any]] = None
    ) -> HabiticaApiResponsePayload:
        """Sends an asynchronous GET request.

        Args:
            endpoint: The API endpoint path (e.g., '/user').
            params: Optional dictionary of query parameters.

        Returns:
            The JSON response payload (dict or list) or None on error/no content.
        """
        return await self._request("GET", endpoint, params=params)

    # FUNC: - post
    async def post(
        self,
        endpoint: str,
        data: Optional[dict[str, Any]] = None,
        params: Optional[dict[str, Any]] = None,
    ) -> HabiticaApiResponsePayload:
        """Sends an asynchronous POST request with an optional JSON body and query params.

        Args:
            endpoint: The API endpoint path (e.g., '/tasks/user').
            data: Optional dictionary for the JSON request body.
            params: Optional dictionary of query parameters.

        Returns:
            The JSON response payload (dict or list) or None on error/no content.
        """
        return await self._request("POST", endpoint, json=data, params=params)

    # FUNC: - put
    async def put(
        self,
        endpoint: str,
        data: Optional[dict[str, Any]] = None,
        params: Optional[dict[str, Any]] = None,
    ) -> HabiticaApiResponsePayload:
        """Sends an asynchronous PUT request with an optional JSON body and query params.

        Args:
            endpoint: The API endpoint path (e.g., '/tasks/{taskId}').
            data: Optional dictionary for the JSON request body.
            params: Optional dictionary of query parameters.

        Returns:
            The JSON response payload (dict or list) or None on error/no content.
        """
        return await self._request("PUT", endpoint, json=data, params=params)

    # FUNC: - delete
    async def delete(
        self, endpoint: str, params: Optional[dict[str, Any]] = None
    ) -> HabiticaApiResponsePayload:
        """Sends an asynchronous DELETE request with optional query params.

        Args:
            endpoint: The API endpoint path (e.g., '/tasks/{taskId}').
            params: Optional dictionary of query parameters.

        Returns:
            The JSON response payload (often None or empty dict) or None on error.
        """
        return await self._request("DELETE", endpoint, params=params)

    # SECTION: - Convenience Methods (User)
    # FUNC: - get_user_data
    async def get_user_data(self) -> Optional[dict[str, Any]]:
        """Async GET /user - Retrieves the full user object data."""
        result = await self.get("/user")
        return result if isinstance(result, dict) else None

    # FUNC: - update_user
    async def update_user(
        self, update_data: dict[str, Any]
    ) -> Optional[dict[str, Any]]:
        """Async PUT /user - Updates general user settings."""
        result = await self.put("/user", data=update_data)
        return result if isinstance(result, dict) else None

    # FUNC: - set_custom_day_start
    async def set_custom_day_start(self, hour: int) -> Optional[dict[str, Any]]:
        """Async Sets user's Custom Day Start hour (0-23) via PUT /user."""
        # Note: API v3 uses PUT /user for this, v4 uses POST /user/custom-day-start
        if not 0 <= hour <= 23:
            raise ValueError("Hour must be between 0 and 23")
        # Using PUT /user based on original code structure
        # return await self.update_user({"preferences.dayStart": hour})
        # If targeting v4 specifically:
        result = await self.post(
            "/user/custom-day-start", data={"dayStart": hour}
        )
        return result if isinstance(result, dict) else None

    # FUNC: - toggle_user_sleep
    async def toggle_user_sleep(self) -> Optional[dict[str, Any]]:
        """Async POST /user/sleep - Toggles user sleep status (Inn/Tavern)."""
        result = await self.post(
            "/user/sleep"
        )  # _request extracts 'data' payload
        if isinstance(result, bool):
            return {"sleep": result}  # Wrap boolean
        elif isinstance(result, dict):
            return result  # Return full dict if API gives more
        return None

    # FUNC: - run_cron
    async def run_cron(self) -> Optional[dict[str, Any]]:
        """Async POST /cron - Manually triggers the user's cron process."""
        # Applies damage, resets dailies/streaks etc.
        result = await self.post("/cron")
        return (
            result if isinstance(result, dict) else None
        )  # API returns task deltas

    # SECTION: - Convenience Methods (Tasks)
    # FUNC: - get_tasks
    async def get_tasks(
        self, task_type: Optional[str] = None
    ) -> list[dict[str, Any]]:
        """Async GET /tasks/user - Gets user tasks, optionally filtered by type."""
        params = {"type": task_type} if task_type else None
        result = await self.get("/tasks/user", params=params)
        return result if isinstance(result, list) else []

    # FUNC: - create_task
    async def create_task(
        self, data: dict[str, Any]
    ) -> Optional[dict[str, Any]]:
        """Async POST /tasks/user - Creates a new task."""
        if not data.get("text") or not data.get("type"):
            raise ValueError("Task data requires 'text' and 'type'.")
        result = await self.post("/tasks/user", data=data)
        return (
            result if isinstance(result, dict) else None
        )  # Returns created task object

    # FUNC: - update_task
    async def update_task(
        self, task_id: str, data: dict[str, Any]
    ) -> Optional[dict[str, Any]]:
        """Async PUT /tasks/{taskId} - Updates an existing task.

        Args:
            task_id: The ID of the task to update.
            data: Dictionary of task attributes to update. See Habitica API docs.
                  Common fields: text, notes, attribute, priority, date, checklist, etc.
        """
        if not task_id:
            raise ValueError("task_id cannot be empty.")
        result = await self.put(f"/tasks/{task_id}", data=data)
        return (
            result if isinstance(result, dict) else None
        )  # Returns updated task object

    # FUNC: - delete_task
    async def delete_task(self, task_id: str) -> Optional[dict[str, Any]]:
        """Async DELETE /tasks/{taskId} - Deletes a task."""
        if not task_id:
            raise ValueError("task_id cannot be empty.")
        result = await self.delete(f"/tasks/{task_id}")
        # API v3 returns { "data": null } on success, _request returns None.
        # Return None explicitly for successful deletion or error.
        return None

    # FUNC: - score_task
    async def score_task(
        self, task_id: str, direction: str = "up"
    ) -> Optional[dict[str, Any]]:
        """Async POST /tasks/{taskId}/score/{direction} - Scores a task (+/-)."""
        if not task_id:
            raise ValueError("task_id cannot be empty.")
        if direction not in ["up", "down"]:
            raise ValueError("Direction must be 'up' or 'down'.")
        result = await self.post(f"/tasks/{task_id}/score/{direction}")
        return (
            result if isinstance(result, dict) else None
        )  # Returns score result object

    # FUNC: - set_attribute
    async def set_attribute(
        self, task_id: str, attribute: str
    ) -> Optional[dict[str, Any]]:
        """Async Sets task attribute ('str', 'int', 'con', 'per') via update_task."""
        if attribute not in ["str", "int", "con", "per"]:
            raise ValueError("Invalid attribute.")
        return await self.update_task(task_id, {"attribute": attribute})

    # FUNC: - move_task_to_position
    async def move_task_to_position(
        self, task_id: str, position: int
    ) -> Optional[list[str]]:
        """Async POST /tasks/{taskId}/move/to/{position} - Moves task (0=top, -1=bottom)."""
        if not task_id:
            raise ValueError("task_id cannot be empty.")
        if position not in [0, -1]:
            raise ValueError("Position must be 0 (top) or -1 (bottom).")
        result = await self.post(f"/tasks/{task_id}/move/to/{position}")
        # API v3 returns list of sorted task IDs in 'data' field
        return result if isinstance(result, list) else None

    # FUNC: - clear_completed_todos
    async def clear_completed_todos(self) -> Optional[dict[str, Any]]:
        """Async POST /tasks/clearCompletedTodos - Deletes user's completed ToDos."""
        # Note: Tasks in active Challenges/Group Plans are not deleted.
        result = await self.post("/tasks/clearCompletedTodos")
        # API v3 returns { "data": null } on success, _request returns None.
        return None

    # SECTION: - Convenience Methods (Tags)
    # FUNC: - get_tags
    async def get_tags(self) -> list[dict[str, Any]]:
        """Async GET /tags - Gets all user tags."""
        result = await self.get("/tags")
        return result if isinstance(result, list) else []

    # FUNC: - create_tag
    async def create_tag(self, name: str) -> Optional[dict[str, Any]]:
        """Async POST /tags - Creates a new tag."""
        if not name or not name.strip():
            raise ValueError("Tag name cannot be empty.")
        result = await self.post("/tags", data={"name": name.strip()})
        return (
            result if isinstance(result, dict) else None
        )  # Returns the created tag object

    # FUNC: - update_tag
    async def update_tag(
        self, tag_id: str, name: str
    ) -> Optional[dict[str, Any]]:
        """Async PUT /tags/{tagId} - Updates tag name."""
        if not tag_id:
            raise ValueError("tag_id cannot be empty.")
        if not name or not name.strip():
            raise ValueError("New tag name cannot be empty.")
        result = await self.put(f"/tags/{tag_id}", data={"name": name.strip()})
        return (
            result if isinstance(result, dict) else None
        )  # Returns updated tag object

    # FUNC: - delete_tag
    async def delete_tag(self, tag_id: str) -> Optional[dict[str, Any]]:
        """Async DELETE /tags/{tagId} - Deletes tag globally."""
        if not tag_id:
            raise ValueError("tag_id cannot be empty.")
        result = await self.delete(f"/tags/{tag_id}")
        # API v3 returns { "data": null } on success, _request returns None.
        return None

    # FUNC: - reorder_tag
    async def reorder_tag(
        self, tag_id: str, position: int
    ) -> Optional[dict[str, Any]]:
        """Async POST /reorder-tags - Reorder a specific tag.

        Args:
            tag_id: The UUID of the tag to move.
            position: The 0-based index to move the tag to (-1 for bottom).

        Returns:
            None on success (API returns {"data": null}). Raises error on failure.
        """
        if not tag_id:
            raise ValueError("tag_id cannot be empty.")
        if not isinstance(position, int) or position < -1:
            raise ValueError("position must be >= -1.")
        payload = {"tagId": tag_id, "to": position}
        result = await self.post("/reorder-tags", data=payload)
        # API v3 returns { "data": null } on success, _request returns None.
        return None

    # FUNC: - add_tag_to_task
    async def add_tag_to_task(
        self, task_id: str, tag_id: str
    ) -> Optional[dict[str, Any]]:
        """Async POST /tasks/{taskId}/tags/{tagId} - Associates tag with task."""
        if not task_id or not tag_id:
            raise ValueError("task_id and tag_id cannot be empty.")
        result = await self.post(f"/tasks/{task_id}/tags/{tag_id}")
        # API v3 returns { "data": { "tags": [...] } } (updated task tags list)
        return result if isinstance(result, dict) else None

    # FUNC: - delete_tag_from_task
    async def delete_tag_from_task(
        self, task_id: str, tag_id: str
    ) -> Optional[dict[str, Any]]:
        """Async DELETE /tasks/{taskId}/tags/{tagId} - Removes tag from task."""
        if not task_id or not tag_id:
            raise ValueError("task_id and tag_id cannot be empty.")
        result = await self.delete(f"/tasks/{task_id}/tags/{tag_id}")
        # API v3 returns { "data": { "tags": [...] } } (updated task tags list)
        return result if isinstance(result, dict) else None

    # SECTION: - Convenience Methods (Checklist)
    # FUNC: - add_checklist_item
    async def add_checklist_item(
        self, task_id: str, text: str
    ) -> Optional[dict[str, Any]]:
        """Async POST /tasks/{taskId}/checklist - Adds checklist item."""
        if not task_id or not text:
            raise ValueError("task_id and text cannot be empty.")
        result = await self.post(
            f"/tasks/{task_id}/checklist", data={"text": text}
        )
        return (
            result if isinstance(result, dict) else None
        )  # Returns updated task object

    # FUNC: - update_checklist_item
    async def update_checklist_item(
        self, task_id: str, item_id: str, text: str
    ) -> Optional[dict[str, Any]]:
        """Async PUT /tasks/{taskId}/checklist/{itemId} - Updates checklist item text."""
        if not task_id or not item_id or text is None:
            raise ValueError("task_id, item_id, and text required.")
        result = await self.put(
            f"/tasks/{task_id}/checklist/{item_id}", data={"text": text}
        )
        return (
            result if isinstance(result, dict) else None
        )  # Returns updated task object

    # FUNC: - delete_checklist_item
    async def delete_checklist_item(
        self, task_id: str, item_id: str
    ) -> Optional[dict[str, Any]]:
        """Async DELETE /tasks/{taskId}/checklist/{itemId} - Deletes checklist item."""
        if not task_id or not item_id:
            raise ValueError("task_id and item_id required.")
        result = await self.delete(f"/tasks/{task_id}/checklist/{item_id}")
        return (
            result if isinstance(result, dict) else None
        )  # Returns updated task object

    # FUNC: - score_checklist_item
    async def score_checklist_item(
        self, task_id: str, item_id: str
    ) -> Optional[dict[str, Any]]:
        """Async POST /tasks/{taskId}/checklist/{itemId}/score - Toggles checklist item."""
        if not task_id or not item_id:
            raise ValueError("task_id and item_id required.")
        result = await self.post(f"/tasks/{task_id}/checklist/{item_id}/score")
        return (
            result if isinstance(result, dict) else None
        )  # Returns updated task object

    # SECTION: - Convenience Methods (Challenges)
    # FUNC: - get_challenges
    async def get_challenges(
        self, member_only: bool = True
    ) -> list[dict[str, Any]]:
        """Async GET /challenges/user - Gets challenges, handles pagination."""
        all_challenges = []
        page = 0
        member_param = "true" if member_only else "false"
        # console.log(f"Fetching challenges (member_only={member_only}, paginating)...", style="info")
        while True:
            try:
                page_data = await self.get(
                    "/challenges/user",
                    params={"member": member_param, "page": page},
                )
                if isinstance(page_data, list):
                    if not page_data:
                        break
                    all_challenges.extend(page_data)
                    page += 1
                else:
                    console.print(
                        f"Warning: Expected list from /challenges/user page {page}, got {type(page_data)}. Stop.",
                        style="warning",
                    )
                    break
            except HabiticaAPIError as e:
                console.print(
                    f"API Error fetching challenges page {page}: {e}. Stop.",
                    style="error",
                )
                break
            except Exception as e:
                console.print(
                    f"Unexpected Error fetching challenges page {page}: {e}. Stop.",
                    style="error",
                )
                break
        # console.log(f"Finished fetching challenges. Total: {len(all_challenges)}", style="info")
        return all_challenges

    # FUNC: - create_challenge
    async def create_challenge(
        self, data: dict[str, Any]
    ) -> Optional[dict[str, Any]]:
        """Async POST /challenges - Creates challenge."""
        # Basic validation (consult API docs for required fields like name, shortName, group)
        if (
            not data.get("name")
            or not data.get("shortName")
            or not data.get("group")
        ):
            raise ValueError(
                "Challenge creation requires at least 'name', 'shortName', and 'group' ID."
            )
        result = await self.post("/challenges", data=data)
        return (
            result if isinstance(result, dict) else None
        )  # Returns created challenge object

    # FUNC: - get_challenge_tasks
    async def get_challenge_tasks(
        self, challenge_id: str
    ) -> list[dict[str, Any]]:
        """Async GET /tasks/challenge/{challengeId} - Gets tasks for a challenge."""
        if not challenge_id:
            raise ValueError("challenge_id cannot be empty.")
        result = await self.get(f"/tasks/challenge/{challenge_id}")
        # API returns list of task objects in 'data' field
        return result if isinstance(result, list) else []

    # FUNC: - create_challenge_task
    async def create_challenge_task(
        self, challenge_id: str, task_data: dict[str, Any]
    ) -> Optional[dict[str, Any]]:
        """Async POST /tasks/challenge/{challengeId} - Creates a single task for a challenge.

        Args:
            challenge_id: The ID of the challenge.
            task_data: Dictionary representing the task to create (must include 'text', 'type').

        Returns:
            The created task object dictionary, or None on failure.
        """
        if not challenge_id:
            raise ValueError("challenge_id cannot be empty.")
        if not task_data.get("text") or not task_data.get("type"):
            raise ValueError("Task data requires 'text' and 'type'.")
        if task_data["type"] not in {"habit", "daily", "todo", "reward"}:
            raise ValueError("Invalid task type.")

        result = await self.post(
            f"/tasks/challenge/{challenge_id}", data=task_data
        )
        # API returns the created task object in 'data' field
        return result if isinstance(result, dict) else None

    # FUNC: - unlink_task_from_challenge
    async def unlink_task_from_challenge(
        self, task_id: str, keep: str = "keep"
    ) -> Optional[dict[str, Any]]:
        """Async POST /tasks/{taskId}/unlink?keep={keep} - Unlinks task from challenge."""
        if not task_id:
            raise ValueError("task_id cannot be empty.")
        if keep not in ["keep", "remove"]:
            raise ValueError("keep must be 'keep' or 'remove'")
        result = await self.post(
            f"/tasks/{task_id}/unlink", params={"keep": keep}
        )
        # API v3 returns {"data": null}, _request returns None
        return None

    # FUNC: - unlink_all_challenge_tasks
    async def unlink_all_challenge_tasks(
        self, challenge_id: str, keep: str = "keep-all"
    ) -> Optional[dict[str, Any]]:
        """Async POST /tasks/unlink-all/{challengeId}?keep={keep} - Unlinks all tasks."""
        if not challenge_id:
            raise ValueError("challenge_id cannot be empty.")
        if keep not in ["keep-all", "remove-all"]:
            raise ValueError("keep must be 'keep-all' or 'remove-all'")
        result = await self.post(
            f"/tasks/unlink-all/{challenge_id}?keep={keep}"
        )
        # API v3 returns {"data": null}, _request returns None
        return None

    # FUNC: - leave_challenge
    async def leave_challenge(
        self, challenge_id: str, keep: str = "keep-all"
    ) -> Optional[dict[str, Any]]:
        """Async POST /challenges/{challengeId}/leave?keep={keep} - Leaves challenge."""
        if not challenge_id:
            raise ValueError("challenge_id cannot be empty.")
        if keep not in ["keep-all", "remove-all"]:
            raise ValueError("keep must be 'keep-all' or 'remove-all'")
        result = await self.post(
            f"/challenges/{challenge_id}/leave?keep={keep}"
        )
        # API v3 returns {"data": null}, _request returns None
        return None

    # FUNC: - clone_challenge
    async def clone_challenge(
        self, challenge_id: str
    ) -> Optional[dict[str, Any]]:
        """Async POST /challenges/{challengeId}/clone - Clones a challenge."""
        if not challenge_id:
            raise ValueError("challenge_id cannot be empty.")
        result = await self.post(f"/challenges/{challenge_id}/clone")
        # API returns the newly cloned challenge object in 'data' field
        return result if isinstance(result, dict) else None

    # FUNC: - update_challenge
    async def update_challenge(
        self, challenge_id: str, **kwargs: Any
    ) -> Optional[dict[str, Any]]:
        """Async PUT /challenges/{challengeId} - Updates challenge details (leader only)."""
        if not challenge_id:
            raise ValueError("challenge_id cannot be empty.")
        allowed_fields = {"name", "summary", "description"}
        update_data = {
            k: v
            for k, v in kwargs.items()
            if k in allowed_fields and v is not None
        }  # Filter nulls
        if not update_data:
            raise ValueError("No valid update fields provided.")
        result = await self.put(f"/challenges/{challenge_id}", data=update_data)
        # API returns the updated challenge object in 'data' field
        return result if isinstance(result, dict) else None

    # SECTION: - Convenience Methods (Party / Groups)
    # FUNC: - get_party_data
    async def get_party_data(self) -> Optional[dict[str, Any]]:
        """Async GET /groups/party - Gets data for the user's current party."""
        result = await self.get("/groups/party")
        return result if isinstance(result, dict) else None

    # FUNC: - get_quest_status
    async def get_quest_status(self) -> bool:
        """Async Checks if user's party is on an active quest."""
        try:
            party_data = await self.get_party_data()
            return (
                party_data is not None
                and party_data.get("quest", {}).get("active", False) is True
            )
        except Exception as e:
            console.print(f"Could not get quest status: {e}", style="warning")
            return False

    # FUNC: - cast_skill
    async def cast_skill(
        self, spell_id: str, target_id: Optional[str] = None
    ) -> Optional[dict[str, Any]]:
        """Async POST /user/class/cast/{spellId}?targetId={targetId} - Casts a skill."""
        if not spell_id:
            raise ValueError("spell_id cannot be empty.")
        # Basic validation - consider using an Enum or Set for allowed_spells
        params = {"targetId": target_id} if target_id else None
        result = await self.post(f"/user/class/cast/{spell_id}", params=params)
        # API returns user delta and potentially target deltas in 'data' field
        return result if isinstance(result, dict) else None

    # FUNC: - get_group_chat_messages
    async def get_group_chat_messages(
        self, group_id: str = "party"
    ) -> list[dict[str, Any]]:
        """Async GET /groups/{groupId}/chat - Gets chat messages for a group ('party' or UUID)."""
        if not group_id:
            raise ValueError(
                "group_id cannot be empty ('party', guild ID, etc.)."
            )
        result = await self.get(f"/groups/{group_id}/chat")
        # API returns list of chat message objects in 'data' field
        return result if isinstance(result, list) else []

    # FUNC: - like_group_chat_message
    async def like_group_chat_message(
        self, group_id: str, chat_id: str
    ) -> Optional[dict[str, Any]]:
        """Async POST /groups/{groupId}/chat/{chatId}/like - Likes a group chat message."""
        if not group_id or not chat_id:
            raise ValueError("group_id and chat_id required.")
        result = await self.post(f"/groups/{group_id}/chat/{chat_id}/like")
        # API returns the updated chat message object in 'data' field
        return result if isinstance(result, dict) else None

    # FUNC: - mark_group_chat_seen
    async def mark_group_chat_seen(
        self, group_id: str = "party"
    ) -> Optional[dict[str, Any]]:
        """Async POST /groups/{groupId}/chat/seen - Marks group messages as read."""
        if not group_id:
            raise ValueError("group_id cannot be empty.")
        result = await self.post(f"/groups/{group_id}/chat/seen")
        # API v3 returns {"data": null}, _request returns None
        return None

    # FUNC: - post_group_chat_message
    async def post_group_chat_message(
        self, group_id: str = "party", message_text: str = ""
    ) -> Optional[dict[str, Any]]:
        """Async POST /groups/{groupId}/chat - Posts a chat message to a group."""
        if not group_id:
            raise ValueError("group_id required.")
        if not message_text or not message_text.strip():
            raise ValueError("message_text cannot be empty.")
        payload = {"message": message_text.strip()}
        result = await self.post(f"/groups/{group_id}/chat", data=payload)
        # API returns the posted message object in 'data' field
        return result if isinstance(result, dict) else None

    # SECTION: - Convenience Methods (Inbox)
    # FUNC: - get_inbox_messages
    async def get_inbox_messages(
        self, page: int = 0, conversation_id: Optional[str] = None
    ) -> list[dict[str, Any]]:
        """Async GET /inbox/messages - Gets inbox messages, optionally filtered."""
        params: dict[str, Any] = {"page": page}
        if conversation_id:
            params["conversation"] = conversation_id
        result = await self.get("/inbox/messages", params=params)
        # API returns list of message objects in 'data' field
        return result if isinstance(result, list) else []

    # FUNC: - like_private_message
    async def like_private_message(
        self, unique_message_id: str
    ) -> Optional[dict[str, Any]]:
        """Async POST /inbox/like-private-message/{uniqueMessageId} - Likes a private message."""
        # Note: Uses V4 path as specified in original file. Confirmed in some docs.
        if not unique_message_id:
            raise ValueError("unique_message_id required.")
        result = await self.post(
            f"/inbox/like-private-message/{unique_message_id}"
        )
        # API returns the liked message object in 'data' field
        return result if isinstance(result, dict) else None

    # FUNC: - send_private_message
    async def send_private_message(
        self, recipient_id: str, message_text: str
    ) -> Optional[dict[str, Any]]:
        """Async POST /members/send-private-message - Sends a private message."""
        if not recipient_id:
            raise ValueError("recipient_id required.")
        if not message_text or not message_text.strip():
            raise ValueError("message_text required.")
        payload = {"toUserId": recipient_id, "message": message_text.strip()}
        result = await self.post("/members/send-private-message", data=payload)
        # API returns the sent message object in 'data' field
        return result if isinstance(result, dict) else None

    # FUNC: - mark_pms_read
    async def mark_pms_read(self) -> Optional[dict[str, Any]]:
        """Async POST /user/mark-pms-read - Marks all private messages as read."""
        result = await self.post("/user/mark-pms-read")
        # API v3 returns {"data": null}, _request returns None
        return None

    # FUNC: - delete_private_message
    async def delete_private_message(
        self, message_id: str
    ) -> Optional[dict[str, Any]]:
        """Async DELETE /user/messages/{id} - Deletes a specific private message."""
        if not message_id:
            raise ValueError("message_id required.")
        result = await self.delete(f"/user/messages/{message_id}")
        # API v3 returns list of remaining messages in 'data' field? Or null? Check docs.
        # Assuming it returns null based on other delete actions.
        return None

    # SECTION: - Convenience Methods (Content)
    # FUNC: - get_content
    async def get_content(self) -> Optional[dict[str, Any]]:
        """Async GET /content - Retrieves the game content object."""
        result = await self._request(
            "GET", "/content"
        )  # Uses internal request (no wrapper)
        return result if isinstance(result, dict) else None

    # FUNC: - get_model_paths
    async def get_model_paths(
        self, model_name: str
    ) -> Optional[dict[str, Any]]:
        """Async GET /models/{model}/paths - Gets field paths for a data model."""
        if not model_name:
            raise ValueError("model_name cannot be empty.")
        allowed = {
            "user",
            "group",
            "challenge",
            "tag",
            "habit",
            "daily",
            "todo",
            "reward",
        }
        if model_name not in allowed:
            raise ValueError(f"Invalid model_name. Allowed: {allowed}")
        result = await self.get(f"/models/{model_name}/paths")
        # API returns {"data": {"path": "type", ...}}
        return result if isinstance(result, dict) else None

# --- End of File ---

--- END OF FILE tui/api.py ---

--- START OF FILE tui/app.py ---

# pixabit/cli/app.py

# MARK: - MODULE DOCSTRING

"""Main Command Line Interface application class for Pixabit - TEXTUAL TUI VERSION.

(Phase 1: Basic Textual App Structure)
"""

# --- Standard Imports ---

import asyncio

# Import asyncio

import sys

# Import sys for system exit

from typing import Any, Dict

# --- Third-party Imports (Textual & Rich) ---

from textual.app import App, ComposeResult
from textual.containers import Container, Vertical

# Layout containers

from textual.widgets import Footer, Header, Label

# Basic widgets

# --- Local Application Imports ---

try:
from pixabit.cli.api import HabiticaAPI

# Still need API Client

except ImportError:
print("[Fatal Error] Could not import Pixabit modules in app.py.")
sys.exit(1)

# MARK: - PixabitTUIApp Class (Textual App)

# ==============================================================================

class PixabitTUIApp(App):
"""Basic Textual TUI Application for Pixabit - PLACEHOLDER UI."""

    CSS_PATH = "pixabit.tcss"

# Link CSS file for styling

    BINDINGS = [
        ("q", "quit_app", "Quit"),

# Keybinding to quit

        ("r", "refresh_data_ui", "Refresh Data (Placeholder)"),

# Keybinding for refresh

    ]

# & - def **init**(self, \*\*kwargs):

    def __init__(self, **kwargs):
        """Initialize Pixabit TUI App (basic init)."""
        super().__init__(**kwargs)
        self.api_client = HabiticaAPI()

# API Client (still sync for now)

# & - async def on_mount(self) -> None:

    async def on_mount(self) -> None:
        """Async on_mount hook - initial async setup."""
        self.title = "Pixabit - Placeholder UI"
        self.subtitle = "Alpha - Placeholder UI"
        self.console.log("Textual App Mounted (on_mount)")
        await self.action_refresh_data_ui()

# Call placeholder refresh

# & - def compose(self) -> ComposeResult:

    def compose(self) -> ComposeResult:
        """Compose the basic visual structure using placeholder widgets."""

# Yield the Header and Footer widget

        yield Header()
        yield Footer()

# Basic grid layout with placeholder panels

        yield Container(
            Vertical(Label("User Stats Placeholder", id="stats-label"), id="stats-panel"),
            Vertical(Label("Main Menu Placeholder", id="menu-label"), id="menu-panel"),
            Vertical(Label("Content Area Placeholder", id="content-label"), id="content-panel"),
            id="main-content-area",

# ID for the main container, used in CSS

        )

# MARK: - Actions (Key Bindings)

# & - async def action_quit_app(self) -> None:

    async def action_quit_app(self) -> None:
        """Action bound to 'q' - quits the app."""
        self.console.log("Action: Quit App")
        await self.shutdown()

# Textual shutdown

# & - async def action_refresh_data_ui(self) -> None:

    async def action_refresh_data_ui(self) -> None:
        """Action bound to 'r' - placeholder refresh."""
        self.console.log("Action: Refresh Data (UI)")

# --- Placeholder Refresh Logic ---

        self.console.log("Simulating data refresh...")
        await asyncio.sleep(1)

# Simulate async data loading

        self.console.log("Data refresh complete (simulated).")

# Update placeholder labels to show refresh happened

        self.query_one("

#stats-label", Label).update("User Stats Refreshed!")
self.query_one("
#menu-label", Label).update("Main Menu Refreshed!")
self.query_one(" #content-label", Label).update("Content Area Refreshed!")

# & - def \_get_content_cached(self) -> dict[str, Any]:

    def _get_content_cached(self) -> dict[str, Any]:
        """Placeholder for cached content loading."""

# Keep this placeholder function for now, implementation not critical for Phase 1

        return {}

# MARK: - Run App Function

# & - def run_app():

def run_app():
"""Run the Pixabit Textual TUI application."""
try:
app = PixabitTUIApp()
app.run()

# Run Textual app

    except Exception:
        console.print_exception(show_locals=False)

# MARK: - Entry Point

# & - if **name** == "**main**":

if **name** == "**main**":
run_app()

--- END OF FILE tui/app.py ---
--- START OF FILE tui/data_store.py ---

# pixabit/data_store.py

# MARK: - MODULE DOCSTRING

"""Provides the PixabitDataStore class, acting as a central facade for accessing
and managing application data and state. It orchestrates API calls, processing,
caching (delegated), and provides processed data models to the UI layer.
"""

# MARK: - IMPORTS

import asyncio
import time
from typing import Any, Callable, Dict, List, Optional, Union

# Core services & data structures

from .api import HabiticaAPI, HabiticaAPIError
from .data_processor import TaskProcessor, get_user_stats
from .game_content import GameContent # Use the lazy-loading version
from .models.challenge import Challenge, ChallengeList

# from .models.user_stats import UserStats # Decide if you want a dedicated Stats object

from .models.party import Party
from .models.skill import Skill, SpellList
from .models.tag import ListTag, Tag
from .models.task import ( # Import specific types
Task,
TaskList,
)

# Import ALL necessary models and containers

from .models.user import User
from .tag_manager import TagManager

# Utilities

from .utils.save_json import save_json # For saving content cache

# Import console for logging

try:
from .utils.display import console, print
except ImportError: # Basic fallback console
import builtins

    print = builtins.print

    class DummyConsole:
        def print(self, *args, **kwargs):
            builtins.print(*args)

        def log(self, *args, **kwargs):
            builtins.print("LOG:", *args)

        def print_exception(self, *args, **kwargs):
            import traceback

            traceback.print_exc()

    console = DummyConsole()

# MARK: - PixabitDataStore Class

class PixabitDataStore:
"""Central facade for managing Habitica data, API interactions, and processing.
Holds the application state (processed objects) and provides methods for access and modification.
"""

    # & - def __init__(self, app_notify_update: Callable[[], None]):
    def __init__(self, app_notify_update: Callable[[], None]):
        """Initializes the DataStore.

        Args:
            app_notify_update: A callable (likely from the TUI App) invoked after
                               data refresh to signal UI updates are needed.
        """
        self.console = console
        self.console.log("Initializing PixabitDataStore...", style="info")
        self.app_notify_update = app_notify_update  # Callback to signal UI
        try:
            self.api_client = HabiticaAPI()
            self.content_manager = (
                GameContent()
            )  # Manages lazy-loading content cache
            self.tag_manager = TagManager(self.api_client)
            self.processor: Optional[TaskProcessor] = (
                None  # Initialized during refresh
            )
        except Exception as e:
            self.console.print(f"DataStore Init Error: {e}", style="error")
            raise  # Propagate critical init errors

        # --- Application State ---
        self.user_obj: Optional[User] = None
        self.user_stats_dict: Optional[Dict[str, Any]] = None
        self.party_obj: Optional[Party] = None
        self.tags_list_obj: Optional[ListTag] = None
        self.challenges_list_obj: Optional[ChallengeList] = None
        self.tasks_list_obj: Optional[TaskList] = None
        self.spells_list_obj: Optional[SpellList] = None
        self.cats_data: Dict[str, Any] = {}  # Keep categories from processor

        self.is_refreshing: asyncio.Lock = asyncio.Lock()
        self.data_loaded_at_least_once: bool = False

        self.console.log("PixabitDataStore initialized.", style="info")

    # & - async def refresh_all_data(self) -> bool:
    async def refresh_all_data(self) -> bool:
        """Fetches, processes, updates state, and triggers UI update notification."""
        if self.is_refreshing.locked():
            self.console.log("Refresh already in progress.", style="warning")
            return False

        async with self.is_refreshing:
            self.console.log(
                "DataStore: Starting full data refresh...", style="info"
            )
            start_time = time.monotonic()
            success = False
            # Temporary raw data storage
            (
                raw_user,
                raw_content,
                raw_tags,
                raw_party,
                raw_challenges,
                raw_tasks,
            ) = (None,) * 6

            try:
                # --- 1. Fetch Raw Data Concurrently ---
                self.log("DataStore: Fetching API data...")
                results = await asyncio.gather(
                    self.api_client.get_user_data(),
                    self.api_client.get_content(),  # Fetch fresh content
                    self.api_client.get_tags(),
                    self.api_client.get_party_data(),
                    self.api_client.get_challenges(member_only=True),
                    self.api_client.get_tasks(),
                    return_exceptions=True,
                )
                (
                    raw_user,
                    raw_content,
                    raw_tags,
                    raw_party,
                    raw_challenges,
                    raw_tasks,
                ) = results

                # --- 2. Validate & Update Content Cache ---
                self.log(
                    "DataStore: Validating fetched data & updating content cache..."
                )
                if isinstance(raw_user, Exception) or not raw_user:
                    raise raw_user or ValueError("User fetch failed")
                if isinstance(raw_tasks, Exception) or not raw_tasks:
                    raise raw_tasks or ValueError(
                        "Task fetch failed"
                    )  # Tasks also critical for processor
                if isinstance(raw_content, Exception) or not raw_content:
                    raise raw_content or ValueError("Content fetch failed")

                # Update content cache file ONLY if fetch was successful
                save_json(raw_content, self.content_manager.CACHE_FILE_CONTENT)
                # Invalidate the content manager's internal cache so it reloads the new file
                self.content_manager._main_content_cache = None
                self.content_manager._cache_loaded = False
                self.log(
                    "DataStore: Main content cache file updated.", style="info"
                )

                # Handle non-critical errors for optional data
                raw_tags = self._handle_fetch_result(
                    raw_tags, "Tags", default=[]
                )
                raw_party = self._handle_fetch_result(
                    raw_party, "Party", default={}
                )
                raw_challenges = self._handle_fetch_result(
                    raw_challenges, "Challenges", default=[]
                )
                raw_tasks = (
                    raw_tasks if isinstance(raw_tasks, list) else []
                )  # Ensure list

                # --- 3. Initialize Processor ---
                self.log("DataStore: Initializing TaskProcessor...")
                # Pass the manager, processor will call get_gear_data() etc.
                self.processor = TaskProcessor(
                    user_data=raw_user,
                    party_data=raw_party,
                    all_tags_list=raw_tags,
                    game_content_manager=self.content_manager,
                )

                # --- 4. Process Tasks -> Task Objects & Categories ---
                self.log("DataStore: Processing tasks...")
                processed_results = self.processor.process_and_categorize_all(
                    raw_tasks
                )
                processed_task_objects_dict: Dict[str, Task] = (
                    processed_results.get("data", {})
                )
                self.cats_data = processed_results.get("cats", {})

                # --- 5. Instantiate/Update Model Objects & Containers ---
                self.log("DataStore: Updating state with new models...")
                self.user_obj = User(
                    raw_user,
                    all_gear_content=self.content_manager.get_gear_data(),
                )
                self.party_obj = Party(raw_party) if raw_party else None
                self.tags_list_obj = ListTag(raw_tags)
                self.tasks_list_obj = TaskList(
                    list(processed_task_objects_dict.values())
                )
                # Ensure ChallengeList constructor and linking work correctly
                self.challenges_list_obj = ChallengeList(
                    raw_challenges, task_list=self.tasks_list_obj
                )

                # --- 6. Calculate Final Stats ---
                self.log("DataStore: Calculating user stats...")
                stats_result = get_user_stats(
                    cats_dict=self.cats_data,
                    processed_tasks_dict=processed_task_objects_dict,
                    user_data=raw_user,
                )
                self.user_stats_dict = stats_result if stats_result else {}

                # --- 7. Instantiate SpellList ---
                self.spells_list_obj = SpellList(
                    raw_content_spells=self.content_manager.get_skill_data(),
                    current_user_class=(
                        self.user_obj.klass if self.user_obj else None
                    ),
                )

                success = True
                self.data_loaded_at_least_once = True
                self.console.log(
                    "DataStore: Refresh successful.", style="success"
                )

            except Exception as e:
                self.console.print(
                    f"Error during DataStore refresh sequence: {e}",
                    style="error",
                )
                self.console.print_exception(show_locals=False)
                success = False

            finally:
                # Notify UI regardless of success/failure
                self.log("DataStore: Notifying UI for update.")
                self.app_notify_update()  # Call the callback

                end_time = time.monotonic()
                duration = end_time - start_time
                self.console.log(
                    f"DataStore: Refresh finished in {duration:.2f}s. Success: {success}",
                    style="info",
                )

        # Lock released automatically
        return success

    # & - def _handle_fetch_result(...) (Keep as before)
    def _handle_fetch_result(
        self, result: Any, name: str, default: Union[List, Dict]
    ) -> Union[List, Dict]:
        if isinstance(result, Exception):
            self.log(f"Error fetching {name}: {result}", style="warning")
            return default
        if not isinstance(result, type(default)):
            self.log(
                f"Unexpected type for {name}: {type(result)}. Using default.",
                style="warning",
            )
            return default
        return result

    # MARK: - Data Accessor Methods (Synchronous - Read current state)
    # These provide data to the UI. The UI should check if data is None (not loaded yet).

    # & - def get_user(self) -> Optional[User]: ...
    def get_user(self) -> Optional[User]:
        return self.user_obj

    # & - def get_user_stats(self) -> Optional[Dict[str, Any]]: ...
    def get_user_stats(self) -> Optional[Dict[str, Any]]:
        return self.user_stats_dict

    # & - def get_party(self) -> Optional[Party]: ...
    def get_party(self) -> Optional[Party]:
        return self.party_obj

    # & - def get_tags(self) -> List[Tag]: ...
    def get_tags(self) -> List[Tag]:
        return self.tags_list_obj.tags if self.tags_list_obj else []

    # & - def get_tasks(self, **filters) -> List[Task]: ...
    def get_tasks(self, **filters) -> List[Task]:
        if not self.tasks_list_obj:
            return []
        # Basic filtering example, expand in TaskList or here
        tasks = self.tasks_list_obj.tasks
        task_type = filters.get("task_type")
        if task_type:
            tasks = [t for t in tasks if t.type == task_type]
        # Add more filters based on kwargs...
        return tasks

    # & - def get_challenges(self, **filters) -> List[Challenge]: ...
    def get_challenges(self, **filters) -> List[Challenge]:
        if not self.challenges_list_obj:
            return []
        # Add filtering logic here or in ChallengeList
        return self.challenges_list_obj.challenges

    # & - def get_spells(self, **filters) -> List[Skill]: ...
    def get_spells(self, **filters) -> List[Skill]:
        if not self.spells_list_obj:
            return []
        # Add filtering logic here or in SpellList
        return self.spells_list_obj.spells

    # Add getters for specific data needed by UI components

    # MARK: - Action Methods (Asynchronous - Modify state via API)
    # These trigger API calls and then schedule a background refresh.

    # & - async def toggle_sleep(self) -> bool: ...
    async def toggle_sleep(self) -> bool:
        self.console.log("DataStore: Action - Toggle sleep...", style="info")
        try:
            result = await self.api_client.toggle_user_sleep()
            if result is not None:
                self.console.log(
                    "DataStore: Sleep toggle API successful.", style="success"
                )
                asyncio.create_task(self.refresh_all_data())  # Trigger refresh
                return True
            else:
                return False  # API call failed gracefully
        except HabiticaAPIError as e:
            self.console.print(
                f"DataStore: Error toggling sleep: {e}", style="error"
            )
            return False

    # & - async def score_task(self, task_id: str, direction: str) -> bool: ...
    async def score_task(self, task_id: str, direction: str) -> bool:
        self.console.log(
            f"DataStore: Action - Scoring task {task_id} {direction}...",
            style="info",
        )
        try:
            result = await self.api_client.score_task(task_id, direction)
            if result:
                self.console.log(
                    f"DataStore: Task {task_id} scored {direction}.",
                    style="success",
                )
                asyncio.create_task(self.refresh_all_data())  # Trigger refresh
                return True
            else:
                return False
        except HabiticaAPIError as e:
            self.console.print(
                f"DataStore: Error scoring task {task_id}: {e}", style="error"
            )
            return False

    # ... Add async methods for ALL other actions (delete task, update task, leave challenge, etc.)
    # Each should:
    # 1. Await the self.api_client call.
    # 2. On success, trigger asyncio.create_task(self.refresh_all_data()).
    # 3. Return True on success, False on failure.
    # 4. Catch HabiticaAPIError.

--- END OF FILE tui/data_store.py ---
--- START OF FILE tui/game_content.py ---

# pixabit/data_handler.py

# MARK: - MODULE DOCSTRING

"""Provides an asynchronous DataHandler class for fetching, caching, and extracting
specific data sections from API responses or cache files.
"""

# MARK: - IMPORTS

import json
import operator
import os
from functools import reduce
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

# Local Imports

# Use themed console for logging/errors if available

try:
from ..utils.display import console, print
except ImportError:
import builtins

    print = builtins.print

    class DummyConsole:
        def print(self, *args, **kwargs):
            builtins.print(*args)

        def log(self, *args, **kwargs):
            builtins.print("LOG:", *args)

        def print_exception(self, *args, **kwargs):
            import traceback

            traceback.print_exc()

    console = DummyConsole()
    print(
        "Warning: pixabit.utils.display not found, using basic print/log for DataHandler."
    )

# Assume save_json/load_json are adapted for Path objects and async isn't needed for file I/O

# If file I/O needs to be async, import run_in_thread from Textual or use aiofiles

# MARK: - Helper Function

# FUNC: - get_nested_item

def get_nested_item(data: dict[str, Any], keys: list[str]) -> Any | None:
"""Safely access nested dictionary items using a list of keys.""" # Ensure data is a dict before starting reduce
if not isinstance(data, dict):
return None
try:
return reduce(operator.getitem, keys, data)
except (KeyError, TypeError, IndexError): # Handle errors during traversal
return None

# KLASS: - DataHandler

class DataHandler:
"""Handles async fetching, caching (large raw response & small extracted sections),
and extraction of specific nested data sections using dot notation keys.
"""

    # FUNC: - __init__
    def __init__(
        self,
        fetch_func: Optional[
            callable
        ] = None,  # Async function to fetch raw data (e.g., api_client.get_content)
        api_url: Optional[
            str
        ] = None,  # OR Provide direct URL (fetch_func preferred)
        dict_keys_to_extract: list[
            str
        ] = [],  # Dot notation keys: ["gear.flat", "spells", "quests"]
        large_cache_filepath: Union[str, Path] = "cache/raw_api_data.json",
        extracted_cache_filepath: Union[
            str, Path
        ] = "cache/extracted_sections.json",
        # Optional: Pass httpx client instance for connection pooling?
    ):
        """Initializes the DataHandler. Requires either `fetch_func` or `api_url`.

        Args:
            fetch_func: An awaitable callable that returns the raw data dict (e.g., api_client method). Preferred.
            api_url: The URL to fetch raw data if `fetch_func` is not provided.
            dict_keys_to_extract: List of dot-notation paths to extract.
            large_cache_filepath: Path for caching the full raw API response.
            extracted_cache_filepath: Path for caching only the extracted sections.
        """
        if not fetch_func and not api_url:
            raise ValueError("Must provide either 'fetch_func' or 'api_url'.")
        if fetch_func and api_url:
            console.log(
                "Warning: Both 'fetch_func' and 'api_url' provided. 'fetch_func' will be used.",
                style="warning",
            )

        self.fetch_func = fetch_func
        self.api_url = api_url
        self.keys_to_extract = dict_keys_to_extract
        self.large_cache_path = Path(large_cache_filepath)
        self.extracted_cache_path = Path(extracted_cache_filepath)
        self.extracted_data: dict[str, Any] = (
            {}
        )  # Stores {key_specifier: extracted_dict}
        self._raw_data_loaded: bool = (
            False  # Flag to avoid re-fetching raw data unnecessarily
        )


    # FUNC: - load_or_fetch_data (async)
    async def load_or_fetch_data(self) -> bool:
        """
        Orchestrates loading/fetching data, prioritizing the extracted cache.

        Attempts to load extracted data. If unsuccessful, loads/fetches raw data,
        extracts required sections, and caches both raw and extracted data.

        Returns:
            bool: True if data was successfully loaded/fetched and extracted, False otherwise.
        """
        self.console.log(f"DataHandler: Initiating load/fetch for keys: {self.keys_to_extract}", style="info")

        # 1. Try loading extracted cache
        cached_extracted = load_json(self.extracted_cache_path)
        if isinstance(cached_extracted, dict) and all(key in cached_extracted for key in self.keys_to_extract):
            self.console.log(f"DataHandler: Loaded successfully from extracted cache: '{self.extracted_cache_path}'", style="success")        self.extracted_data = {}
            self.extracted_data = cached_extracted
            self._raw_data_loaded = True # Assume raw data was processed if extracted cache exists
            return True

        # 2. Extracted cache failed/missing/incomplete, need raw data
        self.console.log(f"DataHandler: Extracted cache miss/invalid. Need raw data.", style="info")
        raw_data = None
        # 2a. Try loading raw cache
        raw_data = load_json(self.large_cache_path)
        if isinstance(raw_data, dict) and raw_data:
             self.console.log(f"DataHandler: Loaded raw data from cache: '{self.large_cache_path}'", style="info")
        else:
            # 2b. Raw cache miss/invalid, fetch from API
            self.console.log(f"DataHandler: Raw cache miss/invalid. Fetching from source...", style="info")
            raw_data = await self._fetch_source_data()
            # 2c. Save fetched data to raw cache if successful
            if isinstance(raw_data, dict) and raw_data:
                 self.console.log(f"DataHandler: API fetch successful. Saving to raw cache '{self.large_cache_path}'...", style="info")
                 save_json(raw_data, self.large_cache_path) # Use sync save for simplicity here
            else:
                 self.console.log(f"DataHandler: Failed to load from cache AND fetch from source.", style="error")
                 self.extracted_data = {key: {} for key in self.keys_to_extract} # Init empty on failure
                 self._raw_data_loaded = True # Mark as attempted
                 return False # Failed to get raw data

      # 3. We have raw_data (from cache or API), extract sections
        self.extracted_data = self._extract_required_dicts(raw_data)
        self._raw_data_loaded = True

        # 4. Save extracted data to its cache (only if something was extracted)
        if self.extracted_data and any(self.extracted_data.values()):
             self.console.log(f"DataHandler: Saving extracted data to cache '{self.extracted_cache_path}'...", style="info")
             save_json(self.extracted_data, self.extracted_cache_path) # Sync save
        else:
             self.console.log("DataHandler: No valid data extracted. Extracted cache not saved.", style="warning")
             # Return False if extraction failed to get any requested keys? Or True because raw data was loaded?
             # Let's return True if raw data was loaded, even if extraction yielded nothing.
             # return False # If extraction failing means overall failure
        return True # Data loading/fetching process completed


    # FUNC: - _fetch_source_data (async)
    async def _fetch_source_data(self) -> Optional[dict[str, Any]]:
        """Fetches raw data using either the provided fetch_func or api_url."""
        if self.fetch_func and callable(self.fetch_func):
            # Use the provided async function (preferred)
            self.console.log(f"DataHandler: Calling provided async fetch_func...", style="subtle")
            try:
                # Assume fetch_func returns the dict/list payload or None
                data = await self.fetch_func()
                if isinstance(data, (dict, list)): # Allow list returns too? Assume dict for now.
                    return data if isinstance(data, dict) else {"_raw_list_data": data} # Wrap list if necessary
                self.console.log(f"DataHandler: fetch_func returned invalid type {type(data)}", style="warning")
                return None
            except Exception as e:
                self.console.log(f"DataHandler: Error calling fetch_func: {e}", style="error")
                return None
        elif self.api_url:
            # Fallback to using httpx directly with api_url
            self.console.log(f"DataHandler: Fetching directly from API URL: {self.api_url}", style="info")
            try:
                async with httpx.AsyncClient(timeout=60) as client: # Shorter timeout?
                    response = await client.get(self.api_url)
                    response.raise_for_status()
                    return response.json() # Assume API returns JSON dict
            except (httpx.RequestError, httpx.HTTPStatusError, json.JSONDecodeError) as e:
                self.console.log(f"DataHandler: API request failed for {self.api_url}: {e}", style="error")
                return None
        else:
            # Should not happen due to __init__ check, but safeguard
            self.console.log("DataHandler: No fetch_func or api_url configured.", style="error")
            return None

    # FUNC: - _extract_required_dicts
    def _extract_required_dicts(self, full_data: Optional[dict[str, Any]]) -> dict[str, Any]:
        """Extracts dictionaries based on keys_to_extract, handling dot notation."""
        extracted = {}
        if not isinstance(full_data, dict):
            self.console.log(f"Warning: Cannot extract from non-dict raw data (type: {type(full_data)}).", style="warning")
            return {key: {} for key in self.keys_to_extract} # Return empty dicts

        for key_specifier in self.keys_to_extract:
            path_parts = key_specifier.split(".")
            target_item = get_nested_item(full_data, path_parts)

            if target_item is not None and isinstance(target_item, dict):
                extracted[key_specifier] = target_item
                # self.console.log(f"Extracted section '{key_specifier}'", style="subtle")
            else:
                self.console.log(f"Warning: Key path '{key_specifier}' not found or not a dict in raw data.", style="warning")
                extracted[key_specifier] = {} # Assign empty dict if extraction fails

        return extracted

    # --- Public Accessors ---
    # FUNC: - get_extracted_data
    def get_extracted_data(self) -> dict[str, Any]:
        """Returns the dictionary containing all successfully extracted data sections."""
        # Consider triggering load_or_fetch here if not already loaded?
        # if not self._raw_data_loaded:
        #     asyncio.run(self.load_or_fetch_data()) # Requires careful handling in async context
        # Or ensure load_or_fetch_data is called before first access.
        if not self._raw_data_loaded:
             self.console.log("Warning: Attempting to get extracted data before loading/fetching.", style="warning")
        return self.extracted_data

    # FUNC: - get_section
    def get_section(self, key_specifier: str) -> Optional[dict[str, Any]]:
        """Returns a specific extracted dictionary section by its key specifier."""
        if not self._raw_data_loaded:
             self.console.log(f"Warning: Attempting to get section '{key_specifier}' before loading/fetching.", style="warning")
             # Optionally trigger load here, but might need async context
             # return None
        # Return the data from the extracted dict, defaulting to None if key missing
        return self.extracted_data.get(key_specifier)

--- END OF FILE tui/game_content.py ---
--- START OF FILE tui/pixabit.tcss ---
/_ pixabit/cli/pixabit.tcss - Basic Stylesheet _/

PixabitTUIApp {
layout: grid;
grid-rows: auto 1fr auto;
grid-columns: 2fr 3fr;
background: #191724; /_ Rosepine Dawn - base _/
color: #e0def4; /_ Rosepine Dawn - text _/
}

Header {
dock: top;
background: #1f1d2e; /_ Rosepine Dawn - panel _/
color: #31748f; /_ Rosepine Dawn - blue _/
height: 2;
content-align: center middle;
}

Footer {
dock: bottom;
background: #1f1d2e; /_ Rosepine Dawn - panel _/
color: #6e6a86; /_ Rosepine Dawn - muted _/
height: auto;
content-align: center middle;
}

Container
#main-content-area {
grid-size: 3 1;
layout: grid;
grid-columns: 1fr 2fr;
grid-rows: 1fr;
grid-gutter: 1;
padding: 1;
/_grid-rows: 1fr ;
grid-columns: 1fr 2fr;
padding: 1 2;
gap: 1; /_ Optional: Add a gap between grid areas if desired \*/
}

Vertical
#stats-panel {
background: #26233a; /_ Rosepine Dawn - surface _/
border: heavy #191724; /_ Rosepine Dawn - base _/
padding: 1 2;
margin-right: 1;
}

Vertical
#menu-panel {
background: #26233a; /_ Rosepine Dawn - surface _/
border: heavy #191724; /_ Rosepine Dawn - base _/
padding: 1 2;
margin-right: 1;
}

Vertical #content-panel {
background: #26233a; /_ Rosepine Dawn - surface _/
border: heavy #191724; /_ Rosepine Dawn - base _/
padding: 1 2;
/_ No margin here as it's the last column _/
}

Label {
padding: 0 1;
margin: 0;
width: auto;
height: auto;
/_ color: #e0def4; Inherits from PixabitTUIApp style _/
}

--- END OF FILE tui/pixabit.tcss ---
--- START OF FILE tui/task_processor.py ---

# pixabit/data_processor.py

# MARK: - MODULE DOCSTRING

"""Processes raw Habitica task data into specific data model objects (Task, Habit, etc.),
populates calculated fields (status, damage, tag names), and categorizes tasks.
Also includes the function to calculate aggregate user statistics.
"""

# MARK: - IMPORTS

import math

# Correct typing imports for Python 3.9+ (Generics require capitalized types)

from typing import Any, Dict, List, Optional, Type

# Local Imports

# Import the data models - CRUCIAL

try:
from .models.task import (
ChallengeData,
ChecklistItem,
Daily,
Habit,
Reward,
Task,
Todo,
)

    # from .models.tag import Tag # Import if needed later

except ImportError:
print(
"ERROR: Could not import task models in data_processor.py. Check paths."
)
Task = Habit = Daily = Todo = Reward = ChecklistItem = ChallengeData = (
dict # Fallback
)

# Import utilities

try:
from pixabit.utils.dates import (
convert_timestamp_to_utc,
convert_to_local_time,
is_date_passed,
)
from pixabit.utils.display import console, print

    from .game_content import GameContent  # Import the content manager class

except ImportError:
print(
"ERROR: Could not import utils or GameContent in data_processor.py. Check paths."
)
import builtins

    print = builtins.print

    class DummyConsole:
        def print(self, *args, **kwargs):
            builtins.print(*args)

        def log(self, *args, **kwargs):
            builtins.print("LOG:", *args)

        def print_exception(self, *args, **kwargs):
            import traceback

            traceback.print_exc()

    console = DummyConsole()

    class GameContent:  # Dummy
        def get_gear_data(self):
            return {}

        def get_skill_data(self):
            return {}

        def get_quest_data(self):
            return {}

        def get_all_content(self):
            return None

# MARK: - TaskProcessor Class

class TaskProcessor:
"""Processes raw task dictionaries into Task data model objects, adding
calculated fields like status, value color, and potential damage. Requires
pre-fetched context data for accurate calculations.
"""

    # Define the mapping for task type strings to class constructors
    _TASK_TYPE_MAP: Dict[str, Type[Task]] = {
        "habit": Habit,
        "daily": Daily,
        "todo": Todo,
        "reward": Reward,
    }

    # & - def __init__(...)
    def __init__(
        self,
        user_data: Dict[str, Any],
        party_data: Dict[str, Any],
        all_tags_list: List[Dict[str, Any]],  # Raw tag list for lookup
        game_content_manager: GameContent,  # Accept the manager instance
    ):
        """Initializes TaskProcessor with necessary context data.

        Args:
            user_data: Raw user data dict from API.
            party_data: Raw party data dict from API.
            all_tags_list: Raw list of tag dicts from API.
            game_content_manager: Instance of GameContent managing cached content.
        """
        self.console = console
        self.console.log("Initializing TaskProcessor...", style="info")

        # Validate critical context
        if not isinstance(user_data, dict) or not user_data:
            raise ValueError("TaskProcessor requires valid user_data.")
        if not isinstance(game_content_manager, GameContent):
            raise ValueError(
                "TaskProcessor requires a valid GameContent manager instance."
            )

        # Validate optional context types
        self.party_data = party_data if isinstance(party_data, dict) else {}
        self.all_tags_list = (
            all_tags_list if isinstance(all_tags_list, list) else []
        )

        # Store context needed for processing
        self.user_data = user_data
        self.gear_stats_lookup = (
            game_content_manager.get_gear_data()
        )  # Get data via manager
        self.tags_lookup = self._prepare_tags_lookup(self.all_tags_list)

        # Calculate and store context values needed internally
        self.user_con: float = 0.0
        self.user_stealth: int = 0
        self.is_sleeping: bool = False
        self.is_on_boss_quest: bool = False
        self.boss_str: float = 0.0
        self._calculate_user_context()  # Calculate based on stored raw data

        self.console.log("TaskProcessor Context Initialized.", style="info")

    # & - def _prepare_tags_lookup(...)
    def _prepare_tags_lookup(
        self, tags_list: List[Dict[str, Any]]
    ) -> Dict[str, str]:
        """Creates tag ID -> name lookup dict."""
        if not tags_list:
            return {}
        lookup = {
            tag["id"]: tag.get("name", f"Unnamed_{tag['id'][:6]}")
            for tag in tags_list
            if isinstance(tag, dict) and "id" in tag
        }
        # self.console.log(f"Prepared lookup for {len(lookup)} tags.", style="info")
        return lookup

    # & - def _calculate_user_context(self) -> None:
    def _calculate_user_context(self) -> None:
        """Calculates effective CON, stealth, sleep, quest status from instance data."""
        # self.console.log("Calculating user context...", style="info")
        try:
            stats = self.user_data.get("stats", {})
            level = stats.get("lvl", 0)
            user_class = stats.get("class")
            buffs = stats.get("buffs", {})
            equipped_gear = (
                self.user_data.get("items", {})
                .get("gear", {})
                .get("equipped", {})
            )

            level_bonus = min(50.0, math.floor(level / 2.0))
            alloc_con = float(stats.get("con", 0.0))
            buff_con = float(buffs.get("con", 0.0))
            gear_con, class_bonus_con = 0.0, 0.0

            if isinstance(equipped_gear, dict) and self.gear_stats_lookup:
                for key in equipped_gear.values():
                    if not key:
                        continue
                    item_stats = self.gear_stats_lookup.get(key)
                    if isinstance(item_stats, dict):
                        item_base_con = float(item_stats.get("con", 0.0))
                        gear_con += item_base_con
                        if item_stats.get("klass") == user_class:
                            class_bonus_con += item_base_con * 0.5

            self.user_con = (
                level_bonus + alloc_con + gear_con + class_bonus_con + buff_con
            )
            self.user_stealth = int(buffs.get("stealth", 0))
            self.is_sleeping = self.user_data.get("preferences", {}).get(
                "sleep", False
            )

            # Party / Quest Status
            quest = self.party_data.get("quest", {})
            if isinstance(quest, dict) and quest.get("active"):
                boss = quest.get("boss")
                if isinstance(boss, dict) and boss.get("str") is not None:
                    self.is_on_boss_quest = True
                    try:
                        self.boss_str = float(boss.get("str", 0.0))
                    except (ValueError, TypeError):
                        self.boss_str = 0.0
                else:
                    self.is_on_boss_quest = False
                    self.boss_str = 0.0
            else:
                self.is_on_boss_quest = False
                self.boss_str = 0.0

        except Exception as e:
            self.console.log(
                f"Error calculating user/party context: {e}", style="warning"
            )
            # Reset defaults on error
            self.user_con, self.user_stealth, self.is_sleeping = 0.0, 0, False
            self.is_on_boss_quest, self.boss_str = False, 0.0

    # & - def _value_color(...)
    def _value_color(self, value: Optional[float]) -> str:
        """Determines a semantic style name based on task value."""
        if value is None:
            return "neutral"
        if value > 15:
            return "rosewater"
        elif value > 8:
            return "flamingo"
        elif value > 1:
            return "peach"
        elif value >= 0:
            return "text"
        elif value > -9:
            return "lavender"
        elif value > -16:
            return "rp_iris"
        else:
            return "red"

    # & - def _calculate_checklist_done(...)
    def _calculate_checklist_done(
        self, checklist: List[ChecklistItem]
    ) -> float:
        """Calculates proportion (0.0-1.0) of checklist items done."""
        if not checklist or not isinstance(checklist, list):
            return 1.0
        try:
            # Access ChecklistItem objects directly
            completed = sum(1 for item in checklist if item.completed)
            total = len(checklist)
            return completed / total if total > 0 else 1.0
        except Exception as e:
            # Log error, use default
            self.console.log(
                f"Error calculating checklist progress: {e}", style="warning"
            )
            return 1.0

    # & - def _create_task_object(...)
    def _create_task_object(self, task_data: Dict[str, Any]) -> Optional[Task]:
        """Factory method to create the appropriate Task subclass instance."""
        task_type = task_data.get("type")
        task_class = self._TASK_TYPE_MAP.get(task_type) if task_type else None

        if task_class:
            try:
                return task_class(task_data)
            except Exception as e:
                self.console.log(
                    f"Error instantiating {task_type} task {task_data.get('id')}: {e}",
                    style="error",
                )
                return None
        # Handle unknown type
        self.console.log(
            f"Unknown task type '{task_type}' for task {task_data.get('id')}. Creating base Task.",
            style="warning",
        )
        try:
            base_task = Task(task_data)
            base_task.type = task_type  # Store original type
            return base_task
        except Exception as e:
            self.console.log(
                f"Error instantiating base Task for {task_data.get('id')}: {e}",
                style="error",
            )
            return None

    # & - def _process_and_calculate_task(...)
    def _process_and_calculate_task(self, task_instance: Task) -> None:
        """Performs post-instantiation processing on a Task object: status,
        value_color, tag names, and damage (for Dailies). Modifies the instance.
        """
        # 1. Tag Names Lookup
        task_instance.tag_names = [
            self.tags_lookup.get(tag_id, f"ID:{tag_id}")
            for tag_id in task_instance.tags
        ]

        # 2. Value Color
        task_instance.value_color = self._value_color(task_instance.value)

        # 3. Status Calculation & Damage (Type Specific)
        dmg_user, dmg_party = 0.0, 0.0

        if isinstance(task_instance, Daily):
            status = "grey"
            if task_instance.is_due:
                status = "success" if task_instance.completed else "due"
            task_instance._status = status

            # Calculate Damage if applicable
            if (
                task_instance.is_due
                and not task_instance.completed
                and not self.is_sleeping
                and self.user_stealth <= 0
            ):
                try:
                    task_value = task_instance.value  # Already float from model
                    checklist = (
                        task_instance.checklist
                    )  # List of ChecklistItem objects
                    priority_val = task_instance.priority  # Already float

                    v_min, v_max = -47.27, 21.27
                    clamped_value = max(v_min, min(task_value, v_max))
                    base_delta = abs(math.pow(0.9747, clamped_value))
                    checklist_mitigation = 1.0 - self._calculate_checklist_done(
                        checklist
                    )
                    effective_delta = base_delta * checklist_mitigation
                    con_mitigation = max(0.1, 1.0 - (self.user_con / 250.0))
                    prio_map = {0.1: 0.1, 1.0: 1.0, 1.5: 1.5, 2.0: 2.0}
                    priority_multiplier = prio_map.get(priority_val, 1.0)

                    hp_mod = (
                        effective_delta
                        * con_mitigation
                        * priority_multiplier
                        * 2.0
                    )
                    dmg_user = round(hp_mod, 1)

                    if self.is_on_boss_quest and self.boss_str > 0:
                        boss_delta = (
                            effective_delta * priority_multiplier
                            if priority_multiplier < 1.0
                            else effective_delta
                        )
                        dmg_party = round(boss_delta * self.boss_str, 1)
                except Exception as e_dmg:
                    self.console.log(
                        f"Error calculating damage for Daily {task_instance.id}: {e_dmg}",
                        style="error",
                    )
                    dmg_user, dmg_party = 0.0, 0.0

        elif isinstance(task_instance, Todo):
            status = "grey"
            if task_instance.completed:
                status = "done"
            elif task_instance.due_date:
                status = "red" if task_instance.is_past_due else "due"
            task_instance._status = status

        elif isinstance(task_instance, Habit):
            task_instance._status = "habit"
        elif isinstance(task_instance, Reward):
            task_instance._status = "reward"
        else:
            task_instance._status = "unknown"  # For base Task

        # 4. Assign Calculated Damage
        task_instance.damage_user = dmg_user if dmg_user > 0 else None
        task_instance.damage_party = dmg_party if dmg_party > 0 else None

        # 5. Emoji processing is done in Task model __init__ now.

    # & - def process_and_categorize_all(...)
    def process_and_categorize_all(
        self, raw_task_list: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """Processes a list of raw task data into Task objects and categorizes them.

        Args:
            raw_task_list: The list of raw task dictionaries from the API.

        Returns:
            Dict containing 'data' (dict of Task objects) and 'cats' (categorized IDs).
        """
        tasks_dict: Dict[str, Task] = {}
        cats_dict: Dict[str, Any] = {
            "tasks": {
                "habits": [],
                "todos": {
                    "due": [],
                    "grey": [],
                    "red": [],
                    "done": [],
                },  # Added done
                "dailys": {"success": [], "due": [], "grey": []},
                "rewards": [],
            },
            "tags": set(),
            "broken": [],
            "challenge": set(),
        }

        if not isinstance(raw_task_list, list):
            self.console.print(
                "Invalid raw_task_list provided to processor.", style="error"
            )
            return {"data": {}, "cats": cats_dict}

        # self.console.print(f"Processing {len(raw_task_list)} raw tasks into objects...", style="info")
        for task_data in raw_task_list:
            if not isinstance(task_data, dict):
                continue

            task_instance = self._create_task_object(task_data)
            if not task_instance or not task_instance.id:
                continue

            # Perform calculations and update the instance
            self._process_and_calculate_task(task_instance)

            # Store processed object
            tasks_dict[task_instance.id] = task_instance

            # Categorization
            cats_dict["tags"].update(task_instance.tags)
            if task_instance.challenge and task_instance.challenge.is_broken:
                cats_dict["broken"].append(task_instance.id)
            if task_instance.challenge_id:
                cats_dict["challenge"].add(task_instance.challenge_id)

            task_type = task_instance.type
            status = task_instance._status  # Use calculated status

            # Ensure the category exists before appending
            if task_type == "habit":
                cats_dict["tasks"]["habits"].append(task_instance.id)
            elif task_type == "reward":
                cats_dict["tasks"]["rewards"].append(task_instance.id)
            elif task_type == "todo":
                cats_dict["tasks"]["todos"].setdefault(status, []).append(
                    task_instance.id
                )
            elif task_type == "daily":
                cats_dict["tasks"]["dailys"].setdefault(status, []).append(
                    task_instance.id
                )
            # else: ignore unknown types, already logged

        # Finalize categories
        cats_dict["tags"] = sorted(list(cats_dict["tags"]))
        cats_dict["challenge"] = sorted(list(cats_dict["challenge"]))

        # self.console.print("Task processing and categorization complete.", style="success")
        return {"data": tasks_dict, "cats": cats_dict}

# MARK: - User Stats Function

# & - def get_user_stats(...)

def get_user_stats(
cats_dict: Dict[str, Any],
processed_tasks_dict: Dict[str, Task], # Expects Task objects
user_data: Dict[str, Any], # Expects raw user data dict
) -> Optional[Dict[str, Any]]:
"""Generates user statistics dict using categorized tasks and raw user data.

    Args:
        cats_dict: The 'cats' dictionary from TaskProcessor.
        processed_tasks_dict: The 'data' dictionary from TaskProcessor (Task objects).
        user_data: The raw user data dictionary from the API.

    Returns:
        A dictionary containing combined user/task statistics, or None on failure.
    """
    # console.print("Calculating user stats from processed data...", style="info")
    if not isinstance(user_data, dict) or not user_data:
        console.print(
            "Cannot calculate stats: Valid user_data required.", style="error"
        )
        return None
    if not isinstance(cats_dict, dict):
        console.print(
            "Cannot calculate stats: Valid cats_dict required.", style="error"
        )
        return None
    if not isinstance(processed_tasks_dict, dict):
        console.print(
            "Cannot calculate stats: Valid processed_tasks_dict required.",
            style="error",
        )
        return None

    try:
        # --- Extract from User Data ---
        stats = user_data.get("stats", {})
        party = user_data.get("party", {})
        prefs = user_data.get("preferences", {})
        auth = user_data.get("auth", {})
        ts = auth.get("timestamps", {})
        local_auth = auth.get("local", {})
        balance = user_data.get("balance", 0.0)
        gems = int(balance * 4) if balance > 0 else 0
        u_class_raw = stats.get("class", "warrior")
        u_class = "mage" if u_class_raw == "wizard" else u_class_raw
        last_login_utc = ts.get("loggedin")
        last_login_local = "N/A"
        if last_login_utc:
            local_dt = convert_to_local_time(
                last_login_utc
            )  # Use improved function
            if local_dt:
                last_login_local = local_dt.isoformat(
                    sep=" ", timespec="minutes"
                )
            else:
                last_login_local = (
                    f"Error ({last_login_utc})"  # Fallback on conversion error
                )
        quest = party.get("quest", {})

        # --- Calculate Task Counts ---
        task_counts: Dict[str, Any] = {}
        task_cats_data = cats_dict.get("tasks", {})
        if isinstance(task_cats_data, dict):
            for category, cat_data in task_cats_data.items():
                if category not in ["habits", "dailys", "todos", "rewards"]:
                    continue  # Skip unknown categories
                if isinstance(cat_data, dict):  # dailys/todos
                    # Ensure all expected status keys exist, default to 0
                    status_keys = [
                        "due",
                        "grey",
                        "red",
                        "done",
                        "success",
                    ]  # Include all possible keys
                    status_counts = {k: 0 for k in status_keys}
                    total_in_cat = 0
                    for status, id_list in cat_data.items():
                        if isinstance(id_list, list):
                            count = len(id_list)
                            status_counts[status] = (
                                count  # Overwrite default 0 if status exists
                            )
                            total_in_cat += count
                    task_counts[category] = status_counts
                    task_counts[category]["_total"] = total_in_cat
                elif isinstance(cat_data, list):  # habits/rewards
                    task_counts[category] = len(cat_data)
        else:
            console.print(
                "Invalid 'tasks' structure in cats_dict.", style="warning"
            )

        # --- Calculate Total Damage (Sums pre-calculated values) ---
        dmg_user, dmg_party = 0.0, 0.0
        # Check if 'dailys' and 'due' exist before accessing
        due_daily_ids = (
            cats_dict.get("tasks", {}).get("dailys", {}).get("due", [])
        )
        for task_id in due_daily_ids:
            task_obj = processed_tasks_dict.get(task_id)
            if isinstance(task_obj, Daily):  # Check type again for safety
                dmg_user += task_obj.damage_user or 0.0
                dmg_party += task_obj.damage_party or 0.0

        # --- Assemble Output Dict ---
        output_stats = {
            "username": local_auth.get("username", "N/A"),
            "class": u_class,
            "level": stats.get("lvl", 0),
            "hp": float(stats.get("hp", 0.0)),
            "maxHealth": stats.get("maxHealth", 50),
            "mp": float(stats.get("mp", 0.0)),
            "maxMP": stats.get("maxMP", 0),
            "exp": float(stats.get("exp", 0.0)),
            "toNextLevel": stats.get("toNextLevel", 0),
            "gp": float(stats.get("gp", 0.0)),
            "gems": gems,
            "stats": {
                "str": stats.get("str", 0),
                "int": stats.get("int", 0),
                "con": stats.get("con", 0),
                "per": stats.get("per", 0),
            },
            "sleeping": prefs.get("sleep", False),
            "day_start": prefs.get("dayStart", 0),
            "last_login_local": last_login_local,  # Use the formatted string
            "quest_active": quest.get("active", False),
            "quest_key": quest.get("key"),
            "task_counts": task_counts,
            "broken_challenge_tasks": len(cats_dict.get("broken", [])),
            "joined_challenges_count": len(cats_dict.get("challenge", [])),
            "tags_in_use_count": len(cats_dict.get("tags", [])),
            "potential_daily_damage_user": round(dmg_user, 2),
            "potential_daily_damage_party": round(dmg_party, 2),
        }
        # console.print("User stats calculation complete.", style="success")
        return output_stats

    except Exception as e_stat:
        console.print(f"Error calculating user stats: {e_stat}", style="error")
        console.print_exception(show_locals=False)
        return None  # Return None on failure

--- END OF FILE tui/task_processor.py ---

--- START OF FILE cli/api.py ---

# pixabit/api.py

# MARK: - MODULE DOCSTRING

"""Provides HabiticaAPI client for interacting with the Habitica API v3.

Handles authentication, rate limiting, standard HTTP methods, and provides
convenience methods for common API endpoints (user, tasks, tags, challenges, etc.).
"""

# MARK: - IMPORTS

import time
from typing import Any, Optional, Union

import requests

# Keep requests import for exception types

from pixabit.cli import config

# For credentials

from pixabit.utils.display import console

# MARK: - CONSTANTS

DEFAULT_BASE_URL = "https://habitica.com/api/v3"
REQUESTS_PER_MINUTE = 29

# Stay under 30/min limit

MIN_REQUEST_INTERVAL = 60.0 / REQUESTS_PER_MINUTE

# ~2.07 seconds

HabiticaApiResponse = Optional[Union[dict[str, Any], list[dict[str, Any]]]]

# Type hint for common API response data structures

# Can be a dict (e.g., /user), a list of dicts (e.g., /tasks/user),

# or potentially None if the API returns no content (204) or on error.

# MARK: - HabiticaAPI Class

class HabiticaAPI:
"""Client class for Habitica API v3 interactions. Handles auth, rate limits, requests.

    Attributes:
        user_id (str): Habitica User ID.
        api_token (str): Habitica API Token.
        base_url (str): Base URL for the API.
        headers (dict[str, str]): Standard request headers including auth.
        request_interval (float): Min seconds between requests for rate limiting.
        last_request_time (float): Timestamp of the last request (monotonic).
    """

    BASE_URL = DEFAULT_BASE_URL

    # & - def __init__(...)
    def __init__(
        self,
        user_id: Optional[str] = None,
        api_token: Optional[str] = None,
        base_url: str = DEFAULT_BASE_URL,
    ):
        """Initializes the HabiticaAPI client.

        Loads credentials from config if not provided. Sets up headers and rate limiting.

        Args:
            user_id: Habitica User ID. Defaults to config.HABITICA_USER_ID.
            api_token: Habitica API Token. Defaults to config.HABITICA_API_TOKEN.
            base_url: API base URL.

        Raises:
            ValueError: If User ID or API Token is missing after checking args/config.
        """
        # Use credentials from config (which should have validated them)
        self.user_id = user_id or config.HABITICA_USER_ID
        self.api_token = api_token or config.HABITICA_API_TOKEN
        self.base_url = base_url

        # This check might be redundant if config.py exits on missing creds, but good safety.
        if not self.user_id or not self.api_token:
            raise ValueError(
                "Habitica User ID and API Token are required. "
                "Check .env file or provide directly."
            )

        self.headers = {
            "x-api-user": self.user_id,
            "x-api-key": self.api_token,
            "Content-Type": "application/json",
            "x-client": "pixabit-cli-your_identifier",
            # Optional: Identify your client
        }

        # Rate limiting attributes
        self.last_request_time: float = 0.0
        self.request_interval: float = MIN_REQUEST_INTERVAL

    # MARK: - Internal Methods

    # --------------------------------------------------------------------------

    # & - def _wait_for_rate_limit(self) -> None:
    def _wait_for_rate_limit(self) -> None:
        """Sleeps if necessary to comply with the rate limit based on monotonic time."""
        current_time = time.monotonic()
        time_since_last = current_time - self.last_request_time

        if time_since_last < self.request_interval:
            wait_time = self.request_interval - time_since_last

            # console.log(f"Rate limit: waiting {wait_time:.2f}s", style="subtle")
            # Optional debug
            time.sleep(wait_time)

        # Update time *after* potential sleep
        self.last_request_time = time.monotonic()

    # & - def _request(self, method: str, endpoint: str, **kwargs: Any) -> HabiticaApiResponse:
    def _request(
        self, method: str, endpoint: str, **kwargs: Any
    ) -> HabiticaApiResponse:
        """Internal method for making API requests with rate limiting and error handling.

        Args:
            method: HTTP method ('GET', 'POST', 'PUT', 'DELETE').
            endpoint: API endpoint path (e.g., '/user').
            **kwargs: Additional arguments for `requests.request` (e.g., json, params).

        Returns:
            The JSON response data (dict or list) from the API's 'data' field if present
            and successful, the raw JSON if no standard wrapper is used but successful,
            or None for 204 No Content or errors.

        Raises:
            requests.exceptions.RequestException: For network or API errors after logging.
        """
        self._wait_for_rate_limit()
        url = f"{self.base_url.rstrip('/')}/{endpoint.lstrip('/')}"
        response: Optional[requests.Response] = None

        # console.log(f"Request: {method} {url} | Kwargs: {kwargs}", style="subtle")
        # Debug

        try:
            kwargs.setdefault("timeout", 120)
            # Generous timeout
            response = requests.request(
                method, url, headers=self.headers, **kwargs
            )

            # console.log(f"Response Status: {response.status_code}", style="subtle")
            # Debug

            response.raise_for_status()
            # Raise HTTPError for 4xx/5xx

            # Handle successful 204 No Content
            if response.status_code == 204 or not response.content:

                # console.log(f"Response: No content (Status {response.status_code})", style="subtle")
                # Debug
                return None
            # Explicitly return None for No Content

            # Attempt to parse JSON for other 2xx responses
            response_data = response.json()

            # --- Handle Habitica's standard wrapper ---
            if isinstance(response_data, dict) and "success" in response_data:
                if response_data["success"]:

                    # Return the 'data' payload if success is true

                    # Use .get to handle cases where 'data' might be missing even on success
                    return response_data.get("data")
                else:

                    # API reported failure
                    error_type = response_data.get(
                        "error", "Unknown Habitica Error"
                    )
                    message = response_data.get(
                        "message", "No message provided."
                    )
                    err_msg = f"Habitica API Error ({response.status_code}): {error_type} - {message}"
                    console.print(err_msg, style="error")

                    # Raise a general RequestException after logging
                    raise requests.exceptions.RequestException(err_msg)
            else:

                # --- Handle successful responses WITHOUT the standard wrapper ---

                # E.g., /content endpoint or potentially others

                # console.log(f"Response for {method} {endpoint} OK, but no standard wrapper. Returning raw JSON.", style="info")

                # Basic validation: ensure it's a dict or list as expected from most endpoints
                if isinstance(response_data, (dict, list)):
                    return response_data
                else:

                    # This case is unlikely for a successful JSON response but possible
                    console.print(
                        f"Warning: Unexpected non-dict/list JSON from {method} {endpoint}: {type(response_data)}",
                        style="warning",
                    )

                    # Decide how to handle: return the data anyway, or raise an error?

                    # Raising ValueError seems appropriate as it violates expected structure.
                    raise ValueError(
                        "Unexpected JSON structure received from API."
                    )

        # --- Exception Handling ---
        except requests.exceptions.HTTPError as http_err:

            # Log detailed HTTP error information
            error_details = f"HTTP Error: {http_err}"
            if http_err.response is not None:
                response = http_err.response
                # Use the response from the exception
                error_details += f" | Status Code: {response.status_code}"
                try:

                    # Try to get more specific error details from Habitica's JSON response body
                    err_data = response.json()
                    error_type = err_data.get("error", "N/A")
                    message = err_data.get("message", "N/A")
                    error_details += (
                        f" | API Error: '{error_type}' | Message: '{message}'"
                    )
                except requests.exceptions.JSONDecodeError:

                    # If response body is not JSON
                    error_details += (
                        f" | Response Body (non-JSON): {response.text[:200]}"
                        # Limit length
                    )
            console.print(f"Request Failed: {error_details}", style="error")

            # Re-raise as a RequestException for consistent handling upstream
            raise requests.exceptions.RequestException(
                error_details
            ) from http_err

        except requests.exceptions.Timeout as timeout_err:
            msg = f"Request timed out ({kwargs.get('timeout')}s) for {method} {endpoint}"
            console.print(f"{msg}: {timeout_err}", style="error")
            raise requests.exceptions.RequestException(msg) from timeout_err

        except requests.exceptions.JSONDecodeError as json_err:

            # Successful status code (2xx) but invalid JSON body
            msg = f"Could not decode JSON response from {method} {endpoint}"
            status = response.status_code if response is not None else "N/A"
            body = response.text[:200] if response is not None else "N/A"
            console.print(f"{msg}", style="error")
            console.print(
                f"Response Status: {status}, Body starts with: {body}",
                style="subtle",
            )

            # Raise ValueError as the JSON structure is invalid
            raise ValueError(
                f"Invalid JSON received from {method} {endpoint}"
            ) from json_err

        except requests.exceptions.RequestException as req_err:

            # Catch other requests errors (connection, DNS, etc.)
            msg = f"Network/Request Error for {method} {endpoint}"
            console.print(f"{msg}: {req_err}", style="error")
            raise
        # Re-raise the original exception

        except Exception as e:
            # Catch any other unexpected errors
            console.print(
                f"Unexpected error during API request: {type(e).__name__} - {e}",
                style="error",
            )
            console.print_exception(show_locals=False)
            # Show traceback for unexpected errors
            raise

    # Re-raise

    # MARK: - Core HTTP Request Methods

    # --------------------------------------------------------------------------

    # & - def get(self, endpoint: str, params: Optional[dict[str, Any]] = None) -> HabiticaApiResponse:
    def get(
        self, endpoint: str, params: Optional[dict[str, Any]] = None
    ) -> HabiticaApiResponse:
        """Sends GET request. Returns JSON data or None."""
        return self._request("GET", endpoint, params=params)

    # & - def post(self, endpoint: str, data: Optional[dict[str, Any]] = None) -> HabiticaApiResponse:
    def post(
        self, endpoint: str, data: Optional[dict[str, Any]] = None
    ) -> HabiticaApiResponse:
        """Sends POST request with JSON data. Returns JSON data or None."""
        return self._request("POST", endpoint, json=data)

    # & - def put(self, endpoint: str, data: Optional[dict[str, Any]] = None) -> HabiticaApiResponse:
    def put(
        self, endpoint: str, data: Optional[dict[str, Any]] = None
    ) -> HabiticaApiResponse:
        """Sends PUT request with JSON data. Returns JSON data or None."""
        return self._request("PUT", endpoint, json=data)

    # & - def delete(self, endpoint: str, params: Optional[dict[str, Any]] = None) -> HabiticaApiResponse:
    def delete(
        self, endpoint: str, params: Optional[dict[str, Any]] = None
    ) -> HabiticaApiResponse:
        """Sends DELETE request. Returns JSON data (often empty dict) or None."""
        # DELETE requests might have query params sometimes (though less common)
        return self._request("DELETE", endpoint, params=params)

    # MARK: - Convenience Methods (User)

    # --------------------------------------------------------------------------

    # & - def get_user_data(self) -> Optional[dict[str, Any]]:
    def get_user_data(self) -> Optional[dict[str, Any]]:
        """GET /user - Retrieves the full user object."""
        result = self.get("/user")

        # Ensure the returned data (from 'data' field) is actually a dict
        return result if isinstance(result, dict) else None

    # & - def update_user(self, update_data: dict[str, Any]) -> Optional[dict[str, Any]]:
    def update_user(
        self, update_data: dict[str, Any]
    ) -> Optional[dict[str, Any]]:
        """PUT /user - Updates general user settings."""
        result = self.put("/user", data=update_data)
        return result if isinstance(result, dict) else None

    # & - def set_custom_day_start(self, hour: int) -> Optional[dict[str, Any]]:
    def set_custom_day_start(self, hour: int) -> Optional[dict[str, Any]]:
        """Sets user's custom day start hour (0-23). Uses PUT /user."""
        if not 0 <= hour <= 23:
            raise ValueError("Hour must be between 0 and 23")
        return self.update_user({"preferences.dayStart": hour})

    # & - def toggle_user_sleep(self) -> Optional[dict[str, Any]]:
    def toggle_user_sleep(self) -> Optional[dict[str, Any]]:
        """POST /user/sleep - Toggles user's sleep status."""
        # API returns { "data": <boolean> } on V3, but let's handle dict return just in case
        result = self.post("/user/sleep")

        # The _request method extracts the 'data' field.

        # If 'data' is a boolean, wrap it for consistency, otherwise return dict if present.
        if isinstance(result, bool):
            return {"sleep": result}
        elif isinstance(result, dict):
            return result
        # Return dict if API returns more info
        return None

    # Return None on error or unexpected type

    # MARK: - Convenience Methods (Tasks)

    # --------------------------------------------------------------------------

    # & - def get_tasks(self, task_type: Optional[str] = None) -> list[dict[str, Any]]:
    def get_tasks(
        self, task_type: Optional[str] = None
    ) -> list[dict[str, Any]]:
        """GET /tasks/user - Gets user tasks, optionally filtered by type."""
        params = {"type": task_type} if task_type else None
        result = self.get("/tasks/user", params=params)

        # Ensure the result is a list, return empty list otherwise
        return result if isinstance(result, list) else []

    # & - def create_task(self, data: dict[str, Any]) -> Optional[dict[str, Any]]:
    def create_task(self, data: dict[str, Any]) -> Optional[dict[str, Any]]:
        """POST /tasks/user - Creates a new task."""
        if "text" not in data or "type" not in data:
            raise ValueError(
                "Task creation data must include 'text' and 'type'."
            )
        result = self.post("/tasks/user", data=data)
        return result if isinstance(result, dict) else None

    # & - def update_task(self, task_id: str, data: dict[str, Any]) -> Optional[dict[str, Any]]:
    def update_task(
        self, task_id: str, data: dict[str, Any]
    ) -> Optional[dict[str, Any]]:
        """PUT /tasks/{taskId} - Updates an existing task."""
        result = self.put(f"/tasks/{task_id}", data=data)
        return result if isinstance(result, dict) else None

    # & - def delete_task(self, task_id: str) -> Optional[dict[str, Any]]:
    def delete_task(self, task_id: str) -> Optional[dict[str, Any]]:
        """DELETE /tasks/{taskId} - Deletes a specific task."""
        result = self.delete(f"/tasks/{task_id}")

        # API might return empty dict or None on success
        return result if isinstance(result, dict) else None

    # & - def score_task(self, task_id: str, direction: str = "up") -> Optional[dict[str, Any]]:
    def score_task(
        self, task_id: str, direction: str = "up"
    ) -> Optional[dict[str, Any]]:
        """POST /tasks/{taskId}/score/{direction} - Scores a task ('clicks' it)."""
        if direction not in ["up", "down"]:
            raise ValueError("Direction must be 'up' or 'down'")
        result = self.post(f"/tasks/{task_id}/score/{direction}")
        return result if isinstance(result, dict) else None

    # & - def set_attribute(self, task_id: str, attribute: str) -> Optional[dict[str, Any]]:
    def set_attribute(
        self, task_id: str, attribute: str
    ) -> Optional[dict[str, Any]]:
        """Sets the primary attribute for a task. Uses `update_task`."""
        if attribute not in ["str", "int", "con", "per"]:
            raise ValueError(
                "Attribute must be one of 'str', 'int', 'con', 'per'"
            )
        return self.update_task(task_id, {"attribute": attribute})

    # & - def move_task_to_position(self, task_id: str, position: int) -> Optional[list[dict[str, Any]]]:
    def move_task_to_position(
        self, task_id: str, position: int
    ) -> Optional[list[dict[str, Any]]]:
        """Moves a task to a specific position (0=top, -1=bottom).
        POST /tasks/{taskId}/move/to/{position}
        """
        if position not in [0, -1]:

            # Corrected validation based on V3 API docs
            raise ValueError(
                "Position must be 0 (to move to top) or -1 (to move to bottom)."
            )

        # API returns the new sorted list of task IDs (not full task objects)
        result = self.post(f"/tasks/{task_id}/move/to/{position}")

        # The API response structure for move/to is often just the sorted list of IDs, not wrapped.
        return result if isinstance(result, list) else None

    # MARK: - Convenience Methods (Tags)

    # --------------------------------------------------------------------------

    # & - def get_tags(self) -> list[dict[str, Any]]:
    def get_tags(self) -> list[dict[str, Any]]:
        """GET /tags - Gets all user tags."""
        result = self.get("/tags")
        return result if isinstance(result, list) else []

    # & - def create_tag(self, name: str) -> Optional[dict[str, Any]]:
    def create_tag(self, name: str) -> Optional[dict[str, Any]]:
        """POST /tags - Creates a new tag."""
        result = self.post("/tags", data={"name": name})
        return result if isinstance(result, dict) else None

    # & - def update_tag(self, tag_id: str, name: str) -> Optional[dict[str, Any]]:
    def update_tag(self, tag_id: str, name: str) -> Optional[dict[str, Any]]:
        """PUT /tags/{tagId} - Updates an existing tag's name."""
        result = self.put(f"/tags/{tag_id}", data={"name": name})
        return result if isinstance(result, dict) else None

    # & - def delete_tag(self, tag_id: str) -> Optional[dict[str, Any]]:
    def delete_tag(self, tag_id: str) -> Optional[dict[str, Any]]:
        """DELETE /tags/{tagId} - Deletes an existing tag globally."""
        result = self.delete(f"/tags/{tag_id}")

        # Often returns None or empty dict on success
        return result if isinstance(result, dict) else None

    # & - def add_tag_to_task(self, task_id: str, tag_id: str) -> Optional[dict[str, Any]]:
    def add_tag_to_task(
        self, task_id: str, tag_id: str
    ) -> Optional[dict[str, Any]]:
        """POST /tasks/{taskId}/tags/{tagId} - Associates a tag with a task."""
        # This endpoint might return the updated task or just success status
        result = self.post(f"/tasks/{task_id}/tags/{tag_id}")

        # V3 API likely just returns {success: true} without data, _request handles this.

        # If it returns the task, it would be a dict.
        return result if isinstance(result, dict) else None

    # Return dict if present, else None

    # & - def delete_tag_from_task(self, task_id: str, tag_id: str) -> Optional[dict[str, Any]]:
    def delete_tag_from_task(
        self, task_id: str, tag_id: str
    ) -> Optional[dict[str, Any]]:
        """DELETE /tasks/{taskId}/tags/{tagId} - Removes tag association from task."""
        result = self.delete(f"/tasks/{task_id}/tags/{tag_id}")
        return result if isinstance(result, dict) else None

    # MARK: - Convenience Methods (Checklist)

    # --------------------------------------------------------------------------

    # & - def add_checklist_item(self, task_id: str, text: str) -> Optional[dict[str, Any]]:
    def add_checklist_item(
        self, task_id: str, text: str
    ) -> Optional[dict[str, Any]]:
        """POST /tasks/{taskId}/checklist - Adds checklist item."""
        result = self.post(f"/tasks/{task_id}/checklist", data={"text": text})
        return result if isinstance(result, dict) else None

    # Returns updated task

    # & - def update_checklist_item(self, task_id: str, item_id: str, text: str) -> Optional[dict[str, Any]]:
    def update_checklist_item(
        self, task_id: str, item_id: str, text: str
    ) -> Optional[dict[str, Any]]:
        """PUT /tasks/{taskId}/checklist/{itemId} - Updates checklist item text."""
        result = self.put(
            f"/tasks/{task_id}/checklist/{item_id}", data={"text": text}
        )
        return result if isinstance(result, dict) else None

    # Returns updated task

    # & - def delete_checklist_item(self, task_id: str, item_id: str) -> Optional[dict[str, Any]]:
    def delete_checklist_item(
        self, task_id: str, item_id: str
    ) -> Optional[dict[str, Any]]:
        """DELETE /tasks/{taskId}/checklist/{itemId} - Deletes checklist item."""
        result = self.delete(f"/tasks/{task_id}/checklist/{item_id}")
        return result if isinstance(result, dict) else None

    # Returns updated task

    # & - def score_checklist_item(self, task_id: str, item_id: str) -> Optional[dict[str, Any]]:
    def score_checklist_item(
        self, task_id: str, item_id: str
    ) -> Optional[dict[str, Any]]:
        """POST /tasks/{taskId}/checklist/{itemId}/score - Toggles checklist item completion."""
        result = self.post(f"/tasks/{task_id}/checklist/{item_id}/score")
        return result if isinstance(result, dict) else None

    # Returns updated task

    # MARK: - Convenience Methods (Challenges)

    # --------------------------------------------------------------------------

    # & - def get_challenges(self, member_only: bool = True) -> list[dict[str, Any]]:
    def get_challenges(self, member_only: bool = True) -> list[dict[str, Any]]:
        """GET /challenges/user - Retrieves challenges (owned or joined), handles pagination."""
        all_challenges = []
        page = 0
        member_param = "true" if member_only else "false"
        console.log(
            f"Fetching challenges (member_only={member_only}, paginating)...",
            style="info",
        )
        while True:
            try:

                # Use params argument for GET request
                challenge_page_data = self.get(
                    "/challenges/user",
                    params={"member": member_param, "page": page},
                )
                if isinstance(challenge_page_data, list):
                    if not challenge_page_data:
                        # Empty list means no more pages
                        break
                    all_challenges.extend(challenge_page_data)

                    # console.log(f"  Fetched page {page} ({len(challenge_page_data)} challenges)", style="subtle")
                    page += 1
                else:

                    # Should not happen with this endpoint if API is consistent
                    console.print(
                        f"Warning: Expected list from /challenges/user page {page}, got {type(challenge_page_data)}. Stopping pagination.",
                        style="warning",
                    )
                    break
            except (requests.exceptions.RequestException, ValueError) as e:
                console.print(
                    f"Error fetching challenges page {page}: {e}. Stopping pagination.",
                    style="error",
                )
                break
        # Stop pagination on error
        console.log(
            f"Finished fetching challenges. Total found: {len(all_challenges)}",
            style="info",
        )
        return all_challenges

    # & - def create_challenge(self, data: dict[str, Any]) -> Optional[dict[str, Any]]:
    def create_challenge(
        self, data: dict[str, Any]
    ) -> Optional[dict[str, Any]]:
        """POST /challenges - Creates a new challenge."""
        result = self.post("/challenges", data=data)
        return result if isinstance(result, dict) else None

    # & - def get_challenge_tasks(self, challenge_id: str) -> list[dict[str, Any]]:
    def get_challenge_tasks(self, challenge_id: str) -> list[dict[str, Any]]:
        """GET /tasks/challenge/{challengeId} - Retrieves tasks for a challenge."""
        result = self.get(f"/tasks/challenge/{challenge_id}")
        return result if isinstance(result, list) else []

    # & - def unlink_task_from_challenge(self, task_id: str, keep: str = "keep") -> Optional[dict[str, Any]]:
    def unlink_task_from_challenge(
        self, task_id: str, keep: str = "keep"
    ) -> Optional[dict[str, Any]]:
        """POST /tasks/{taskId}/unlink - Unlinks a single task from its challenge.
        Note: V3 API uses /tasks/{taskId}/unlink?keep={keep_option}
        """
        if keep not in ["keep", "remove"]:
            raise ValueError("keep must be 'keep' or 'remove'")

        # Endpoint path is just /unlink, keep option is a query parameter
        result = self.post(f"/tasks/unlink-one/{task_id}?keep={keep}")

        # API often returns None or {} on success for unlink actions
        return result if isinstance(result, dict) else None

    # & - def unlink_all_challenge_tasks(self, challenge_id: str, keep: str = "keep-all") -> Optional[dict[str, Any]]:
    def unlink_all_challenge_tasks(
        self, challenge_id: str, keep: str = "keep-all"
    ) -> Optional[dict[str, Any]]:
        """POST /tasks/unlink-all/{challengeId} - Unlinks ALL tasks from a challenge.
        Note: V3 API uses /tasks/unlink-all/{challengeId}?keep={keep_option}
        """
        if keep not in ["keep-all", "remove-all"]:
            raise ValueError("keep must be 'keep-all' or 'remove-all'")

        # Pass 'keep' as a query parameter
        result = self.post(f"/tasks/unlink-all/{challenge_id}?keep={keep}")
        return result if isinstance(result, dict) else None

    # & - def leave_challenge(self, challenge_id: str, keep: str = "keep-all") -> Optional[dict[str, Any]]:
    def leave_challenge(
        self, challenge_id: str, keep: str = "keep-all"
    ) -> Optional[dict[str, Any]]:
        """POST /challenges/{challengeId}/leave - Leaves a challenge, handling tasks.
        Note: V3 API uses /challenges/{challengeId}/leave?keep={keep_option}
        """
        if keep not in ["keep-all", "remove-all"]:
            raise ValueError("keep must be 'keep-all' or 'remove-all'")

        # Pass 'keep' as a query parameter
        result = self.post(f"/challenges/{challenge_id}/leave?keep={keep}")
        return result if isinstance(result, dict) else None

    # MARK: - Convenience Methods (Group & Party)

    # --------------------------------------------------------------------------

    # & - def get_party_data(self) -> Optional[dict[str, Any]]:
    def get_party_data(self) -> Optional[dict[str, Any]]:
        """GET /groups/party - Gets data about the user's current party."""
        result = self.get("/groups/party")

        # API returns null or error if not in party, _request handles errors,

        # so None means not in party or actual error occurred.
        return result if isinstance(result, dict) else None

    # & - def get_quest_status(self) -> bool:
    def get_quest_status(self) -> bool:
        """Checks if the user's party is currently on an active quest."""
        try:
            party_data = self.get_party_data()

            # Safely access nested keys
            return (
                party_data is not None
                and party_data.get("quest", {}).get("active", False) is True
            )
        except requests.exceptions.RequestException as e:

            # Log error but return False, as quest status is unknown/unavailable
            console.print(
                f"Could not get party data for quest status: {e}",
                style="warning",
            )
            return False
        except ValueError as e:
            # Catch potential errors from API response format
            console.print(
                f"Invalid data received for party data: {e}", style="warning"
            )
            return False

    # MARK: - Convenience Methods (Inbox)

    # --------------------------------------------------------------------------

    # & - def get_inbox_messages(self, page: int = 0) -> list[dict[str, Any]]:
    def get_inbox_messages(self, page: int = 0) -> list[dict[str, Any]]:
        """GET /inbox/messages - Gets inbox messages (paginated)."""
        result = self.get("/inbox/messages", params={"page": page})

        # API returns list directly in 'data' field
        return result if isinstance(result, list) else []

    # MARK: - Convenience Methods (Content)

    # --------------------------------------------------------------------------

    # & - def get_content(self) -> Optional[dict[str, Any]]:
    def get_content(self) -> Optional[dict[str, Any]]:
        """GET /content - Retrieves the game content object."""
        # This endpoint does NOT use the standard {success, data} wrapper
        result = self._request("GET", "/content")
        # Use internal _request
        return result if isinstance(result, dict) else None

--- END OF FILE cli/api.py ---
--- START OF FILE cli/app.py ---

# pixabit/cli/app.py

# MARK: - MODULE DOCSTRING

"""Main Command Line Interface application class for Pixabit.
Handles user interaction, menu navigation, data fetching/refreshing,
and dispatching actions to underlying managers and processors, respecting
optional feature configurations.
"""

# MARK: - IMPORTS

import builtins
import datetime
import difflib
import json

# Keep for debug dumping if needed

import sys
import time
from collections import defaultdict
from pathlib import Path
from typing import Any, Dict, Optional, Set, Tuple

import timeago

# --- Rich and Display ---

try:
from pixabit.utils.display import (
BarColumn,
Confirm,
IntPrompt,
Live,
Panel,
Progress,
Prompt,
Rule,
SpinnerColumn,
Table,
TaskProgressColumn,
Text,
TextColumn,
TimeElapsedColumn,
TimeRemainingColumn,
box,
console,
print,
track,
)
except ImportError as e_rich:

    # Use standard print for this critical failure
    builtins.print(f"Fatal Error: Failed to import Rich components: {e_rich}")
    builtins.print("Please install Rich: pip install rich")
    sys.exit(1)

# --- Local Application Imports ---

try:
from pixabit import config

    # Import config to check optional tags
    from pixabit.api import MIN_REQUEST_INTERVAL, HabiticaAPI

    # Import constant
    from pixabit.challenge_backupper import ChallengeBackupper
    from pixabit.cli.exports import (
        # Import export functions
        save_all_userdata_into_json,
        save_processed_tasks_into_json,
        save_tags_into_json,
        save_tasks_without_proccessing,
    )

    # Correct class name/file
    from pixabit.config_tags import configure_tags as run_tag_config_setup

    # Alias for clarity
    from pixabit.data_processor import TaskProcessor, get_user_stats
    from pixabit.tag_manager import TagManager
    from pixabit.utils.dates import convert_to_local_time

except ImportError as e_imp:

    # Use standard print as console might not be ready
    builtins.print(f"Fatal Error importing Pixabit modules: {e_imp}")
    sys.exit(1)

# MARK: - CliApp Class

# ==============================================================================

class CliApp:
"""Main application class for the Pixabit CLI."""

    # MARK: - Initialization

    # & - def __init__(self):
    def __init__(self):
        """Initializes API client, managers, state, and performs initial data load."""
        self.console = console
        self.console.log("Initializing Pixabit App...", style="info")
        try:
            self.api_client = HabiticaAPI()
            # Handles mandatory credential check
            self.processor: Optional[TaskProcessor] = None
            # Initialized in refresh_data
            self.tag_manager = TagManager(self.api_client)
            # Logs its own config status
            self.backupper = ChallengeBackupper(self.api_client)
            self.console.log("Core components initialized.", style="info")
        except ValueError as e:
            # Catch missing mandatory creds from API init
            self.console.print(f"Configuration Error: {e}", style="error")
            sys.exit(1)
        except Exception:
            self.console.print(
                "Unexpected Initialization Error:", style="error"
            )
            self.console.print_exception(show_locals=False)
            sys.exit(1)

        # --- Application State Attributes ---
        self.user_data: dict[str, Any] = {}
        self.party_data: dict[str, Any] = {}
        self.content_data: dict[str, Any] = {}
        self.all_tags: list[Dict] = []
        self.processed_tasks: dict[str, Dict] = {}
        self.cats_data: dict[str, Any] = {}
        # Categorized task IDs/metadata
        self.user_stats: dict[str, Any] = {}
        self.unused_tags: list[Dict] = []
        self.all_challenges_cache: Optional[list[Dict]] = None
        # Cache for GET /challenges/user

        # --- Initial Data Load ---
        self.console.log("Performing initial data refresh...", style="info")
        self.refresh_data()
        self.console.log("Initialization complete.", style="success")
        self.console.print("")

    # Spacer

    # MARK: - Primary Public Method (Entry Point)

    # & - def run(self):
    def run(self):
        """Starts the main application menu loop."""
        while True:

            # --- Dynamically Build Menu Based on Config ---
            active_categories = self._build_active_menu()
            main_menu_options = list(active_categories.keys())

            # --- Display Menu & Get Choice ---
            choice = self._display_menu(
                "Main Menu", main_menu_options, embed_stats=True
            )
            if choice == 0:
                break
            # Exit
            if choice == -1:
                continue
            # Invalid input

            # --- Handle Choice ---
            try:
                category_name = main_menu_options[choice - 1]
            except IndexError:
                self.console.print(
                    f"Invalid choice index {choice}.", style="error"
                )
                continue

            if category_name == "Application":
                app_options = active_categories["Application"]
                app_choice = self._display_menu(
                    "Application Menu", app_options, embed_stats=False
                )
                if app_choice in [0, -1]:
                    continue
                try:
                    action_name = app_options[app_choice - 1]
                    if action_name == "Exit":
                        break
                    else:
                        self._execute_action(action_name)
                except IndexError:
                    self.console.print(
                        f"Invalid app choice {app_choice}.", style="error"
                    )
            else:
                self._submenu_loop(
                    category_name, active_categories[category_name]
                )

        self.console.print("\nExiting Pixabit. Goodbye!", style="bold info")

    # MARK: - Dynamic Menu Building

    # & - def _build_active_menu(self) -> dict[str, list[str]]:
    def _build_active_menu(self) -> dict[str, list[str]]:
        """Builds the menu dictionary, including optional items based on config."""
        # --- Base Menu Structure ---
        categories = {
            "Manage Tasks": ["Handle Broken Tasks", "Replicate Monthly Setup"],
            "Manage Tags": [
                "Display All Tags",
                "Display Unused Tags",
                "Delete Unused Tags",
                "Add/Replace Tag Interactively",
            ],
            "Manage Challenges": ["Backup Challenges", "Leave Challenge"],
            "View Data": ["Display Stats"],
            "Export Data": [
                "Save Processed Tasks (JSON)",
                "Save Raw Tasks (JSON)",
                "Save All Tags (JSON)",
                "Save Full User Data (JSON)",
            ],
            "User Actions": ["Toggle Sleep Status"],
            "Application": ["Refresh Data", "Configure Special Tags", "Exit"],
        }

        # --- Add Optional Tag Actions Conditionally ---
        mg_tags = categories["Manage Tags"]
        # Shortcut

        # Insert items at specific indices to maintain logical order
        insert_pos = 3
        # Position after basic display/delete options

        # Check config directly (config module holds the loaded values)
        if config.CHALLENGE_TAG_ID and config.PERSONAL_TAG_ID:
            mg_tags.insert(insert_pos, "Sync Challenge/Personal Tags")
            insert_pos += 1
        if config.PSN_TAG_ID and config.NOT_PSN_TAG_ID:
            mg_tags.insert(insert_pos, "Sync Poison Status Tags")
            insert_pos += 1
        if config.ATTR_TAG_MAP and config.NO_ATTR_TAG_ID:
            mg_tags.insert(insert_pos, "Sync Attribute Tags")
            insert_pos += 1

        # Filter out any categories that might have become empty (unlikely here)
        active_categories = {
            name: opts for name, opts in categories.items() if opts
        }
        return active_categories

    # MARK: - Major Workflow Methods

    # & - def refresh_data(self):
    def refresh_data(self):
        """Fetches/processes all necessary data using optimized API calls."""
        self.console.print(
            "\nRefreshing all application data...", style="highlight"
        )
        start_time = time.monotonic()

        # --- Setup Progress Bar ---
        progress = Progress(
            TextColumn(" â€¢ ", style="subtle"),
            TextColumn(
                "[progress.description]{task.description}", justify="left"
            ),
            BarColumn(
                style="rp_surface",
                complete_style="rp_foam",
                finished_style="rp_pine",
            ),
            TaskProgressColumn(style="rp_subtle_color"),
            TimeElapsedColumn(),
            SpinnerColumn("dots", style="rp_iris"),
            console=self.console,
            transient=False,
        )

        # Define steps and weights for progress calculation
        steps = [
            (
                "Fetch User",
                self.api_client.get_user_data,
                "user_data",
                1,
                True,
            ),
            # Name, function, attr_name, weight, critical
            (
                "Fetch Content",
                self._get_content_cached,
                "content_data",
                1,
                True,
            ),
            ("Fetch Tags", self.api_client.get_tags, "all_tags", 1, False),
            # Non-critical
            (
                "Fetch Party",
                self.api_client.get_party_data,
                "party_data",
                1,
                False,
            ),
            # Non-critical
            (
                "Fetch Challenges",
                self._fetch_challenges_cached,
                "all_challenges_cache",
                1,
                False,
            ),
            # Non-critical
            (
                "Process Tasks",
                self._process_tasks_step,
                "processed_tasks",
                5,
                True,
            ),
            # Special step
            (
                "Calculate Stats/Unused",
                self._calculate_stats_unused_step,
                None,
                1,
                False,
            ),
            # Special step
        ]
        total_weight = sum(w for _, _, _, w, _ in steps)
        main_task_id = progress.add_task(
            "[info]Initializing...", total=total_weight
        )
        refresh_ok = True

        with Live(
            progress,
            console=self.console,
            vertical_overflow="ellipsis",
            refresh_per_second=10,
        ) as live:
            units_done = 0

            # --- Execute Steps ---
            for i, (name, func, attr, weight, critical) in enumerate(steps):
                progress.update(
                    main_task_id,
                    description=f"[{i + 1}/{len(steps)}] {name}...",
                )
                try:

                    # Special steps call internal methods directly
                    if name == "Process Tasks":
                        if not self._process_tasks_step():
                            # Returns success bool
                            raise RuntimeError("Task processing failed.")
                    elif name == "Calculate Stats/Unused":
                        self._calculate_stats_unused_step()
                    # Updates attributes directly
                    else:
                        # Standard data fetching steps
                        result = func()
                        # Call the fetch function
                        if result is None and critical:
                            # Critical fetch failed (e.g., user, content)
                            raise ValueError(
                                f"{name} data fetch returned None."
                            )
                        if attr:
                            # If an attribute name is provided, store the result
                            setattr(
                                self,
                                attr,
                                (
                                    result
                                    if result is not None
                                    else self._get_default_for_attr(attr)
                                ),
                            )

                    units_done += weight
                    progress.update(main_task_id, completed=units_done)

                except Exception as e:
                    failed_msg = f"[error]Failed: {name}!"
                    progress.update(main_task_id, description=failed_msg)
                    self.console.log(
                        f"Error during '{name}': {e}", style="error"
                    )
                    refresh_ok = False
                    if critical:
                        # Stop refresh if critical step fails
                        self.console.print(
                            f"Halting refresh due to critical error in '{name}'.",
                            style="error",
                        )

                        # Ensure default types are set for subsequent steps even if we break
                        self._ensure_default_attributes()
                        break
                    # Exit the loop
                    else:
                        # Non-critical error, log and continue
                        self.console.log(
                            "Continuing refresh despite non-critical error.",
                            style="warning",
                        )

                        # Ensure attribute has a default value if fetch failed
                        if attr:
                            setattr(
                                self, attr, self._get_default_for_attr(attr)
                            )
                        units_done += weight
                        # Still advance progress for non-critical failures
                        progress.update(main_task_id, completed=units_done)

        # --- Post-Refresh Summary ---
        end_time = time.monotonic()
        duration = end_time - start_time
        final_status, final_style = (
            ("Refresh Complete!", "success")
            if refresh_ok
            else ("Refresh Failed!", "error")
        )
        progress.update(
            main_task_id,
            description=f"[{final_style}]{final_status}[/]",
            completed=total_weight,
        )
        time.sleep(0.1)
        # Allow final render
        self.console.print(
            f"[{final_style}]{final_status}[/] (Duration: {duration:.2f}s)"
        )

        # Ensure default types after loop finishes, especially if errors occurred
        self._ensure_default_attributes()

    # & - def _get_default_for_attr(self, attr_name: str) -> Any:
    def _get_default_for_attr(self, attr_name: str) -> Any:
        """Returns a sensible default value based on the attribute name."""
        if "list" in attr_name or "tags" in attr_name or "cache" in attr_name:
            return []
        if "dict" in attr_name or "data" in attr_name or "stats" in attr_name:
            return {}
        return None

    # Default fallback

    # & - def _ensure_default_attributes(self):
    def _ensure_default_attributes(self):
        """Ensures core state attributes have default types after refresh, especially if errors occurred."""
        self.user_data = getattr(self, "user_data", None) or {}
        self.party_data = getattr(self, "party_data", None) or {}
        self.content_data = getattr(self, "content_data", None) or {}
        self.all_tags = getattr(self, "all_tags", None) or []
        self.processed_tasks = getattr(self, "processed_tasks", None) or {}
        self.cats_data = getattr(self, "cats_data", None) or {
            "tasks": {},
            "tags": [],
            "broken": [],
            "challenge": [],
        }
        self.user_stats = getattr(self, "user_stats", None) or {}
        self.unused_tags = getattr(self, "unused_tags", None) or []
        self.all_challenges_cache = getattr(self, "all_challenges_cache", None)
        # Keep None if not fetched
        if (
            not isinstance(self.all_challenges_cache, list)
            and self.all_challenges_cache is not None
        ):
            self.all_challenges_cache = []

    # Reset to list if it became something else

    # & - def _get_content_cached(self) -> dict[str, Any]: ... (keep previous implementation)
    def _get_content_cached(self) -> dict[str, Any]:
        """Helper to get game content, using cache first."""
        # Re-use implementation from app_v5.txt
        content = None
        cache_path = Path("content_cache.json")
        # Use Path object
        if cache_path.exists():
            try:
                with open(cache_path, encoding="utf-8") as f:
                    content = json.load(f)
                if isinstance(content, dict) and content:
                    self.console.log(
                        f"Using cached content from '{cache_path}'.",
                        style="subtle",
                    )
                    return content
                else:
                    self.console.log(
                        f"Invalid content in cache '{cache_path}'. Refetching.",
                        style="warning",
                    )
                    content = None
            except (OSError, json.JSONDecodeError, Exception) as e:
                self.console.log(
                    f"Failed loading cache '{cache_path}': {e}. Refetching.",
                    style="warning",
                )
                content = None
        if content is None:
            self.console.log("Fetching game content from API...", style="info")
            try:
                content = self.api_client.get_content()
                # Returns dict or None
                if isinstance(content, dict) and content:
                    try:
                        with open(cache_path, "w", encoding="utf-8") as f:
                            json.dump(content, f, ensure_ascii=False, indent=2)
                        self.console.log(
                            f"Saved content to cache: '{cache_path}'",
                            style="subtle",
                        )
                    except (OSError, Exception) as e_save:
                        self.console.log(
                            f"Failed to save content cache: {e_save}",
                            style="warning",
                        )
                    return content
                else:
                    self.console.log(
                        "Failed to fetch valid game content.", style="error"
                    )
                    return {}
            except Exception as e_fetch:
                self.console.log(
                    f"Exception fetching content: {e_fetch}", style="error"
                )
                return {}
        return {}

    # Should not be reached

    # & - def _fetch_challenges_cached(self) -> Optional[list[Dict]]:
    def _fetch_challenges_cached(self) -> Optional[list[Dict]]:
        """Fetches challenges only if cache is empty."""
        if self.all_challenges_cache is None:
            self.console.log(
                "Challenge cache empty, fetching...", style="subtle"
            )

            # Fetch only challenges the user is currently a member of
            fetched = self.api_client.get_challenges(member_only=True)
            # Returns list or []
            self.all_challenges_cache = fetched
            # Update cache
            self.console.log(
                f"Fetched and cached {len(self.all_challenges_cache)} challenges.",
                style="subtle",
            )
        else:
            self.console.log(
                f"Using cached challenges ({len(self.all_challenges_cache)} found).",
                style="subtle",
            )
        return self.all_challenges_cache

    # Return the list (potentially empty or from cache)

    # & - def _process_tasks_step(self) -> bool:
    def _process_tasks_step(self) -> bool:
        """Internal step for task processing during refresh_data."""
        try:

            # Instantiate processor, passing pre-fetched data
            self.processor = TaskProcessor(
                api_client=self.api_client,
                user_data=self.user_data,
                party_data=self.party_data,
                all_tags_list=self.all_tags,
                content_data=self.content_data,
            )

            # Perform processing and categorization
            processed_results = self.processor.process_and_categorize_all()

            # Store results
            self.processed_tasks = processed_results.get("data", {})
            self.cats_data = processed_results.get("cats", {})
            if not self.processed_tasks and not self.cats_data.get("tasks"):
                self.console.log("No tasks found or processed.", style="info")
            return True
        # Indicate success
        except Exception as e:
            self.console.log(f"Error processing tasks: {e}", style="error")
            self.processed_tasks = {}
            # Reset on error
            self.cats_data = {}
            return False

    # Indicate failure

    # & - def _calculate_stats_unused_step(self):
    def _calculate_stats_unused_step(self):
        """Internal step for calculating stats and unused tags during refresh_data."""
        # Calculate User Stats (uses pre-fetched/processed data)
        try:
            if self.cats_data and self.processed_tasks and self.user_data:
                self.user_stats = get_user_stats(
                    api_client=self.api_client,
                    # Pass client just in case
                    cats_dict=self.cats_data,
                    processed_tasks_dict=self.processed_tasks,
                    user_data=self.user_data,
                    # Pass pre-fetched data
                )
            else:
                self.console.log(
                    "Skipping stats calculation: missing data.", style="warning"
                )
                self.user_stats = {}
        except Exception as e:
            self.console.log(
                f"Error calculating user stats: {e}.", style="warning"
            )
            self.user_stats = {}

        # Calculate Unused Tags (uses pre-fetched/processed data)
        try:
            if (
                isinstance(self.all_tags, list)
                and self.cats_data.get("tags") is not None
            ):

                # Ensure used_tag_ids is a set
                used_tag_ids: Set[str] = set(self.cats_data.get("tags", []))
                self.unused_tags = self.tag_manager.find_unused_tags(
                    self.all_tags, used_tag_ids
                )

            # self.console.log(f"Calculated {len(self.unused_tags)} unused tags.", style="subtle")
            else:
                self.console.log(
                    "Skipping unused tags calculation: missing data.",
                    style="warning",
                )
                self.unused_tags = []
        except Exception as e:
            self.console.log(
                f"Error calculating unused tags: {e}", style="warning"
            )
            self.unused_tags = []

    # & - def _submenu_loop(...)
    def _submenu_loop(self, title: str, options: list[str]):
        """Handles display/logic for a submenu."""
        while True:
            choice = self._display_menu(
                f"{title} Menu", options, embed_stats=False
            )
            if choice == 0:
                break
            if choice == -1:
                continue
            try:
                self._execute_action(options[choice - 1])
            except IndexError:
                self.console.print(
                    f"Invalid submenu choice {choice}.", style="error"
                )

    # & - def _execute_action(...)
    def _execute_action(self, action_name: str):
        """Executes selected action, passing data, checks config for optional actions."""
        self.console.print(
            f"\nâ¡ï¸ Executing: [highlight]{action_name}[/]", highlight=False
        )
        refresh_needed = False
        action_taken = False
        # Track if an action was actually performed
        start_time = time.monotonic()

        try:

            # --- Task Management ---
            if action_name == "Handle Broken Tasks":

                # This action uses self.cats_data and self.processed_tasks internally
                action_taken = refresh_needed = (
                    self._handle_broken_tasks_action()
                )
            elif action_name == "Replicate Monthly Setup":

                # This action uses self.cats_data, self.processed_tasks, self.all_challenges_cache
                action_taken = refresh_needed = (
                    self._replicate_monthly_setup_action()
                )

            # --- Tag Management (Check Config for Optional Actions) ---
            elif action_name == "Display All Tags":
                self._display_tags()
                action_taken = True
            # Display actions always run
            elif action_name == "Display Unused Tags":
                self._display_unused_tags()
                action_taken = True
            elif action_name == "Delete Unused Tags":

                # Pass necessary data to TagManager method
                used_ids = set(self.cats_data.get("tags", []))
                action_taken = refresh_needed = (
                    self.tag_manager.delete_unused_tags_interactive(
                        self.all_tags, used_ids
                    )
                )
            elif action_name == "Sync Challenge/Personal Tags":

                # Check config before calling
                if config.CHALLENGE_TAG_ID and config.PERSONAL_TAG_ID:
                    action_taken = refresh_needed = (
                        self.tag_manager.sync_challenge_personal_tags(
                            self.processed_tasks
                        )
                    )
                else:
                    self.console.print(
                        "Challenge/Personal tags not configured.", style="info"
                    )
            elif action_name == "Sync Poison Status Tags":
                if config.PSN_TAG_ID and config.NOT_PSN_TAG_ID:
                    action_taken = refresh_needed = (
                        self.tag_manager.ensure_poison_status_tags(
                            self.processed_tasks
                        )
                    )
                else:
                    self.console.print(
                        "Poison Status tags not configured.", style="info"
                    )
            elif action_name == "Sync Attribute Tags":
                if config.ATTR_TAG_MAP and config.NO_ATTR_TAG_ID:
                    action_taken = refresh_needed = (
                        self.tag_manager.sync_attributes_to_tags(
                            self.processed_tasks
                        )
                    )
                else:
                    self.console.print(
                        "Attribute tags not fully configured.", style="info"
                    )
            elif action_name == "Add/Replace Tag Interactively":

                # This action uses self.all_tags and self.processed_tasks
                action_taken = refresh_needed = (
                    self._interactive_tag_replace_action()
                )

            # --- Challenge Management ---
            elif action_name == "Backup Challenges":
                if Confirm.ask(
                    "Backup all accessible challenges?", console=self.console
                ):
                    backup_folder = Path("_challenge_backups")
                    # Use Path
                    self.backupper.create_backups(output_folder=backup_folder)
                    action_taken = True
            elif action_name == "Leave Challenge":

                # This action uses self.all_challenges_cache, self.user_data, updates cache
                action_taken = self._leave_challenge_action()
            # Returns False for refresh

            # --- View Data ---
            elif action_name == "Display Stats":
                stats_panel = self._display_stats()
                # Uses self.user_stats
                if stats_panel:
                    self.console.print(stats_panel)
                    action_taken = True

            # --- Export Data ---
            elif action_name == "Save Processed Tasks (JSON)":
                if self.processed_tasks and Confirm.ask(
                    "Save processed tasks?", console=self.console
                ):
                    save_processed_tasks_into_json(
                        self.processed_tasks, "tasks_processed.json"
                    )
                    action_taken = True
                elif not self.processed_tasks:
                    self.console.print(
                        "No processed tasks to save.", style="warning"
                    )
            elif action_name == "Save Raw Tasks (JSON)":
                if Confirm.ask(
                    "Save raw tasks (fetches fresh)?", console=self.console
                ):
                    save_tasks_without_proccessing(
                        self.api_client, "tasks_raw.json"
                    )
                    action_taken = True
            elif action_name == "Save All Tags (JSON)":
                if Confirm.ask(
                    "Save all tags (fetches fresh)?", console=self.console
                ):
                    save_tags_into_json(self.api_client, "tags_all.json")
                    action_taken = True
            elif action_name == "Save Full User Data (JSON)":
                if Confirm.ask(
                    "Save full user data (fetches fresh)?", console=self.console
                ):
                    save_all_userdata_into_json(
                        self.api_client, "user_data_full.json"
                    )
                    action_taken = True

            # --- User Actions ---
            elif action_name == "Toggle Sleep Status":
                current_status = self.user_stats.get("sleeping", False)
                action_desc = "wake up" if current_status else "go to sleep"
                if Confirm.ask(
                    f"Do you want to {action_desc}?", console=self.console
                ):
                    response = self.api_client.toggle_user_sleep()
                    if response is not None:
                        new_status = (
                            response.get("sleep")
                            if isinstance(response, dict)
                            else "Unknown"
                        )
                        self.console.print(
                            f"Sleep toggled. New status: {new_status}",
                            style="success",
                        )
                        refresh_needed = True
                        action_taken = True
                    else:
                        self.console.print(
                            "Failed to toggle sleep status.", style="error"
                        )

            # --- Application ---
            elif action_name == "Refresh Data":
                refresh_needed = True
                action_taken = True
            # Refresh happens after action block
            elif action_name == "Configure Special Tags":
                run_tag_config_setup()
                # Call the setup function
                refresh_needed = True
                action_taken = True
            # Assume config changed

            # --- Fallback ---
            else:
                self.console.print(
                    f"Action '{action_name}' not implemented.", style="warning"
                )

            # --- Post-Action Refresh ---
            if refresh_needed:
                self.console.print(
                    f"\nAction '{action_name}' requires data update.",
                    style="info",
                )
                self.refresh_data()

        except Exception:
            self.console.print(
                f"\nError executing action '{action_name}':", style="error"
            )
            self.console.print_exception(show_locals=False)
        finally:
            end_time = time.monotonic()
            duration = end_time - start_time
            if action_taken:
                # Only prompt if something actually happened
                self.console.print(
                    f"Action '{action_name}' finished. (Duration: {duration:.2f}s)",
                    style="subtle",
                )
                Prompt.ask(
                    "\n[subtle]Press Enter to continue...[/]",
                    default="",
                    console=self.console,
                )

    # MARK: - UI Helper Methods

    # & - def _display_menu(...) (Keep previous themed implementation)
    def _display_menu(
        self, title: str, options: list[str], embed_stats: bool = False
    ) -> int:
        """Displays a menu using Rich, optionally embedding stats."""
        # Re-use implementation from app_v5.txt
        max_option = len(options)
        menu_renderables = []
        back_label = "Exit Application" if title == "Main Menu" else "Back"
        menu_renderables.append(f"[subtle] 0.[/] {back_label}")
        for i, opt in enumerate(options):
            menu_renderables.append(f"[bold] {i + 1}.[/] {opt}")
        menu_panel = Panel(
            "\n".join(menu_renderables),
            title=f"[highlight]{title}[/]",
            border_style="rp_subtle_color",
            box=box.ROUNDED,
            padding=(1, 2),
            expand=False,
        )
        display_object: Any = menu_panel
        if embed_stats:
            stats_panel = self._display_stats()
            if stats_panel:
                layout_table = Table.grid(expand=True)
                layout_table.add_column(ratio=3)
                layout_table.add_column(ratio=2)
                layout_table.add_row(stats_panel, menu_panel)
                display_object = Panel(
                    layout_table, border_style="rp_overlay", expand=True
                )
            else:
                self.console.print(
                    "Could not display stats panel.", style="warning"
                )
        self.console.print(display_object)
        try:
            return IntPrompt.ask(
                "Choose an option",
                choices=[str(i) for i in range(max_option + 1)],
                show_choices=False,
                console=self.console,
            )
        except Exception as e:
            self.console.print(f"Menu input error: {e}", style="error")
            return -1

    # & - def _display_stats(...) (Keep previous themed implementation)
    def _display_stats(self) -> Optional[Panel]:
        """Builds and returns a Rich Panel containing formatted user stats."""
        # Re-use implementation from app_v5.txt
        stats = self.user_stats
        if not stats:
            self.console.print("No user stats data available.", style="warning")
            return None
        try:

            # Extract data safely
            uname, lvl, uclass = (
                stats.get("username", "N/A"),
                stats.get("level", 0),
                stats.get("class", "N/A").capitalize(),
            )
            hp, max_hp, mp, max_mp = (
                int(stats.get("hp", 0)),
                stats.get("maxHealth", 50),
                int(stats.get("mp", 0)),
                stats.get("maxMP", 30),
            )
            exp, next_lvl, gp, gems = (
                int(stats.get("exp", 0)),
                stats.get("toNextLevel", 100),
                int(stats.get("gp", 0)),
                stats.get("gems", 0),
            )
            core = stats.get("stats", {})
            sleeping, day_start, last_login = (
                stats.get("sleeping", False),
                stats.get("day_start", "?"),
                stats.get("last_login_local", "N/A"),
            )
            broken, questing, q_key = (
                stats.get("broken_challenge_tasks", 0),
                stats.get("quest_active", False),
                stats.get("quest_key"),
            )
            dmg_u, dmg_p = (
                stats.get("potential_daily_damage_user", 0.0),
                stats.get("potential_daily_damage_party", 0.0),
            )
            dmg_style = (
                "error" if dmg_u >= 5 else "warning" if dmg_u > 0 else "subtle"
            )
            dmg_p_str = f", Party: {dmg_p:.1f}" if dmg_p > 0 else ""
            t_counts = stats.get("task_counts", {})

            # Format login time
            login_display = "N/A"
            if last_login and "Error" not in last_login and last_login != "N/A":
                try:
                    login_dt = datetime.datetime.fromisoformat(last_login)
                    local_tz = datetime.datetime.now().astimezone().tzinfo
                    now_local = datetime.datetime.now(local_tz)
                    login_dt_aware = login_dt.replace(tzinfo=local_tz)
                    login_display = timeago.format(login_dt_aware, now_local)
                except Exception:
                    login_display = last_login
            # Fallback

            # Build UI Tables
            user_info = Table.grid(padding=(0, 1), expand=False)
            user_info.add_column(style="subtle", justify="right", min_width=3)
            user_info.add_column(justify="left")
            user_info.add_row(
                "ğŸ‘¤", f"[highlight]{uname}[/] ([rp_iris]{uclass} Lv {lvl}[/])"
            )
            user_info.add_row("ğŸ•’", f"Login: [rp_text i]{login_display}[/]")
            user_info.add_row("ğŸŒ…", f"Day start: {day_start}:00")
            if sleeping:
                user_info.add_row("ğŸ’¤", "[warning i]Resting in Inn[/]")
            if questing:
                user_info.add_row(
                    "ğŸ‰", f"[info]On Quest:[/] [i]{q_key or 'Unknown'}[/]"
                )
            if broken:
                user_info.add_row(
                    ":warning:", f"[error]{broken} broken tasks[/]"
                )
            user_info.add_row(
                "ğŸ’”", f"Dmg: [{dmg_style}]User {dmg_u:.1f}{dmg_p_str}[/]"
            )

            stat_vals = Table.grid(padding=(0, 1), expand=False)
            stat_vals.add_row(
                f"[rp_love b]HP: [/]{hp: <3}/ {max_hp}",
                f"[rp_gold b]XP: [/]{exp: <3}/ {next_lvl}",
            )
            stat_vals.add_row(
                f"[rp_foam b]MP: [/]{mp: <3}/ {max_mp}",
                f"[rp_gold b]GP: [/]{gp}",
            )
            stat_vals.add_row(f"[b]ğŸ’ Gems:[/b] {gems}", "")
            stat_vals.add_row(
                f"[subtle]STR:[/] {core.get('str', 0)} [subtle]INT:[/] {core.get('int', 0)}",
                f"[subtle]CON:[/] {core.get('con', 0)} [subtle]PER:[/] {core.get('per', 0)}",
            )

            # Task Counts Panel
            hab_c, rew_c = t_counts.get("habits", 0), t_counts.get("rewards", 0)
            day_d, todo_d = t_counts.get("dailys", {}), t_counts.get(
                "todos", {}
            )
            day_tot, todo_tot = day_d.get("_total", 0), todo_d.get("_total", 0)
            day_due, todo_due = day_d.get("due", 0), todo_d.get(
                "due", 0
            ) + todo_d.get("red", 0)
            day_done = day_d.get("success", 0)
            # Use 'success' key from processor
            tasks_text = f"Habits:[b]{hab_c}[/]\n Daylies:[b]{day_tot}[/] ([warning]{day_due}[/] due/[success]{day_done}[/] done)\n Todo:[b]{todo_tot}[/] ([warning]{todo_due}[/] due)\n Rewards:[b]{rew_c}[/]"
            tasks_p = Panel(
                tasks_text,
                title="Tasks",
                border_style="blue",
                padding=(0, 1),
                expand=False,
            )

            # Assemble Layout
            top = Table.grid(expand=True)
            top.add_column(ratio=1)
            top.add_column(ratio=1)
            top.add_row(
                Panel(user_info, border_style="rp_overlay", padding=(1, 1)),
                Panel(stat_vals, border_style="rp_overlay", padding=(1, 1)),
            )
            final = Table.grid(expand=True)
            final.add_row(top)
            final.add_row(tasks_p)
            return Panel(
                final,
                title="ğŸ“Š [highlight]Dashboard[/]",
                border_style="green",
                padding=(1, 2),
            )
        except Exception:
            self.console.print("Error building stats display:", style="error")
            self.console.print_exception(show_locals=False)
            return None

    # & - def _display_tags(...) (Keep previous themed implementation)
    def _display_tags(self):
        """Displays all fetched tags in a table using theme styles."""
        if not self.all_tags:
            self.console.print("No tags data available.", style="warning")
            return
        self.console.print(
            f"\n[highlight]All Tags ({len(self.all_tags)})[/]", highlight=False
        )
        table = Table(
            show_header=True,
            header_style="rp_iris",
            box=box.ROUNDED,
            padding=(0, 1),
        )
        table.add_column("Num", style="subtle", width=4, justify="right")
        table.add_column("Name", style="rp_foam", min_width=20, no_wrap=True)
        table.add_column("ID", style="rp_rose", overflow="fold", min_width=36)
        valid = [
            tag
            for tag in self.all_tags
            if isinstance(tag, dict) and tag.get("id")
        ]
        for i, tag in enumerate(valid):
            table.add_row(
                str(i + 1), tag.get("name", "[subtle]N/A[/]"), tag["id"]
            )
        self.console.print(table)

    # & - def _display_unused_tags(...) (Keep previous themed implementation)
    def _display_unused_tags(self):
        """Displays unused tags in a table using theme styles."""
        if not self.unused_tags:
            self.console.print("âœ… No unused tags found.", style="success")
            return
        self.console.print(
            f"\n[highlight]Unused Tags ({len(self.unused_tags)})[/]",
            highlight=False,
        )
        table = Table(
            show_header=True,
            header_style="rp_gold",
            box=box.ROUNDED,
            padding=(0, 1),
        )
        table.add_column("Num", style="subtle", width=4, justify="right")
        table.add_column("Name", style="rp_foam", min_width=20, no_wrap=True)
        table.add_column("ID", style="rp_rose", overflow="fold", min_width=36)
        for i, tag in enumerate(self.unused_tags):
            table.add_row(
                str(i + 1),
                tag.get("name", "[subtle]N/A[/]"),
                tag.get("id", "[subtle]N/A[/]"),
            )
        self.console.print(table)

    # & - def _display_broken_tasks(...) (Keep previous themed implementation)
    def _display_broken_tasks(
        self, challenge_id_filter: Optional[str] = None
    ) -> list[Dict]:
        """Displays broken tasks using theme styles, returns displayed task info list."""
        broken_ids = self.cats_data.get("broken", [])
        if not broken_ids:
            if not challenge_id_filter:
                self.console.print("âœ… No broken tasks found.", style="success")
            return []
        title, display_tasks = "Broken Challenge Tasks", []
        for tid in broken_ids:
            task = self.processed_tasks.get(tid)
            if task:
                cid = task.get("challenge_id")
                cname = task.get("challenge_name", "[subtle]N/A[/]")
                ttext = task.get("text", "[subtle]N/A[/]")
                info = {
                    "id": tid,
                    "text": ttext,
                    "challenge_id": cid,
                    "challenge_name": cname,
                }
                if challenge_id_filter:
                    if cid == challenge_id_filter:
                        display_tasks.append(info)
                else:
                    display_tasks.append(info)
        if not display_tasks:
            if challenge_id_filter:
                self.console.print(
                    f"No broken tasks for challenge ID {challenge_id_filter}.",
                    style="warning",
                )
            return []
        if challenge_id_filter:
            title = f"Broken Tasks for: {display_tasks[0]['challenge_name']}"
        self.console.print(
            f"\nFound {len(display_tasks)} broken tasks:", style="warning"
        )
        table = Table(
            title=title, show_header=True, header_style="error", box=box.ROUNDED
        )
        table.add_column("Num", style="subtle", width=4, justify="right")
        table.add_column("Task Text", style="rp_text", min_width=30)
        if not challenge_id_filter:
            table.add_column("Challenge", style="rp_iris", min_width=20)
        table.add_column("Task ID", style="subtle", width=36)
        for i, task in enumerate(display_tasks):
            row = [str(i + 1), task["text"]]
            if not challenge_id_filter:
                row.append(task["challenge_name"])
            row.append(task["id"])
            table.add_row(*row)
        self.console.print(table)
        return display_tasks

    # MARK: - Action Helper Methods

    # & - def _handle_broken_tasks_action(...) (Keep previous themed implementation)
    def _handle_broken_tasks_action(self) -> bool:
        """Groups broken tasks, allows bulk/individual unlinking using theme styles."""
        # Re-use implementation from app_v5.txt
        broken_ids = self.cats_data.get("broken", [])
        should_refresh = False
        if not broken_ids:
            self.console.print("âœ… No broken tasks found.", style="success")
            return False
        broken_by_challenge = defaultdict(list)
        challenge_names = {}
        all_valid = []
        for tid in broken_ids:
            task = self.processed_tasks.get(tid)
            if task:
                cid = task.get("challenge_id")
                if cid:
                    cname = task.get("challenge_name", cid)
                    info = {"id": tid, "text": task.get("text", "N/A")}
                    broken_by_challenge[cid].append(info)
                    if cid not in challenge_names:
                        challenge_names[cid] = cname
                    all_valid.append(
                        {**info, "challenge_id": cid, "challenge_name": cname}
                    )
        if not broken_by_challenge:
            self.console.print(
                "No broken tasks with challenge links found.", style="warning"
            )
            return False
        self.console.print(
            f"\nFound {len(all_valid)} broken tasks across {len(broken_by_challenge)} challenges:",
            style="warning",
        )
        ch_table = Table(
            title="Challenges with Broken Tasks",
            box=box.ROUNDED,
            border_style="warning",
        )
        ch_table.add_column("Num", style="subtle", width=4)
        ch_table.add_column("Challenge Name / ID", style="rp_iris")
        ch_table.add_column("Task Count", style="rp_text", justify="right")
        ch_list = list(broken_by_challenge.keys())
        for i, cid in enumerate(ch_list):
            ch_table.add_row(
                str(i + 1),
                challenge_names.get(cid, cid),
                str(len(broken_by_challenge[cid])),
            )
        self.console.print(ch_table)
        self.console.print(
            "\nManage broken tasks:\n  [1] By Challenge (Bulk)\n  [2] Individually\n  [0] Cancel"
        )
        try:
            mode = IntPrompt.ask(
                "Enter choice",
                choices=["0", "1", "2"],
                show_choices=False,
                console=self.console,
            )
            if mode == 0:
                return False
            elif mode == 1:
                # Bulk
                if not ch_list:
                    return False
                ch_num = IntPrompt.ask(
                    f"Challenge number (1-{len(ch_list)})",
                    choices=[str(i) for i in range(1, len(ch_list) + 1)],
                    show_choices=False,
                    console=self.console,
                )
                sel_cid = ch_list[ch_num - 1]
                sel_cname = challenge_names.get(sel_cid, sel_cid)
                tasks_in_ch = broken_by_challenge[sel_cid]
                self.console.print(f"\nTasks in [rp_iris]'{sel_cname}'[/]:")
                [
                    self.console.print(
                        f"  - {t['text']} ([subtle]{t['id']}[/])"
                    )
                    for t in tasks_in_ch
                ]
                keep = Confirm.ask(
                    f"\nKeep personal copies of these {len(tasks_in_ch)} tasks?",
                    default=True,
                    console=self.console,
                )
                keep_param = "keep-all" if keep else "remove-all"
                action_desc = (
                    "keeping copies"
                    if keep_param == "keep-all"
                    else "[error]removing permanently[/]"
                )
                if Confirm.ask(
                    f"Confirm bulk-unlink for '{sel_cname}' ({action_desc})?",
                    default=True,
                    console=self.console,
                ):
                    self.console.print(
                        f"Attempting bulk unlink for {sel_cid} ({action_desc})...",
                        style="info",
                    )
                    try:
                        self.api_client.unlink_all_challenge_tasks(
                            sel_cid, keep=keep_param
                        )
                        self.console.print(
                            f"Bulk unlink successful for '{sel_cname}'.",
                            style="success",
                        )
                        should_refresh = True
                    except Exception as e:
                        self.console.print(
                            f"Error bulk unlinking {sel_cid}: {e}",
                            style="error",
                        )
                        self.console.print(
                            "Hint: Try individual unlinking.", style="warning"
                        )
                        should_refresh = False
                else:
                    self.console.print("Bulk unlink cancelled.", style="info")
            elif mode == 2:
                # Individual
                if not all_valid:
                    return False
                disp_tasks = self._display_broken_tasks()
                # Use helper to display numbered list
                if not disp_tasks:
                    return False
                task_num = IntPrompt.ask(
                    f"Task number to unlink (1-{len(disp_tasks)})",
                    choices=[str(i) for i in range(1, len(disp_tasks) + 1)],
                    show_choices=False,
                    console=self.console,
                )
                sel_task = disp_tasks[task_num - 1]
                sel_tid = sel_task["id"]
                sel_ttext = sel_task["text"]
                keep = Confirm.ask(
                    f"Keep personal copy of '{sel_ttext}'?",
                    default=True,
                    console=self.console,
                )
                keep_param = "keep" if keep else "remove"
                action_desc = (
                    "keeping copy"
                    if keep_param == "keep"
                    else "[error]removing permanently[/]"
                )
                if Confirm.ask(
                    f"Unlink task '{sel_ttext}' ({action_desc})?",
                    default=True,
                    console=self.console,
                ):
                    self.console.print(
                        f"Attempting unlink for task {sel_tid} ({action_desc})...",
                        style="info",
                    )
                    try:
                        self.api_client.unlink_task_from_challenge(
                            sel_tid, keep=keep_param
                        )
                        self.console.print(
                            f"Successfully unlinked '{sel_ttext}'.",
                            style="success",
                        )
                        should_refresh = True
                    except Exception as e:
                        self.console.print(
                            f"Error unlinking task {sel_tid}: {e}",
                            style="error",
                        )
                        should_refresh = False
                else:
                    self.console.print("Unlink cancelled.", style="info")
        except (ValueError, IndexError) as e:
            self.console.print(f"Invalid selection: {e}", style="error")
        except KeyboardInterrupt:
            self.console.print("\nOperation cancelled.")
        return should_refresh

    # & - def _interactive_tag_replace_action(...) (Keep previous themed implementation)
    def _interactive_tag_replace_action(self) -> bool:
        """Handles interactive prompts for replacing tags using theme styles."""
        # Re-use implementation from app_v5.txt
        self._display_tags()
        valid = [
            t for t in self.all_tags if isinstance(t, dict) and t.get("id")
        ]
        num_tags = len(valid)
        if not valid:
            self.console.print("No valid tags found.", style="warning")
            return False
        should_refresh = False
        try:
            self.console.print("\nSelect tags by number:")
            del_num = IntPrompt.ask(
                f"Tag to FIND/REPLACE (1-{num_tags})", console=self.console
            )
            if not 1 <= del_num <= num_tags:
                raise ValueError("Find selection out of range")
            find_tag = valid[del_num - 1]
            find_id, find_name = find_tag["id"], find_tag.get(
                "name", find_tag["id"]
            )
            add_num = IntPrompt.ask(
                f"Tag to ADD (1-{num_tags})", console=self.console
            )
            if not 1 <= add_num <= num_tags:
                raise ValueError("Add selection out of range")
            if del_num == add_num:
                self.console.print(
                    "Source and target tags cannot be same.", style="warning"
                )
                return False
            add_tag = valid[add_num - 1]
            add_id, add_name = add_tag["id"], add_tag.get("name", add_tag["id"])
            replace = Confirm.ask(
                f"Also REMOVE '[rp_rose]{find_name}[/]' after adding '[rp_foam]{add_name}[/]'?",
                default=False,
                console=self.console,
            )
            mode = "replace" if replace else "add"
            if Confirm.ask(
                f"Proceed to {mode} tag '[rp_foam]{add_name}[/]' on tasks having '[rp_rose]{find_name}[/]'?",
                default=True,
                console=self.console,
            ):
                if not self.processed_tasks:
                    self.console.print(
                        "No processed task data.", style="warning"
                    )
                    return False
                self.console.print(
                    f"Performing tag {mode} operation...", style="info"
                )

                # Pass data to TagManager method
                success = self.tag_manager.add_or_replace_tag_based_on_other(
                    tasks_dict=self.processed_tasks,
                    find_tag_id=find_id,
                    add_tag_id=add_id,
                    remove_original=replace,
                )
                if success:
                    self.console.print(
                        "Tag operation completed.", style="success"
                    )
                    should_refresh = True
                else:
                    self.console.print(
                        "Tag operation may have errors.", style="warning"
                    )
                    should_refresh = True
            # Refresh anyway
            else:
                self.console.print("Operation cancelled.", style="info")
        except (ValueError, IndexError) as e:
            self.console.print(f"Invalid input: {e}.", style="error")
        except KeyboardInterrupt:
            self.console.print("\nOperation cancelled.")
        return should_refresh

    # & - def _leave_challenge_action(...) (Keep previous themed implementation, ensure cache update)
    def _leave_challenge_action(self) -> bool:
        """Handles listing JOINED challenges and leaving, updates local cache."""
        # Re-use implementation from app_v5.txt, ensure cache update logic is solid
        if self.all_challenges_cache is None:
            self.console.print(
                "Challenge list not loaded. Refresh data.", style="warning"
            )
            return False
        uid = self.user_data.get("id", "") if self.user_data else None
        joined = (
            [
                ch
                for ch in self.all_challenges_cache
                if isinstance(ch, dict)
                and ch.get("leader", {}).get("_id") != uid
            ]
            if uid
            else self.all_challenges_cache
        )
        if not joined:
            self.console.print(
                "No challenges joined (or cannot determine owner).",
                style="info",
            )
            return False
        table = Table(
            title="Challenges You Have Joined",
            show_header=True,
            header_style="bold blue",
            box=box.ROUNDED,
        )
        table.add_column("Num", style="subtle", width=4)
        table.add_column("Name", style="rp_iris", min_width=25)
        table.add_column("Leader", style="subtle", min_width=15)
        table.add_column("Memb", style="rp_text", width=7, justify="right")
        valid_sel = []
        # List of dicts
        for ch in joined:
            if isinstance(ch, dict) and ch.get("id"):
                valid_sel.append(ch)
                ldr = (
                    ch.get("leader", {})
                    .get("profile", {})
                    .get("name", "[subtle]?[/]")
                )
                mem = ch.get("memberCount", "?")
                table.add_row(
                    str(len(valid_sel)),
                    ch.get("shortName", "N/A"),
                    ldr,
                    str(mem),
                )
        if not valid_sel:
            self.console.print("No valid joined challenges.", style="warning")
            return False
        self.console.print(table)
        try:
            choice = IntPrompt.ask(
                f"Challenge number to leave (1-{len(valid_sel)}), or 0",
                choices=["0"] + [str(i) for i in range(1, len(valid_sel) + 1)],
                show_choices=False,
                console=self.console,
            )
            if choice == 0:
                return False
            sel_ch = valid_sel[choice - 1]
            sel_id, sel_name = sel_ch["id"], sel_ch.get(
                "shortName", sel_ch["id"]
            )
            self.console.print(f"\nSelected: [rp_iris]'{sel_name}'[/]")
            keep = Confirm.ask(
                "Keep personal copies of tasks?",
                default=True,
                console=self.console,
            )
            keep_param = "keep-all" if keep else "remove-all"
            action_desc = (
                "keeping copies"
                if keep_param == "keep-all"
                else "[error]removing tasks[/]"
            )
            if Confirm.ask(
                f"Confirm leaving '{sel_name}' ({action_desc})?",
                default=True,
                console=self.console,
            ):
                self.console.print(
                    f"Attempting to leave '{sel_name}' ({action_desc})...",
                    style="info",
                )
                try:
                    self.api_client.leave_challenge(sel_id, keep=keep_param)
                    self.console.print(
                        f"Successfully left challenge '{sel_name}'.",
                        style="success",
                    )

                    # --- IMPORTANT: Update Cache ---
                    if self.all_challenges_cache is not None:
                        self.all_challenges_cache = [
                            c
                            for c in self.all_challenges_cache
                            if isinstance(c, dict) and c.get("id") != sel_id
                        ]
                        self.console.print(
                            "In-memory challenge cache updated.", style="subtle"
                        )
                    return False
                # IMPORTANT: Return False as refresh is not needed due to cache update
                except Exception as e:
                    self.console.print(
                        f"Error leaving challenge {sel_id}: {e}", style="error"
                    )
                    return False
            else:
                self.console.print("Leave cancelled.", style="info")
                return False
        except (ValueError, IndexError) as e:
            self.console.print(f"Invalid selection: {e}", style="error")
        except KeyboardInterrupt:
            self.console.print("\nOperation cancelled.")
        return False

    # & - def _replicate_monthly_setup_action(...) (Keep previous themed implementation)
    def _replicate_monthly_setup_action(self) -> bool:
        """Replicates setup from old to new challenge using theme styles."""
        # Re-use implementation from app_v5.txt
        self.console.print(
            "\n--- Replicate Monthly Challenge Setup ---", style="highlight"
        )
        should_refresh = False
        old_cid, new_cid = None, None
        try:

            # Step 1: Select Old
            self.console.print("Identifying source challenges...", style="info")
            broken_ids = self.cats_data.get("broken", [])
            old_chs = {}
            if not broken_ids:
                self.console.print("No broken tasks found.", style="warning")
                return False
            for tid in broken_ids:
                task = self.processed_tasks.get(tid)
                if task:
                    cid = task.get("challenge_id")
                if cid and cid not in old_chs:
                    old_chs[cid] = task.get("challenge_name", cid)
            if not old_chs:
                self.console.print(
                    "Could not extract challenge info from broken tasks.",
                    style="warning",
                )
                return False
            old_list = list(old_chs.items())
            old_list.sort(key=lambda x: x[1])
            # Sort by name
            old_table = Table(
                title="Select Source (Old/Broken)",
                box=box.ROUNDED,
                border_style="rp_pine",
            )
            old_table.add_column("Num", style="subtle", width=4)
            old_table.add_column("Name / ID", style="rp_iris")
            old_table.add_column("ID", style="subtle")
            for i, (cid, cname) in enumerate(old_list):
                old_table.add_row(str(i + 1), cname, cid)
            self.console.print(old_table)
            old_choice = IntPrompt.ask(
                f"Select OLD (1-{len(old_list)})",
                choices=[str(i) for i in range(1, len(old_list) + 1)],
                show_choices=False,
                console=self.console,
            )
            old_cid, old_cname = old_list[old_choice - 1]
            uid = self.user_data.get("id", "") if self.user_data else None

            # Step 2: Select New
            self.console.print(
                "\nLoading current challenges for destination...", style="info"
            )
            if self.all_challenges_cache is None:
                self.console.print(
                    "Challenge cache not loaded.", style="warning"
                )
                return False
            valid_new = [
                ch
                for ch in self.all_challenges_cache
                if isinstance(ch, dict)
                and ch.get("id")
                and ch.get("id") != old_cid
                and ch.get("leader", "").get("_id") != uid
            ]
            valid_new.sort(key=lambda x: x.get("shortName", ""))
            if not valid_new:
                self.console.print(
                    "No other suitable challenges found.", style="warning"
                )
                return False
            new_table = Table(
                title="Select Destination (New)",
                box=box.ROUNDED,
                border_style="rp_foam",
            )
            new_table.add_column("Num", style="subtle", width=4)
            new_table.add_column("Name", style="rp_iris")
            new_table.add_column("Leader", style="subtle")
            new_table.add_column("ID", style="subtle")
            for i, ch in enumerate(valid_new):
                ldr = ch.get("leader", {}).get("profile", {}).get("name", "?")
                new_table.add_row(
                    str(i + 1), ch.get("shortName", "N/A"), ldr, ch["id"]
                )
            self.console.print(new_table)
            new_choice = IntPrompt.ask(
                f"Select NEW (1-{len(valid_new)})",
                choices=[str(i) for i in range(1, len(valid_new) + 1)],
                show_choices=False,
                console=self.console,
            )
            new_ch = valid_new[new_choice - 1]
            new_cid, new_cname = new_ch["id"], new_ch.get(
                "shortName", new_ch["id"]
            )

            # Step 3: Confirm
            self.console.print(
                f"\nSource: [rp_iris]'{old_cname}'[/] ([subtle]{old_cid}[/])"
            )
            self.console.print(
                f"Destination: [rp_iris]'{new_cname}'[/] ([subtle]{new_cid}[/])"
            )
            if not Confirm.ask(
                "Confirm selection?", default=True, console=self.console
            ):
                return False

            # Step 4: Get Tasks
            self.console.print(
                f"Gathering OLD tasks for '{old_cname}'...", style="info"
            )
            old_tasks = [
                t
                for t in self.processed_tasks.values()
                if t.get("challenge_id") == old_cid
            ]
            if not old_tasks:
                self.console.print(
                    "Warning: No tasks found for OLD challenge.",
                    style="warning",
                )
            # Allow continue?

            self.console.print(
                f"Gathering NEW tasks for '{new_cname}'...", style="info"
            )
            new_tasks = [
                t
                for t in self.processed_tasks.values()
                if t.get("challenge_id") == new_cid
            ]
            self.console.print(
                f"Found {len(old_tasks)} old, {len(new_tasks)} new tasks.",
                style="info",
            )
            if not new_tasks:
                self.console.print(
                    "No tasks found for NEW challenge. Cannot proceed.",
                    style="error",
                )
                return False

            # Step 5: Filter Type (Optional)

            # Step 6: Match Tasks
            sim_thresh = 0.80
            matched: list[Tuple[Dict, Dict]] = []
            # List of (old_task, new_task) tuples
            matched_new_ids: Set[str] = set()
            # Track matched new tasks to avoid duplicates
            self.console.print(
                f"Matching tasks (> {sim_thresh * 100:.0f}% similarity)...",
                style="info",
            )

            # --- START: INSERTED FUZZY MATCHING LOOP ---

            # Use track for progress indication if task lists are large
            for old_task in track(
                old_tasks,
                description="Comparing tasks...",
                # Progress bar description
                console=self.console,
                total=len(old_tasks),
                transient=True,
                # Make bar disappear after loop
            ):
                best_match_new_task = None
                highest_ratio = 0.0
                old_text = old_task.get("text", "")
                old_id = old_task.get("id")
                # Needed for debugging maybe

                if not old_text or not old_id:

                    # self.console.log(f"Skipping old task due to missing text/ID: {old_task}", style="subtle")
                    continue
                # Skip old tasks without text or ID

                # Compare against all potentially available new tasks
                for new_task in new_tasks:
                    new_id = new_task.get("id")
                    new_text = new_task.get("text", "")

                    # Skip new tasks already matched or without text/ID
                    if not new_id or new_id in matched_new_ids or not new_text:
                        continue

                    # --- Calculate Similarity ---

                    # SequenceMatcher is good for finding similar sequences

                    # You could also explore other libraries like fuzzywuzzy or rapidfuzz if needed

                    # but difflib is built-in.
                    matcher = difflib.SequenceMatcher(
                        None, old_text, new_text, autojunk=False
                    )
                    ratio = matcher.ratio()
                    # Get similarity ratio (0.0 to 1.0)

                    # --- Check if this is the best match found *so far* for this *old_task* ---
                    if ratio > highest_ratio and ratio >= sim_thresh:
                        highest_ratio = ratio
                        best_match_new_task = new_task
                # Store the potential best match

                # After checking all new tasks for the current old_task:
                if best_match_new_task:

                    # We found a suitable match above the threshold
                    matched.append((old_task, best_match_new_task))

                    # Mark the new task as used so it can't be matched again
                    matched_new_ids.add(best_match_new_task["id"])

            # --- END: INSERTED FUZZY MATCHING LOOP ---

            if not matched:
                self.console.print("No matching tasks found.", style="warning")
                return False
            self.console.print(f"Found {len(matched)} potential pairs:")
            for old, new in matched:
                ratio = difflib.SequenceMatcher(
                    None, old.get("text", ""), new.get("text", "")
                ).ratio()
                self.console.print(
                    f"  - '[subtle]{old.get('text', 'N/A')}[/]' -> '[rp_iris]{new.get('text', 'N/A')}[/]' ({ratio:.1%})"
                )
            if not Confirm.ask(
                "Proceed replicating attributes/tags?",
                default=True,
                console=self.console,
            ):
                return False

            # === Step 7: Apply Attributes & Tags ===
            self.console.print("Applying attributes and tags...", style="info")
            errors = 0

            # Use track for progress feedback during API calls
            for old, new in track(
                matched,
                description="Syncing attributes/tags...",
                console=self.console,
                total=len(matched),
                transient=True,
            ):

                # Extract IDs and attributes

                # Corrected variable names
                new_id = new["id"]
                old_attr = old.get("attribute", "str")
                cur_attr = new.get("attribute", "str")
                if old_attr != cur_attr:
                    try:
                        self.api_client.set_attribute(new_id, old_attr)
                    except Exception as e:
                        self.console.print(
                            f"Error setting attr: {e}", style="error"
                        )
                        errors += 1
                old_tags = old.get("tags", [])
                tags_to_add = [t for t in old_tags if t != old_cid]
                # Filter out old challenge tag
                cur_new_tags = set(new.get("tags", []))
                for tag_id in tags_to_add:
                    if tag_id not in cur_new_tags:
                        try:
                            self.api_client.add_tag_to_task(new_id, tag_id)
                            time.sleep(0.05)
                        except Exception as e:
                            if "already has the tag" not in str(e).lower():
                                self.console.print(
                                    f"Error adding tag {tag_id}: {e}",
                                    style="error",
                                )
                                errors += 1
            self.console.print(
                "Attribute/tag replication finished.", style="info"
            )
            if errors > 0:
                self.console.print(
                    f"Completed with {errors} errors.", style="warning"
                )
            should_refresh = True

            # === Step 8: Apply Position (Optional & Slow) ===
            if Confirm.ask(
                "\nAttempt to replicate task order? ([warning]SLOW[/])",
                default=False,
                console=self.console,
            ):
                task_type_filter = None
                if Confirm.ask(
                    "Replicate for [highlight]Dailies only[/]?",
                    default=True,
                    console=self.console,
                ):
                    task_type_filter = "daily"
                    old_tasks = [
                        t for t in old_tasks if t.get("_type") == "daily"
                    ]
                    new_tasks = [
                        t for t in new_tasks if t.get("_type") == "daily"
                    ]
                    self.console.print(
                        f"Filtered to {len(old_tasks)} old, {len(new_tasks)} new dailies.",
                        style="info",
                    )
                if not old_tasks or not new_tasks:
                    self.console.print(
                        "No matching types after filtering.", style="warning"
                    )
                    return False
                self.console.print(
                    "Determining original task order...", style="info"
                )

                # Create map of {old_task_id: original_index} from the filtered old_tasks list
                old_task_order_map = {
                    task["id"]: i
                    for i, task in enumerate(old_tasks)
                    if isinstance(task, dict) and task.get("id")
                }

                # Sort the *matched* new task IDs based on the original order of their old counterparts
                def sort_key(match_tuple: Tuple[Dict, Dict]):
                    old_task_id = match_tuple[0].get("id")
                    return old_task_order_map.get(old_task_id, float("inf"))

                # Place unmatched last

                sorted_matched_tasks = sorted(matched, key=sort_key)

                # Extract the new task IDs in the desired final order
                desired_new_task_order_ids = [
                    new_task["id"]
                    for old_task, new_task in sorted_matched_tasks
                    if isinstance(new_task, dict) and new_task.get("id")
                ]

                if not desired_new_task_order_ids:
                    self.console.print(
                        "Could not determine desired task order.",
                        style="warning",
                    )
                else:
                    num_to_move = len(desired_new_task_order_ids)

                    # Estimate time using the actual request interval from the API client
                    est_time_secs = num_to_move * (
                        self.api_client.request_interval + 0.1
                    )
                    # Add small buffer
                    self.console.print(
                        f"Will move {num_to_move} tasks to replicate order."
                    )
                    self.console.print(
                        f"[warning]Estimated time: ~{est_time_secs:.1f} seconds due to API rate limits.[/warning]"
                    )

                    if Confirm.ask(
                        "Proceed with moving tasks?",
                        default=True,
                        console=self.console,
                    ):
                        move_errors = 0

                        # Move tasks to the top (position 0) one by one, IN REVERSE of the desired final order

                        # This ensures they end up in the correct order at the top.
                        for task_id_to_move in track(
                            reversed(desired_new_task_order_ids),
                            description="Moving tasks to position 0...",
                            console=self.console,
                            total=num_to_move,
                            transient=True,
                        ):
                            try:
                                self.api_client.move_task_to_position(
                                    task_id_to_move, 0
                                )

                            # Rate limiting is handled automatically by api_client._wait_for_rate_limit
                            except Exception as e:

                                # Use print within track context
                                self.console.print(
                                    f"\n[error]Error moving task {task_id_to_move}: {e}[/]"
                                )
                                move_errors += 1

                        self.console.print(
                            "Task moving finished.", style="info"
                        )
                        if move_errors > 0:
                            self.console.print(
                                f"Completed moving with {move_errors} errors.",
                                style="warning",
                            )
                        should_refresh = True
                    # Order definitely changed (or errors occurred)
                    else:
                        self.console.print(
                            "Task moving cancelled.", style="info"
                        )
            else:
                self.console.print(
                    "Skipping position replication.", style="info"
                )

            # === Step 9: Cleanup (Optional Unlink Old) ===
            self.console.print(
                "\nReplication process complete.", style="success"
            )
            if old_cid and Confirm.ask(
                f"\nRemove all tasks from OLD challenge '[rp_iris]{old_cname}[/]'?",
                default=False,
                console=self.console,
            ):
                remove_permanently = Confirm.ask(
                    "Remove OLD tasks permanently? (No = Keep personal copies)",
                    default=False,
                    console=self.console,
                )
                keep_param = "remove-all" if remove_permanently else "keep-all"
                action_desc = (
                    "[error]removing permanently[/]"
                    if keep_param == "remove-all"
                    else "keeping personal copies"
                )
                if Confirm.ask(
                    f"Confirm unlinking ALL tasks from OLD challenge ({action_desc})?",
                    default=True,
                    console=self.console,
                ):
                    self.console.print(
                        f"Attempting bulk unlink for OLD challenge ({old_cid})...",
                        style="info",
                    )
                    try:

                        # Call the correct API method
                        response = self.api_client.unlink_all_challenge_tasks(
                            old_cid, keep="remove-all"
                        )
                        self.console.print(
                            f"Successfully unlinked tasks from old challenge '{old_cname}'.",
                            style="success",
                        )
                        should_refresh = False
                    except Exception as e:
                        self.console.print(
                            f"Error unlinking tasks from old challenge: {e}",
                            style="error",
                        )
                else:
                    self.console.print(
                        "Unlinking from old challenge cancelled.", style="info"
                    )
            else:
                self.console.print(
                    "Skipping cleanup of old challenge tasks.", style="info"
                )

        # ... (Confirm keep/remove, confirm unlink, call unlink_all_challenge_tasks) ...

        except (ValueError, IndexError) as e:
            self.console.print(f"Invalid selection: {e}", style="error")
        except KeyboardInterrupt:
            self.console.print("\nReplication cancelled.")
        except Exception as e:
            self.console.print(
                f"Unexpected error during replication: {e}", style="error"
            )
            self.console.print_exception(show_locals=False)
            should_refresh = False
        return should_refresh

    # MARK: - Static Helper Methods

    # & - def _get_total(...) (Keep previous implementation)
    @staticmethod
    def _get_total(task_counts: Dict) -> int:
        """Calculates total task count from the categorized counts dictionary."""
        # Re-use implementation from app_v5.txt
        total = 0
        if not isinstance(task_counts, dict):
            return 0
        try:
            for cat, data in task_counts.items():
                if isinstance(data, dict):
                    total += sum(
                        v
                        for k, v in data.items()
                        if isinstance(v, int) and not k.startswith("_")
                    )
                elif isinstance(data, int):
                    total += data
        except Exception as e:
            console.log(
                f"Error calculating total task count: {e}", style="warning"
            )
            return -1
        return total

# MARK: - Entry Point (Example for running the CLI)

# Typically lives in project root, e.g., main.py or run_pixabit.py

# if **name** == "**main**":

# try:

# app = CliApp()

# app.run()

# except KeyboardInterrupt:

# console.print("\n[bold yellow]Ctrl+C detected. Exiting Pixabit.[/bold yellow]")

# sys.exit(0)

# except Exception as e:

#

# Use console for final error display if available

# try: from pixabit.utils.display import console

# except ImportError: console = None

# if console:

# console.print(f"\n[error]An unexpected critical error occurred:[/error]")

# console.print_exception(show_locals=True, word_wrap=False)

# else:

# import traceback

# print(f"\nAn unexpected critical error occurred: {e}")

# traceback.print_exc()

# sys.exit(1)

--- END OF FILE cli/app.py ---

--- START OF FILE cli/challenge_backupper.py ---

# pixabit/challenge_backupper.py

# MARK: - MODULE DOCSTRING

"""Provides the ChallengeBackupper class for backing up Habitica challenges.

Fetches challenges and tasks, processes them (cleans tasks, handles emojis),
and saves each challenge with its tasks as an individual JSON file using
sanitized filenames.
"""

# MARK: - IMPORTS

from pathlib import Path
from typing import Dict, Optional, Tuple, Union

import emoji_data_python
import requests

# For specific API error handling

from pathvalidate import sanitize_filename

from ..utils.display import console

# Use themed display

from ..utils.save_json import save_json

# For creating safe filenames

# Local Imports

from .api import HabiticaAPI

# Use shared save utility

# MARK: - CLASS DEFINITION

class ChallengeBackupper:
"""Handles fetching Habitica challenges, processing tasks, and saving backups."""

    # Keys to remove from task data for a cleaner, more reusable backup
    TASK_KEYS_TO_REMOVE: list[str] = [
        "history",
        "completed",
        "isDue",
        "nextDue",
        "yesterDaily",
        "streak",
        "userId",
        "updatedAt",
        "createdAt",
        # Keep 'group', 'byHabitica', 'challenge' for context? Decide based on backup goal.
        # Let's keep them for now unless they cause issues.
    ]

    # & - def __init__(self, api_client: HabiticaAPI):
    def __init__(self, api_client: HabiticaAPI):
        """Initializes the ChallengeBackupper."""
        if not isinstance(api_client, HabiticaAPI):
            raise TypeError("`api_client` must be an instance of HabiticaAPI")
        self.api_client: HabiticaAPI = api_client
        self.console = console
        # Use themed console
        self.console.log("ChallengeBackupper initialized.", style="info")

    # --- Public Method ---

    # & - def create_backups(...)
    def create_backups(
        self, output_folder: Union[str, Path] = "_challenge_backups"
    ) -> None:
        """Executes the full challenge backup process."""
        self.console.print("\nğŸš€ Starting challenge backup process...")
        saved_count, failed_count = 0, 0
        output_path = Path(output_folder)

        try:

            # --- Fetch Data ---
            self.console.print(
                "â³ Fetching challenges and tasks from Habitica API..."
            )
            tasks, challenges = self._fetch_data()
            if challenges is None or tasks is None:
                # Check for fetch failure
                self.console.print(
                    "âŒ Halting backup due to errors fetching data.",
                    style="error",
                )
                return
            if not challenges:
                self.console.print(
                    "â„¹ï¸ No challenges found for this user to back up.",
                    style="info",
                )
                return
            self.console.print(
                f"âœ… Fetched {len(challenges)} challenges and {len(tasks)} tasks.",
                style="success",
            )

            # --- Group Tasks ---
            tasks_by_challenge = self._group_tasks_by_challenge(tasks)

            # --- Prepare Output Dir ---
            try:
                output_path.mkdir(parents=True, exist_ok=True)
                self.console.print(
                    f"ğŸ’¾ Saving backups to folder: [file]'{output_path.resolve()}'[/]"
                )
            except OSError as io_err:
                self.console.print(
                    f"âŒ File System Error creating '{output_path}': {io_err}",
                    style="error",
                )
                return

            # --- Process & Save ---
            sorted_challenges = sorted(
                challenges, key=lambda x: str(x.get("name", "")).lower()
            )
            total_challenges = len(sorted_challenges)
            self.console.print(f"âš™ï¸ Processing {total_challenges} challenges...")

            for index, challenge_data in enumerate(sorted_challenges):
                challenge_id = challenge_data.get("id")
                original_name = challenge_data.get("name", "Unnamed_Challenge")
                short_name = challenge_data.get("shortName") or original_name
                # Fallback

                progress_prefix = f"({index + 1}/{total_challenges})"
                self.console.print(
                    f"\n{progress_prefix} Processing: [keyword]'{original_name}'[/] ([info]{challenge_id or 'N/A'}[/])"
                )

                if not challenge_id or not isinstance(challenge_data, dict):
                    self.console.print(
                        f"  âš ï¸ Skipping invalid challenge data: {challenge_data}",
                        style="warning",
                    )
                    failed_count += 1
                    continue

                associated_tasks = tasks_by_challenge.get(challenge_id, [])
                self.console.print(
                    f"  Found {len(associated_tasks)} associated task(s)."
                )

                processed_backup = self._process_single_challenge(
                    challenge_data, associated_tasks
                )

                # Generate safe filename
                safe_base = sanitize_filename(str(short_name))
                if not safe_base:
                    safe_base = (
                        f"challenge_{challenge_id}"
                        # Fallback if name was all invalid chars
                    )
                filename = f"{safe_base}.json"
                filepath = output_path / filename

                # Save using utility
                if save_json(data=processed_backup, filepath=filepath):
                    saved_count += 1
                else:
                    failed_count += 1
            # save_json already prints errors

            # --- Final Summary ---
            self.console.rule(style="rp_overlay")
            if failed_count == 0:
                self.console.print(
                    f"[success]âœ… Backup complete. Saved {saved_count}/{total_challenges} challenges.[/success]"
                )
            else:
                self.console.print(
                    f"[warning]âš ï¸ Backup complete. Saved: {saved_count}, Failed/Skipped: {failed_count} (Total: {total_challenges}).[/warning]"
                )
            self.console.rule(style="rp_overlay")

        except Exception as e:
            self.console.print(
                f"\n[error]âŒ Unexpected error during challenge backup: {e}[/error]"
            )

    # self.console.print_exception(show_locals=False)
    # Optional traceback

    # --- Internal Helper Methods ---

    # & - def _fetch_data(...)
    def _fetch_data(self) -> Tuple[Optional[list[Dict]], Optional[list[Dict]]]:
        """Fetches all user tasks and member challenges. Returns (tasks, challenges) or (None, None) on error."""
        tasks, challenges = None, None
        try:
            self.console.print("  Fetching all user tasks...")
            tasks = self.api_client.get_tasks()
            if not isinstance(tasks, list):
                self.console.print(
                    f"API Error: Expected list of tasks, got {type(tasks)}.",
                    style="error",
                )
                tasks = None
            # Signal error
            else:
                self.console.print(f"  Fetched {len(tasks)} tasks.")

            self.console.print("  Fetching member challenges...")
            challenges = self.api_client.get_challenges(member_only=True)
            if not isinstance(challenges, list):
                self.console.print(
                    f"API Error: Expected list of challenges, got {type(challenges)}.",
                    style="error",
                )
                challenges = None
            # Signal error
            else:
                self.console.print(f"  Fetched {len(challenges)} challenges.")

            return tasks, challenges

        except requests.exceptions.RequestException as api_err:
            self.console.print(
                f"API Connection Error fetching data: {api_err}", style="error"
            )
            return None, None
        except Exception as e:
            self.console.print(
                f"Unexpected Error fetching data: {e}", style="error"
            )
            return None, None

    # & - def _group_tasks_by_challenge(...)
    def _group_tasks_by_challenge(
        self, tasks: Optional[list[Dict]]
    ) -> dict[str, list[Dict]]:
        """Groups tasks by challenge ID. Returns {challenge_id: [tasks]}."""
        self.console.print("  Grouping tasks by challenge ID...")
        tasks_by_challenge: dict[str, list[Dict]] = {}
        if not isinstance(tasks, list):
            self.console.print(
                "Task list invalid for grouping. Returning empty map.",
                style="warning",
            )
            return {}

        processed_count, linked_count = 0, 0
        for task in tasks:
            if not isinstance(task, dict):
                continue
            processed_count += 1
            challenge = task.get("challenge")
            if isinstance(challenge, dict):
                c_id = challenge.get("id")
                if c_id and isinstance(c_id, str):
                    tasks_by_challenge.setdefault(c_id, []).append(task)
                    linked_count += 1
        self.console.print(
            f"  Processed {processed_count} tasks. Found {linked_count} linked to {len(tasks_by_challenge)} challenges."
        )
        return tasks_by_challenge

    # & - def _clean_task_for_backup(...)
    def _clean_task_for_backup(self, task_data: Dict) -> Dict:
        """Removes transient keys and processes emojis for task backup."""
        if not isinstance(task_data, dict):
            return {"error": "Invalid task data"}
        cleaned = task_data.copy()
        for key in self.TASK_KEYS_TO_REMOVE:
            cleaned.pop(key, None)
        if "text" in cleaned:
            cleaned["text"] = emoji_data_python.replace_colons(
                str(cleaned.get("text", ""))
            )
        if "notes" in cleaned:
            cleaned["notes"] = emoji_data_python.replace_colons(
                str(cleaned.get("notes", ""))
            )

        # Clean checklist items too
        if "checklist" in cleaned and isinstance(cleaned["checklist"], list):
            for item in cleaned["checklist"]:
                if isinstance(item, dict) and "text" in item:
                    item["text"] = emoji_data_python.replace_colons(
                        str(item.get("text", ""))
                    )
        return cleaned

    # & - def _process_single_challenge(...)
    def _process_single_challenge(
        self, challenge_data: Dict, tasks_raw: list[Dict]
    ) -> Dict:
        """Processes a single challenge and its tasks into backup format."""
        backup = challenge_data.copy()
        backup["_tasks"] = [
            self._clean_task_for_backup(task) for task in tasks_raw
        ]
        # Embed cleaned tasks

        # Process text fields
        name = backup.pop("name", "Unnamed")
        desc = backup.pop("description", "")
        summary = backup.pop("summary", "")
        backup["_name"] = emoji_data_python.replace_colons(str(name))
        backup["_description"] = emoji_data_python.replace_colons(str(desc))
        if summary:
            backup["_summary"] = emoji_data_python.replace_colons(str(summary))
        return backup

--- END OF FILE cli/challenge_backupper.py ---

--- START OF FILE cli/config_auth.py ---

# pixabit/config_auth.py

# MARK: - MODULE DOCSTRING

"""Manages the creation and verification of the application's .env configuration file
specifically for MANDATORY credentials (Habitica User ID, API Token).

Provides functions to interactively create a `.env` file using prompts and
confirmations from the Rich library (via the `utils.display` helper module).
Includes `check_env_file` to verify existence and trigger creation if missing.
"""

# MARK: - IMPORTS

import datetime
import sys
from pathlib import Path

# Use themed display components

try:
from .utils.display import Confirm, Prompt, console, print
except ImportError: # Fallback for potential direct script execution or import issues
import builtins

    print = builtins.print

    # Define dummy components if Rich is not available
    def Prompt_ask(prompt, **kwargs):
        return input(prompt)

    def Confirm_ask(prompt, **kwargs):
        return input(f"{prompt} [y/N]: ").lower() == "y"

    class DummyConsole:
        def print(self, *args, **kwargs):
            builtins.print(*args)

        def log(self, *args, **kwargs):
            builtins.print(*args)

    console = DummyConsole()
    Prompt = type("DummyPrompt", (), {"ask": staticmethod(Prompt_ask)})()
    Confirm = type("DummyConfirm", (), {"ask": staticmethod(Confirm_ask)})()

# MARK: - CONSTANTS

# (No specific constants needed here, path is passed in)

# MARK: - CORE FUNCTIONS

# & - def create_env_file(env_path: Path) -> bool:

def create_env_file(env_path: Path) -> bool:
"""Interactively creates or overwrites mandatory credentials in a .env file.

    Prompts for Habitica User ID and API Token. Confirms overwrite.
    Creates file with placeholders if interactive help is declined.

    Args:
        env_path: The Path object for the .env file.

    Returns:
        bool: True if the file was created/updated successfully, False otherwise.
    """
    filename_display = f"[file]{env_path.name}[/]"
    filepath_display = f"[file]{env_path}[/]"
    interactive_mode = False
    # Track if user actively provided credentials

    # --- 1. Check overwrite ---
    if env_path.exists():
        console.print(f"[warning]File {filename_display} exists.[/warning]")
        if not Confirm.ask(
            f"Overwrite MANDATORY credentials (User ID, API Token) in {filename_display}?",
            default=False,
        ):
            console.print(
                f"[info]â„¹ï¸ Keeping existing mandatory credentials in {filename_display}. Optional tags can be configured separately.[/info]"
            )
            return True
    # File exists and user chose not to modify essentials

    # --- 2. Get User Input ---
    console.print(
        f"\nâš™ï¸ Setting up MANDATORY credentials in {filename_display}."
    )
    if Confirm.ask(
        "Provide credentials now? (Choose No to create placeholders)",
        default=True,
    ):
        interactive_mode = True
        # User chose interactive setup
        console.print(
            "\n[bold yellow]ğŸ”‘ Enter Habitica API Credentials[/bold yellow]"
            "\n[dim](Find at: https://habitica.com/user/settings/api)[/dim]"
        )
        input_userid = ""
        while not input_userid or input_userid == "YOUR_HABITICA_USER_ID_HERE":
            input_userid = Prompt.ask(
                "  Enter your [info]Habitica User ID[/info]",
                default="YOUR_HABITICA_USER_ID_HERE",
            )
            if not input_userid or input_userid == "YOUR_HABITICA_USER_ID_HERE":
                console.print(
                    "[error]User ID cannot be empty or the placeholder.[/error]"
                )
                if not Confirm.ask("Try again?", default=True):
                    input_userid = "YOUR_HABITICA_USER_ID_HERE"
                    # Reset to placeholder
                    console.print(
                        "[warning]Creating file with placeholder User ID.[/warning]"
                    )
                    interactive_mode = False
                    # Switched to placeholder mode
                    break
        # Exit loop, use placeholder

        input_apitoken = ""

        # Only ask for token if we successfully got a real User ID in interactive mode
        if interactive_mode and input_userid != "YOUR_HABITICA_USER_ID_HERE":
            while not input_apitoken or input_apitoken == "YOUR_API_TOKEN_HERE":
                input_apitoken = Prompt.ask(
                    "  Enter your [info]Habitica API Token[/info]",
                    default="YOUR_API_TOKEN_HERE",
                    password=True,
                )
                if (
                    not input_apitoken
                    or input_apitoken == "YOUR_API_TOKEN_HERE"
                ):
                    console.print(
                        "[error]API Token cannot be empty or the placeholder.[/error]"
                    )
                    if not Confirm.ask("Try again?", default=True):
                        input_apitoken = "YOUR_API_TOKEN_HERE"
                        # Reset to placeholder
                        console.print(
                            "[warning]Creating file with placeholder API Token.[/warning]"
                        )
                        interactive_mode = False
                        # Switched to placeholder mode
                        break
        # Exit loop, use placeholder

        elif interactive_mode:
            # User ID is placeholder, so token must be too
            input_apitoken = "YOUR_API_TOKEN_HERE"
            interactive_mode = False
    # No longer truly interactive

    else:
        # User chose No for interactive help initially
        console.print(
            "\nCreating file with placeholder values for manual editing."
        )
        input_userid = "YOUR_HABITICA_USER_ID_HERE"
        input_apitoken = "YOUR_API_TOKEN_HERE"
        interactive_mode = False

    # --- 3. Build Content ---
    timestamp = datetime.datetime.now(datetime.timezone.utc).isoformat()
    env_content = f"""

# Habitica Credentials (MANDATORY)

# Generated by pixabit setup script on {timestamp}

# Find these values at: https://habitica.com/user/settings/api

HABITICA_USER_ID="{input_userid}"
HABITICA_API_TOKEN="{input_apitoken}"

# --- Optional Tag IDs (Configure via 'pixabit setup-tags' or manually) ---

# CHALLENGE_TAG_ID=""

# PERSONAL_TAG_ID=""

# PSN_TAG_ID=""

# NOT_PSN_TAG_ID=""

# NO_ATTR_TAG_ID=""

# ATTR_TAG_STR_ID=""

# ATTR_TAG_INT_ID=""

# ATTR_TAG_CON_ID=""

# ATTR_TAG_PER_ID=""

""".strip()

    # --- 4. Write File ---
    try:
        env_path.parent.mkdir(parents=True, exist_ok=True)
        with env_path.open("w", encoding="utf-8") as envfile:
            envfile.write(env_content + "\n")

        console.print(
            f"\n[success]âœ… Mandatory credentials saved/updated in {filepath_display}.[/success]"
        )

        # Use the interactive_mode flag to give appropriate next steps
        if (
            not interactive_mode
            or input_userid == "YOUR_HABITICA_USER_ID_HERE"
            or input_apitoken == "YOUR_API_TOKEN_HERE"
        ):
            console.print(
                f"[warning]âš ï¸ Remember to manually edit {filename_display} and replace placeholder values if needed.[/warning]"
            )
        else:
            console.print(
                "[info]â„¹ï¸ You can now configure optional tags if desired (e.g., `pixabit setup-tags`).[/info]"
            )

        console.print(
            f"[warning]ğŸ”’ IMPORTANT:[/warning] Ensure {filename_display} is in `.gitignore`!"
        )
        return True
    # File written successfully

    except OSError as e:
        console.print(
            f"[error]âŒ Error writing file {filepath_display}: {e}[/error]"
        )
        return False
    except Exception as e:
        console.print(
            f"[error]âŒ Unexpected error writing {filepath_display}: {e}[/error]"
        )
        return False

# MARK: - HELPER ENTRY FUNCTION

# & - def check_env_file(env_path: Path) -> None:

def check_env_file(env_path: Path) -> None:
"""Checks if the .env file exists and prompts for creation if missing. Exits if creation fails or is skipped.

    Args:
        env_path: Path object for the .env file.
    """
    filename_display = f"[file]{env_path.name}[/]"
    filepath_display = f"[file]{env_path}[/]"

    console.log(f"âŒ› Checking for configuration file: {filepath_display}")
    if not env_path.exists():
        console.print(
            f"[warning]âš ï¸ File {filename_display} not found.[/warning]"
        )
        if Confirm.ask(
            f"\nCreate the {filename_display} configuration file now? (Needed for credentials)",
            default=True,
        ):
            if not create_env_file(env_path):
                # Call creation function
                console.print(
                    "[error]âŒ Failed to create .env file. Application cannot continue.[/error]"
                )
                sys.exit(1)
        # Exit if creation failed
        else:
            console.print(
                f"[error]âŒ Skipping {filename_display} creation. Application requires credentials and cannot continue.[/error]"
            )
            sys.exit(1)
    # Exit if user skips creation
    else:
        console.print(
            f"[success]âœ… Configuration file {filename_display} found at {filepath_display}.[/success]"
        )

--- END OF FILE cli/config_auth.py ---

--- START OF FILE cli/config_tags.py ---

# pixabit/config_tags.py

# MARK: - MODULE DOCSTRING

"""Provides functionality for interactively setting up OPTIONAL Tag IDs in the .env file.

Fetches existing tags, displays them, groups configuration by feature, and allows
users to select, create, keep existing, or skip/unset tags for predefined roles.
Saves changes back to the .env file using python-dotenv utilities.
"""

# MARK: - IMPORTS

import os
from pathlib import Path
from typing import Any, Optional, Set, Union

# Added set

import requests

# For API exceptions

# Use specific dotenv functions

from dotenv import find_dotenv, get_key, set_key, unset_key

# Use themed display components

from ..utils.display import (
Confirm,
Prompt,
Rule,
Table,
box,
console, # Added Rule
)

# Local Imports

from .api import HabiticaAPI

# MARK: - CONSTANTS

# Group tag configurations logically for prompting

TAG_CONFIG_GROUPS: dict[str, dict[str, str]] = {
"Challenge/Personal": {
"Challenge Tag (for challenge tasks)": "CHALLENGE_TAG_ID",
"Personal Tag (for non-challenge tasks)": "PERSONAL_TAG_ID",
},
"Poison Status": {
"Poisoned Tag (e.g., for poison challenge)": "PSN_TAG_ID",
"Not Poisoned Tag (default status)": "NOT_PSN_TAG_ID",
},
"Attributes": {
"No Attribute Tag (tasks w/o STR/INT/...)": "NO_ATTR_TAG_ID",
"Strength Attribute Tag": "ATTR_TAG_STR_ID",
"Intelligence Attribute Tag": "ATTR_TAG_INT_ID",
"Constitution Attribute Tag": "ATTR_TAG_CON_ID",
"Perception Attribute Tag": "ATTR_TAG_PER_ID",
}, # Add other logical groups here if needed
}

# Flattened map for easier lookup later

ALL_TAG_CONFIG_KEYS: dict[str, str] = {
desc: key
for group in TAG_CONFIG_GROUPS.values()
for desc, key in group.items()
}

# MARK: - CORE FUNCTION

# & - def interactive_tag_setup(api_client: HabiticaAPI, dotenv_path: Union[str, Path]) -> None:

def interactive_tag_setup(
api_client: HabiticaAPI, dotenv_path: Union[str, Path]
) -> None:
"""Interactively configures OPTIONAL tag IDs in the .env file, grouped by feature.

    Args:
        api_client: Authenticated HabiticaAPI client.
        dotenv_path: Path to the .env file.
    """
    console.print(
        "\n--- Interactive Optional Tag Configuration ---",
        style="highlight",
        justify="center",
    )
    console.print(
        "Configure Tag IDs for optional features. Skip groups or individual tags if unused."
    )
    console.print(
        f"Using configuration file: [file]'{dotenv_path}'[/]", style="info"
    )

    dotenv_path_str = str(dotenv_path)
    # Ensure string for dotenv functions

    # --- Step 1: Fetch existing tags ---
    all_tags: list[dict[str, Any]] = []
    try:
        console.print("â³ Fetching tags from Habitica...", style="info")
        fetched_tags = api_client.get_tags()
        if not isinstance(fetched_tags, list):
            raise TypeError(f"Expected list of tags, got {type(fetched_tags)}")
        all_tags = fetched_tags
        all_tags.sort(key=lambda t: t.get("name", "").lower())
        console.print(
            f"âœ… Found {len(all_tags)} existing tags.", style="success"
        )
    except (requests.exceptions.RequestException, TypeError, Exception) as e:
        console.print(f"âŒ Error fetching tags: {e}", style="error")
        console.print("Cannot proceed without tag list.")
        return

    # --- Step 2: Prepare and Display Tags ---
    valid_tags_for_selection = [
        tag for tag in all_tags if isinstance(tag, dict) and tag.get("id")
    ]
    num_tags_selectable = len(valid_tags_for_selection)

    table = Table(
        title="Available Habitica Tags",
        show_lines=True,
        box=box.ROUNDED,
        border_style="rp_overlay",
    )
    table.add_column("Num", style="subtle", width=4, justify="right")
    table.add_column("Name", style="rp_foam", max_width=40)
    table.add_column("ID", style="rp_rose", no_wrap=True)

    if not valid_tags_for_selection:
        table.add_row(
            "...", "[dim]No existing selectable tags found[/dim]", "..."
        )
    else:
        for i, tag in enumerate(valid_tags_for_selection):
            table.add_row(
                str(i + 1), tag.get("name", "[dim]N/A[/dim]"), tag.get("id")
            )
    console.print(table)
    if not valid_tags_for_selection:
        console.print(
            "âš ï¸ You will need to use 'Create New' or 'Skip' for all tags.",
            style="warning",
        )

    # --- Step 3: Prompt User for Each Tag GROUP ---
    selected_ids: dict[str, Optional[str]] = {}
    # Store {env_key: tag_id or None}
    keys_to_unset: Set[str] = set()
    # Track keys currently in .env that user skips

    for group_name, tags_in_group in TAG_CONFIG_GROUPS.items():
        console.print(
            Rule(
                f"[highlight]Configure {group_name} Tags[/]", style="rp_overlay"
            )
        )

        # Ask to configure this group
        if not Confirm.ask(
            f"set up tags for '{group_name}' feature?", default=True
        ):
            console.print(
                f"â­ï¸ Skipping configuration for {group_name} tags.", style="info"
            )

            # Mark existing keys in this group for potential removal
            for env_key in tags_in_group.values():
                if get_key(dotenv_path_str, env_key) is not None:
                    keys_to_unset.add(env_key)
                selected_ids[env_key] = None
            # Mark as not configured in this run
            continue
        # Skip to next group

        # Configure tags within this group
        for tag_description, env_key in tags_in_group.items():
            console.print(
                f"\n-- Tag: [highlight]{tag_description}[/] ([dim]Variable: {env_key}[/]) --"
            )
            current_value_id = get_key(dotenv_path_str, env_key)
            current_display_name = "[dim i]Not Set[/dim i]"
            current_tag_name = None
            # Store name if found
            if current_value_id:
                current_tag = next(
                    (
                        t
                        for t in all_tags
                        if isinstance(t, dict)
                        and t.get("id") == current_value_id
                    ),
                    None,
                )
                if current_tag:
                    current_tag_name = current_tag.get(
                        "name", "[dim]Unknown[/dim]"
                    )
                    current_display_name = f" '[rp_foam]{current_tag_name}[/]' ([rp_rose]{current_value_id}[/])"
                else:
                    current_display_name = f" ID [rp_rose]{current_value_id}[/] ([warning]Tag no longer exists![/warning])"

            tag_configured_successfully = False
            while not tag_configured_successfully:
                try:

                    # --- Build Prompt ---
                    prompt_options_list = []
                    valid_choices_numeric = []
                    if num_tags_selectable > 0:
                        prompt_options_list.append(
                            f"[bold]1[/]-[bold]{num_tags_selectable}[/] Select"
                        )
                        valid_choices_numeric.extend(
                            range(1, num_tags_selectable + 1)
                        )
                    prompt_options_list.append("[bold]0[/] Create")
                    valid_choices_numeric.append(0)
                    if current_value_id:
                        prompt_options_list.append("[bold]-1[/] Keep Current")
                        valid_choices_numeric.append(-1)
                    prompt_options_list.append("[bold]S[/] Skip/Unset")
                    valid_choices_str = [
                        str(n) for n in valid_choices_numeric
                    ] + ["s", "S"]

                    prompt_text = (
                        f"Action for '[highlight]{tag_description}[/]':\n"
                        f"[dim]Options: {', '.join(prompt_options_list)} | Current: {current_display_name}[/dim]\n"
                        f"Enter choice: "
                    )

                    choice_str = Prompt.ask(
                        prompt_text,
                        choices=valid_choices_str,
                        show_choices=False,
                    ).strip()

                    # --- Handle Choice ---
                    if choice_str.lower() == "s":
                        selected_ids[env_key] = None
                        # Explicitly mark as not set
                        if current_value_id:
                            keys_to_unset.add(env_key)
                        # Mark for removal
                        console.print(
                            f"  â­ï¸ Skipping/Unsetting '{tag_description}'.",
                            style="info",
                        )
                        tag_configured_successfully = True
                    elif choice_str == "-1" and current_value_id:
                        selected_ids[env_key] = current_value_id
                        # Keep existing value
                        if env_key in keys_to_unset:
                            keys_to_unset.remove(env_key)
                        # Don't unset if kept
                        console.print(
                            f"  â¡ï¸ Keeping current value {current_display_name}.",
                            style="info",
                        )
                        tag_configured_successfully = True
                    elif choice_str.isdigit() or (
                        choice_str.startswith("-") and choice_str[1:].isdigit()
                    ):
                        choice = int(choice_str)
                        if 1 <= choice <= num_tags_selectable:
                            selected_tag = valid_tags_for_selection[choice - 1]
                            tag_id = selected_tag.get("id")
                            tag_name = selected_tag.get(
                                "name", "[dim]N/A[/dim]"
                            )
                            if tag_id:
                                selected_ids[env_key] = tag_id
                                if env_key in keys_to_unset:
                                    keys_to_unset.remove(env_key)
                                console.print(
                                    f"  âœ… Selected '[rp_foam]{tag_name}[/]' ([rp_rose]{tag_id}[/]).",
                                    style="success",
                                )
                                tag_configured_successfully = True
                            else:
                                console.print(
                                    "âŒ Internal Error: Selected tag missing ID.",
                                    style="error",
                                )
                        elif choice == 0:
                            # Create New Tag
                            default_name = (
                                tag_description.split("(")[0]
                                .strip()
                                .replace(" ", "_")
                                .replace("/", "-")
                            )
                            new_name = Prompt.ask(
                                f"Enter name for new '{tag_description}' tag:",
                                default=default_name,
                            ).strip()
                            if not new_name:
                                console.print(
                                    "âš ï¸ Creation cancelled (no name).",
                                    style="warning",
                                )
                                continue
                            # Re-prompt for this tag
                            if Confirm.ask(
                                f"Create new Habitica tag named '[rp_foam]{new_name}[/]'?"
                            ):
                                try:
                                    console.print(
                                        f"  â³ Creating tag '[rp_foam]{new_name}[/]' via API...",
                                        style="info",
                                    )
                                    created_tag = api_client.create_tag(
                                        new_name
                                    )
                                    # Returns dict or None
                                    if (
                                        created_tag
                                        and isinstance(created_tag, dict)
                                        and created_tag.get("id")
                                    ):
                                        new_id = created_tag["id"]
                                        new_name_api = created_tag.get(
                                            "name", new_name
                                        )
                                        console.print(
                                            f"  âœ… Created '[rp_foam]{new_name_api}[/]' ID: [rp_rose]{new_id}[/]",
                                            style="success",
                                        )
                                        selected_ids[env_key] = new_id

                                        # Add to lists for potential use later in this run
                                        all_tags.append(created_tag)
                                        valid_tags_for_selection.append(
                                            created_tag
                                        )
                                        num_tags_selectable = len(
                                            valid_tags_for_selection
                                        )
                                        if env_key in keys_to_unset:
                                            keys_to_unset.remove(env_key)
                                        tag_configured_successfully = True
                                    else:
                                        console.print(
                                            f"âŒ API Error: Failed to create tag '{new_name}' or invalid response.",
                                            style="error",
                                        )
                                except (
                                    requests.exceptions.RequestException,
                                    Exception,
                                ) as create_err:
                                    console.print(
                                        f"âŒ Error creating tag '{new_name}': {create_err}",
                                        style="error",
                                    )
                            else:
                                console.print(
                                    "  Creation cancelled.", style="info"
                                )
                        else:
                            console.print(
                                "âŒ Invalid number choice.", style="error"
                            )
                    else:
                        console.print(
                            "âŒ Invalid input. Please enter a valid number or 'S'.",
                            style="error",
                        )

                except (ValueError, TypeError):
                    console.print(
                        "âŒ Invalid input. Please enter a number or 'S'.",
                        style="error",
                    )
                except Exception as e:
                    # Catch unexpected errors during prompt/handling
                    console.print(
                        f"âŒ Unexpected error configuring '{tag_description}': {e}",
                        style="error",
                    )
                    console.print_exception(show_locals=False)

                    # Decide whether to break or continue loop on unexpected error
                    break
    # Break inner loop on unexpected error

    # --- End of loop for tags within group ---

    # --- End of loop for groups ---

    # --- Step 4. Confirm Selections Before Saving ---
    console.print(
        Rule("[highlight]Review Final Tag Selections[/]", style="rp_overlay")
    )

    # active_selections = {k: v for k, v in selected_ids.items() if v is not None}
    review_table = Table(
        show_header=True,
        header_style="keyword",
        show_lines=True,
        box=box.ROUNDED,
        border_style="rp_surface",
    )
    review_table.add_column("Configuration Role", style="info", min_width=40)
    review_table.add_column("Selected Tag Name", style="rp_text")
    review_table.add_column("Selected Tag ID / Status", style="info")

    for desc, key in ALL_TAG_CONFIG_KEYS.items():
        tag_id = selected_ids.get(key)
        # Could be None if skipped group or individual tag
        if tag_id is not None:
            # Value was set or kept
            tag_info = next(
                (
                    t
                    for t in all_tags
                    if isinstance(t, dict) and t.get("id") == tag_id
                ),
                None,
            )
            tag_name = (
                f"'[rp_foam]{tag_info.get('name', '[dim]Unknown[/dim]')}[/]'"
                if tag_info
                else "[warning]MISSING TAG[/warning]"
            )
            tag_id_display = f"[rp_rose]{tag_id}[/]"
            review_table.add_row(desc, tag_name, tag_id_display)
        elif key in keys_to_unset:
            # Value existed but was explicitly unset
            review_table.add_row(
                desc, "[dim i]Will be Unset/Removed[/dim i]", "[dim]---[/dim]"
            )
        else:
            # Value was not set and didn't exist before
            review_table.add_row(
                desc, "[dim i]Not Set[/dim i]", "[dim]---[/dim]"
            )

    console.print(review_table)
    if keys_to_unset:
        console.print(
            f"âš ï¸ [warning]Will remove {len(keys_to_unset)} existing setting(s) marked as 'Unset'.[/warning]"
        )
    console.print(Rule(style="rp_overlay"))

    # --- Step 5. Save to .env File ---
    if not Confirm.ask(
        f"\nğŸ’¾ Apply these changes to [file]'{os.path.basename(dotenv_path_str)}'[/]?",
        default=True,
    ):
        console.print("ğŸš« Operation cancelled. No changes saved.", style="info")
        return

    try:
        console.print(
            f"â³ Updating '[file]{dotenv_path_str}[/]'...", style="info"
        )
        num_set, num_unset_actual = 0, 0

        # set new/kept values (only if not None)
        for key, value in selected_ids.items():
            if value is not None:
                if set_key(dotenv_path_str, key, value, quote_mode="always"):
                    num_set += 1
        # Count if set_key reports change or addition

        # Unset skipped values that previously existed
        for key in keys_to_unset:
            if unset_key(dotenv_path_str, key):
                num_unset_actual += 1
        # Count if unset_key reports success

        console.print(
            f"âœ… Successfully updated optional tag configurations: "
            f"{num_set} set/updated, {num_unset_actual} unset/removed "
            f"in [file]{os.path.basename(dotenv_path_str)}[/]!",
            style="success",
        )
        console.print(
            "â„¹ï¸ Restart the application if running for changes to take effect.",
            style="info",
        )

    except OSError as e:
        console.print(
            f"âŒ Error writing to .env file '{dotenv_path_str}': {e}",
            style="error",
        )
    except Exception as e:
        console.print(
            f"âŒ Unexpected error saving to .env file: {e}", style="error"
        )

# MARK: - CALLER FUNCTION (for CLI integration)

# & - def configure_tags() -> None:

def configure_tags() -> None:
"""Wrapper to initialize API client and run the interactive tag setup."""
console.print(
"\nğŸš€ Starting interactive optional tag configuration...", style="info"
)
dotenv_path_str = find_dotenv(raise_error_if_not_found=False, usecwd=True)
if not dotenv_path_str:

        # Attempt to find/create it relative to this file's project structure
        try:
            project_root = Path(__file__).resolve().parent.parent
            dotenv_path_candidate = project_root / ".env"
            if not dotenv_path_candidate.exists():

                # If it truly doesn't exist, user needs to run main setup first
                console.print(
                    f"âŒ '.env' file not found at expected location: [file]{dotenv_path_candidate}[/].",
                    style="error",
                )
                console.print(
                    "   Please run the main application first to set up mandatory credentials."
                )
                return
            dotenv_path_str = str(dotenv_path_candidate)
        except Exception as e:
            console.print(f"âŒ Error determining .env path: {e}", style="error")
            return

    api: Optional[HabiticaAPI] = None
    try:
        api = HabiticaAPI()
        console.print(
            "ğŸ”‘ Habitica API client initialized successfully.", style="success"
        )
    except ValueError as e:
        console.print(f"âŒ API Initialization Error: {e}", style="error")
        console.print(
            "   Cannot configure tags without valid API credentials in .env."
        )
        return
    except Exception as e:
        console.print(
            f"âŒ Unexpected Error initializing API: {e}", style="error"
        )
        return

    if api and dotenv_path_str:
        try:
            interactive_tag_setup(api, dotenv_path_str)
        except Exception as e:
            console.print(
                f"\nâŒ Error during interactive tag configuration: {e}",
                style="error",
            )
            console.print_exception(show_locals=False)
    # Show traceback for setup errors
    else:
        console.print(
            "âŒ Could not proceed: Missing API client or .env path.",
            style="error",
        )

    console.print(
        "\nğŸ Optional Tag configuration process finished.", style="info"
    )

# --- End of file ---

--- END OF FILE cli/config_tags.py ---

--- START OF FILE cli/config.py ---

# pixabit/config.py

# MARK: - MODULE DOCSTRING

"""Loads configuration settings for the Pixabit application from a .env file.

Locates `.env` (project root expected), ensures mandatory credentials exist
(using `config_auth.check_env_file`), loads variables using `python-dotenv`,
and makes settings available as constants. Exits if mandatory credentials
are missing after the check/creation step.

Constants Defined: - HABITICA*USER_ID (str): Habitica User ID (Validated). - HABITICA_API_TOKEN (str): Habitica API Token (Validated). - Optional Tag IDs (Optional[str]): CHALLENGE_TAG_ID, PERSONAL_TAG_ID,
PSN_TAG_ID, NOT_PSN_TAG_ID, NO_ATTR_TAG_ID, ATTR_TAG*\*\_ID.
"""

# MARK: - IMPORTS

import os
import sys

# For sys.exit

from pathlib import Path
from typing import Optional

# Added Dict for ATTR_TAG_MAP

from dotenv import load_dotenv

# Use themed display and auth check function

try:
from ..utils.display import console, print
from . import check_env_file
except ImportError:
import builtins

    print = builtins.print

    # Define dummy components if run standalone or during setup issues
    def check_env_file(env_path):
        pass

    class DummyConsole:
        def print(self, *args, **kwargs):
            builtins.print(*args)

        def log(self, *args, **kwargs):
            builtins.print(*args)

    console = DummyConsole()
    print("[Warning] Could not import Pixabit display/auth utils in config.py")

# MARK: - PATH CALCULATION

try:
ENV_FILE_PATH = Path(**file**).resolve().parent.parent / ".env"
except NameError:
ENV_FILE_PATH = Path(".").resolve() / ".env"
console.log(
f"[warning]âš ï¸ `__file__` undefined. Assuming .env in CWD: [file]{ENV_FILE_PATH}[/]",
style="warning", # Use direct style if console might be dummy
)

# MARK: - ENSURE .ENV EXISTS (calls config_auth.py)

# This will prompt for creation or exit if skipped/failed

check_env_file(env_path=ENV_FILE_PATH)

CACHE_FILE_CONTENT = "content_cache.json"

# MARK: - LOAD ENVIRONMENT VARIABLES

console.log(f"âŒ› Loading environment variables from: [file]{ENV_FILE_PATH}[/]")
loaded = load_dotenv(dotenv_path=ENV_FILE_PATH, verbose=False, override=False)

# verbose=False is quieter

if not loaded and ENV_FILE_PATH.exists():
console.log(
"[warning]âš ï¸ .env found but `load_dotenv` failed (empty/malformed?).[/]"
)
elif not ENV_FILE_PATH.exists(): # Should not happen if check_env_file worked
console.log(
f"[error]âŒ .env file still not found at [file]{ENV_FILE_PATH}[/]. Exiting.[/]"
)
sys.exit(1)

# MARK: - APPLICATION CONSTANTS (Mandatory first)

# --- Habitica API Credentials (Checked for None after loading) ---

HABITICA_USER_ID: Optional[str] = os.getenv("HABITICA_USER_ID")
HABITICA_API_TOKEN: Optional[str] = os.getenv("HABITICA_API_TOKEN")

# --- Validation of Mandatory Credentials ---

if not HABITICA_USER_ID or not HABITICA_API_TOKEN:
console.print("\n" + "=" _ 60, style="error")
console.print(
" [error]âŒ FATAL ERROR: Essential Configuration Missing![/error]"
)
if not HABITICA_USER_ID:
console.print(
" - `HABITICA_USER_ID` not found or empty in `.env` file."
)
if not HABITICA_API_TOKEN:
console.print(
" - `HABITICA_API_TOKEN` not found or empty in `.env` file."
)
console.print(f" Location checked: [file]{ENV_FILE_PATH}[/]")
console.print(
" Please run setup (`pixabit setup-auth`) or manually edit the `.env` file."
)
console.print(" Application cannot continue without these credentials.")
console.print("=" _ 60 + "\n", style="error")
sys.exit(1)

# Exit if mandatory credentials are not loaded

# --- Optional Tag IDs ---

CHALLENGE_TAG_ID: Optional[str] = os.getenv("CHALLENGE_TAG_ID")
PERSONAL_TAG_ID: Optional[str] = os.getenv("PERSONAL_TAG_ID")
LEGACY_TAG_ID: Optional[str] = os.getenv("LEGACY_TAG_ID")
PSN_TAG_ID: Optional[str] = os.getenv("PSN_TAG_ID")
NOT_PSN_TAG_ID: Optional[str] = os.getenv("NOT_PSN_TAG_ID")
NO_ATTR_TAG_ID: Optional[str] = os.getenv("NO_ATTR_TAG_ID")
ATTR_TAG_STR_ID: Optional[str] = os.getenv("ATTR_TAG_STR_ID")
ATTR_TAG_INT_ID: Optional[str] = os.getenv("ATTR_TAG_INT_ID")
ATTR_TAG_CON_ID: Optional[str] = os.getenv("ATTR_TAG_CON_ID")
ATTR_TAG_PER_ID: Optional[str] = os.getenv("ATTR_TAG_PER_ID")

# --- Derived Config: Attribute Tag Map (for convenience) ---

TAG_MAP: dict[str, str] = {
tag_id: attr
for tag_id, attr in [
(CHALLENGE_TAG_ID, "challenge"),
(LEGACY_TAG_ID, "legacy"),
(PERSONAL_TAG_ID, "personal"),
(PSN_TAG_ID, "psn"),
(NOT_PSN_TAG_ID, "no_psn"),
]
if tag_id
}

# Useful for TagManager and potentially other parts of the app

# Only includes tags that are actually configured in the .env

ATTR_TAG_MAP: dict[str, str] = {
tag_id: attr
for tag_id, attr in [
(ATTR_TAG_STR_ID, "str"),
(ATTR_TAG_INT_ID, "int"),
(ATTR_TAG_CON_ID, "con"),
(ATTR_TAG_PER_ID, "per"),
]
if tag_id
}
ATTRIBUTE_MAP = ATTR_TAG_MAP
POISON_MAP: dict[str, str] = {
tag_id: attr
for tag_id, attr in [
(PSN_TAG_ID, "psn"),
(NOT_PSN_TAG_ID, "no_psn"),
]
if tag_id
}

CHALLENGE_MAP: dict[str, str] = {
tag_id: attr
for tag_id, attr in [
(CHALLENGE_TAG_ID, "challenge"),
(LEGACY_TAG_ID, "legacy"),
(PERSONAL_TAG_ID, "personal"),
]
if tag_id
}

# MARK: - MODULE LOAD COMPLETION

console.log("[success]âœ… Configuration module loaded successfully.[/success]")

--- END OF FILE cli/config.py ---

--- START OF FILE cli/data_processor.py ---

# pixabit/data_processor.py

# MARK: - MODULE DOCSTRING

"""Processes raw Habitica data (Tasks, User, Party, Content) into structured formats,
categorizes tasks, calculates derived stats (like effective CON), and computes
potential daily damage. Includes functions to get combined user statistics.
"""

# MARK: - IMPORTS

import json
import math
from pathlib import Path
from typing import Any, Dict, Optional

import emoji_data_python

from ..utils.dates import convert_to_local_time, is_date_passed
from ..utils.display import console

# Use themed display

from ..utils.save_json import save_json

# Local Imports

from .api import HabiticaAPI

# Keep for saving processed data if needed

# MARK: - CONSTANTS

# Cache file for game content

# MARK: - TaskProcessor Class

class TaskProcessor:
"""Processes raw task data, user data, and game content from Habitica.

    Fetches data if not provided, calculates derived stats, processes tasks,
    calculates potential damage, and categorizes tasks.
    """

    # MARK: - Initialization

    # & - def __init__(...)
    def __init__(
        self,
        api_client: HabiticaAPI,
        user_data: Optional[dict[str, Any]] = None,
        party_data: Optional[dict[str, Any]] = None,
        all_tags_list: Optional[list[dict[str, Any]]] = None,
        content_data: Optional[dict[str, Any]] = None,
    ):
        """Initializes TaskProcessor. Fetches required data only if not provided.

        Args:
            api_client: Authenticated HabiticaAPI client.
            user_data: Optional pre-fetched user data.
            party_data: Optional pre-fetched party data.
            all_tags_list: Optional pre-fetched list of all tags.
            content_data: Optional pre-fetched game content.
        """
        self.api_client = api_client
        self.console = console
        self.console.log("Initializing TaskProcessor...", style="info")

        # Store or Fetch Required Data (Reduces API calls if data passed in)
        self.user_data = (
            user_data if user_data is not None else self._fetch_user_data()
        )
        self.party_data = (
            party_data if party_data is not None else self._fetch_party_data()
        )
        save_json(party_data, "party.json")
        _tags_list = (
            all_tags_list
            if all_tags_list is not None
            else self._fetch_tags_list()
        )
        self.tags_lookup = self._prepare_tags_lookup(_tags_list)
        self.game_content = (
            content_data
            if content_data is not None
            else self._fetch_or_load_content()
        )
        self.gear_stats_lookup = self.game_content.get("gear", {}).get(
            "flat", {}
        )
        if not self.gear_stats_lookup:
            self.console.log(
                "Could not find gear data in game content.", style="warning"
            )

        # Initialize Derived Stats
        self.user_con: float = 0.0
        self.user_stealth: int = 0
        self.is_sleeping: bool = False
        self.is_on_boss_quest: bool = False
        self.boss_str: float = 0.0

        # Calculate context from the fetched/provided data
        self._calculate_user_context()
        self.console.log("TaskProcessor Initialized.", style="info")

    # MARK: - Private Data Fetching Helpers

    # & - def _fetch_user_data(self) -> dict[str, Any]:
    def _fetch_user_data(self) -> dict[str, Any]:
        """Fetches user data. Returns {} on failure."""
        self.console.log(
            "Fetching user data for TaskProcessor context...", style="info"
        )
        try:
            data = self.api_client.get_user_data()
            return data if data else {}
        except Exception as e:
            self.console.log(
                f"Exception fetching user data: {e}", style="error"
            )
            return {}

    # & - def _fetch_party_data(self) -> dict[str, Any]:
    def _fetch_party_data(self) -> dict[str, Any]:
        """Fetches party data. Returns {} on failure or if not in party."""
        self.console.log(
            "Fetching party data for TaskProcessor context...", style="info"
        )
        try:
            data = self.api_client.get_party_data()
            return data if data else {}
        except Exception as e:
            self.console.log(
                f"Exception fetching party data: {e}", style="error"
            )
            return {}

    # & - def _fetch_tags_list(self) -> list[dict[str, Any]]:
    def _fetch_tags_list(self) -> list[dict[str, Any]]:
        """Fetches all tags. Returns [] on failure."""
        self.console.log("Fetching all tags for lookup...", style="info")
        try:
            return self.api_client.get_tags()
        # Returns list or []
        except Exception as e:
            self.console.log(
                f"Exception fetching tags list: {e}", style="error"
            )
            return []

    # & - def _fetch_or_load_content(self) -> dict[str, Any]:
    def _fetch_or_load_content(self) -> dict[str, Any]:
        """Fetches game content from API or loads from cache. Returns {} on failure."""
        self.console.log("Fetching/Loading game content...", style="info")
        raw_content = None

        # --- 1. Try Cache ---
        if Path(CACHE_FILE_CONTENT).exists():
            self.console.log(
                f"Attempting load from cache: '{CACHE_FILE_CONTENT}'...",
                style="subtle",
            )
            try:
                with open(CACHE_FILE_CONTENT, encoding="utf-8") as f:
                    raw_content = json.load(f)
                if isinstance(raw_content, dict) and raw_content:
                    self.console.log(
                        "Successfully loaded content from cache.",
                        style="success",
                    )
                else:
                    self.console.log(
                        f"Cache file '{CACHE_FILE_CONTENT}' invalid. Refetching.",
                        style="warning",
                    )
                    raw_content = None
            except (OSError, json.JSONDecodeError, Exception) as e:
                self.console.log(
                    f"Failed load/parse cache '{CACHE_FILE_CONTENT}': {e}. Refetching.",
                    style="warning",
                )
                raw_content = None

        # --- 2. Fetch API if Needed ---
        if raw_content is None:
            self.console.log("Fetching game content from API...")
            try:
                raw_content = self.api_client.get_content()
                # Returns dict or None
                if isinstance(raw_content, dict) and raw_content:
                    self.console.log(
                        "Successfully fetched content from API.",
                        style="success",
                    )

                    # --- 3. Save to Cache ---
                    try:
                        with open(
                            CACHE_FILE_CONTENT, "w", encoding="utf-8"
                        ) as f:
                            json.dump(
                                raw_content, f, ensure_ascii=False, indent=2
                            )
                        self.console.log(
                            f"Saved content to cache: '{CACHE_FILE_CONTENT}'",
                            style="info",
                        )
                    except (OSError, Exception) as e_save:
                        self.console.log(
                            f"Failed to save content cache '{CACHE_FILE_CONTENT}': {e_save}",
                            style="warning",
                        )
                else:
                    self.console.log(
                        "Failed to fetch valid content from API.", style="error"
                    )
                    raw_content = {}
            except Exception as e_fetch:
                self.console.log(
                    f"Exception fetching content: {e_fetch}", style="error"
                )
                raw_content = {}
        return raw_content if isinstance(raw_content, dict) else {}

    # MARK: - Private Calculation & Preparation Helpers

    # & - def _prepare_tags_lookup(...)
    def _prepare_tags_lookup(
        self, tags_list: list[dict[str, Any]]
    ) -> dict[str, str]:
        """Creates tag ID -> name lookup dict."""
        if not tags_list:
            self.console.log(
                "Tag list empty. Tag lookup will be empty.", style="warning"
            )
            return {}
        lookup = {
            tag["id"]: tag.get("name", f"Unnamed_{tag['id'][:6]}")
            # More descriptive fallback
            for tag in tags_list
            if isinstance(tag, dict) and "id" in tag
        }
        self.console.log(
            f"Prepared lookup for {len(lookup)} tags.", style="info"
        )
        return lookup

    # & - def _calculate_user_context(self) -> None:
    def _calculate_user_context(self) -> None:
        """Calculates effective CON, stealth, sleep, quest status from instance data."""
        self.console.log(
            "Calculating user context (CON, Stealth, etc.)...", style="info"
        )
        if not self.user_data:
            self.console.log(
                "Cannot calculate context: User data missing.", style="warning"
            )
            return

        try:

            # --- Calculate Effective CON ---
            stats = self.user_data.get("stats", {})
            level = stats.get("lvl", 0)
            user_class = stats.get("class")
            buffs = stats.get("buffs", {})
            equipped_gear = (
                self.user_data.get("items", {})
                .get("gear", {})
                .get("equipped", {})
            )

            level_bonus = min(50.0, math.floor(level / 2.0))
            alloc_con = float(stats.get("con", 0.0))
            buff_con = float(buffs.get("con", 0.0))
            gear_con = 0.0
            class_bonus_con = 0.0

            if isinstance(equipped_gear, dict) and self.gear_stats_lookup:
                for key in equipped_gear.values():
                    if not key:
                        continue
                    item_stats = self.gear_stats_lookup.get(key)
                    if isinstance(item_stats, dict):
                        item_base_con = float(item_stats.get("con", 0.0))
                        gear_con += item_base_con
                        if item_stats.get("klass") == user_class:
                            class_bonus_con += item_base_con * 0.5

            self.user_con = (
                level_bonus + alloc_con + gear_con + class_bonus_con + buff_con
            )

            # --- Other Context ---
            self.user_stealth = int(buffs.get("stealth", 0))
            self.is_sleeping = self.user_data.get("preferences", {}).get(
                "sleep", False
            )
            self.console.log(
                f"User Context: CON={self.user_con:.2f}, Stealth={self.user_stealth}, Sleeping={self.is_sleeping}",
                style="success",
            )

        except (ValueError, TypeError, KeyError, AttributeError) as e:
            self.console.log(
                f"Error calculating user stats context: {e}. Using defaults.",
                style="warning",
            )
            self.user_con, self.user_stealth, self.is_sleeping = 0.0, 0, False

        # --- Party Context ---
        if not self.party_data:
            self.console.log(
                "Cannot calculate party context: Party data missing.",
                style="warning",
            )
            self.is_on_boss_quest, self.boss_str = False, 0.0
            return

        try:
            quest = self.party_data.get("quest", {})
            if isinstance(quest, dict) and quest.get("active"):
                boss_name = quest.get("key")
                boss = (
                    self.game_content.get("quests", {})
                    .get(boss_name, {})
                    .get("boss", {})
                )
                # V3 API structure
                if isinstance(boss, dict) and boss.get("str") is not None:
                    self.is_on_boss_quest = True
                    try:
                        self.boss_str = float(boss.get("str", 0.0))
                    except (ValueError, TypeError):
                        self.boss_str = 0.0
                    # Default if conversion fails
                    self.console.log(
                        f"Party Context: On active BOSS quest (Str={self.boss_str:.2f}).",
                        style="info",
                    )
                else:
                    # Active quest, but not a boss or no boss strength
                    self.is_on_boss_quest, self.boss_str = False, 0.0
                    quest_key = quest.get("key", "Unknown")
                    self.console.log(
                        f"Party Context: On active quest '{quest_key}' (not boss/no str).",
                        style="info",
                    )
            else:
                # Not on an active quest
                self.is_on_boss_quest, self.boss_str = False, 0.0
                self.console.log(
                    "Party Context: Not on active quest.", style="info"
                )
        except Exception as e:
            self.console.log(
                f"Error calculating party context: {e}. Assuming no active boss.",
                style="warning",
            )
            self.is_on_boss_quest, self.boss_str = False, 0.0

    # & - def _value_color(self, value: Optional[float]) -> str: ... (Keep previous theme mapping)
    def _value_color(self, value: Optional[float]) -> str:
        """Determines a semantic style name based on task value."""
        if value is None:
            return "neutral"
        if value > 15:
            return "rosewater"
        elif value > 8:
            return "flamingo"
        elif value > 1:
            return "peach"
        elif value >= 0:
            return "text"
        elif value > -9:
            return "lavender"
        elif value > -16:
            return "rp_iris"
        else:
            return "red"

    # & - def _process_task_tags(...) (Keep previous implementation)
    def _process_task_tags(self, task_data: Dict) -> list[str]:
        """Retrieves tag names using lookup."""
        tag_ids = task_data.get("tags", [])
        if not isinstance(tag_ids, list):
            task_id = task_data.get("id", "N/A")
            self.console.log(
                f"Task {task_id} has non-list tags: {tag_ids}. Processing as empty.",
                style="warning",
            )
            return []
        return [
            self.tags_lookup.get(tag_id, f"ID:{tag_id}") for tag_id in tag_ids
        ]

    # & - def _calculate_checklist_done(...) (Keep previous implementation)
    def _calculate_checklist_done(
        self, checklist: Optional[list[Dict]]
    ) -> float:
        """Calculates proportion (0.0-1.0) of checklist items done."""
        if (
            not checklist
            or not isinstance(checklist, list)
            or len(checklist) == 0
        ):
            return 1.0
        try:
            completed = sum(
                1
                for item in checklist
                if isinstance(item, dict) and item.get("completed", False)
            )
            total = len(checklist)
            return completed / total if total > 0 else 1.0
        except Exception as e:
            self.console.log(
                f"Error calculating checklist progress: {e}. Defaulting to 1.0.",
                style="warning",
            )
            return 1.0

    # MARK: - Private Task Type Processors
    # & - def _process_and_calculate_task(...) - REVISED
    def _process_and_calculate_task(self, task_instance: Task) -> None:
        """Performs post-instantiation processing on a Task object:
        emoji, status, value_color, tag names, and damage (for Dailies).
        Modifies the task_instance directly.
        """
        # --- 1. Emoji Processing ---
        task_instance.text = emoji_data_python.replace_colons(
            task_instance.text or ""
        )
        task_instance.notes = emoji_data_python.replace_colons(
            task_instance.notes or ""
        )
        if hasattr(task_instance, "checklist") and isinstance(
            task_instance.checklist, list
        ):
            for item in task_instance.checklist:
                if isinstance(item, ChecklistItem):
                    item.text = emoji_data_python.replace_colons(
                        item.text or ""
                    )

        # --- 2. Tag Names Lookup ---
        task_instance.tag_names = [
            self.tags_lookup.get(tag_id, f"ID:{tag_id}")
            for tag_id in task_instance.tags
        ]

        # --- 3. Value Color ---
        task_instance.value_color = self._value_color(task_instance.value)

        # --- 4. Status Calculation & Damage (if Daily) ---
        dmg_user, dmg_party = 0.0, 0.0  # Initialize damage vars

        if isinstance(task_instance, Daily):
            # Calculate Daily status
            status = "grey"
            if task_instance.is_due:
                status = "success" if task_instance.completed else "due"
            task_instance._status = status

            # --- Calculate Damage ONLY if due, not completed, not sleeping, not stealthed ---
            if (
                task_instance.is_due
                and not task_instance.completed
                and not self.is_sleeping
                and self.user_stealth <= 0
            ):
                try:
                    # Use attributes from the task_instance object
                    task_value = task_instance.value or 0.0
                    checklist = task_instance.checklist
                    priority_val = task_instance.priority or 1.0

                    # a. Clamp Task Value
                    v_min, v_max = -47.27, 21.27
                    clamped_value = max(v_min, min(task_value, v_max))

                    # b. Base Delta Calculation (Habitica formula)
                    base_delta = abs(math.pow(0.9747, clamped_value))

                    # c. Checklist Mitigation
                    checklist_done_ratio = self._calculate_checklist_done(
                        checklist
                    )
                    checklist_mitigation = (
                        1.0 - checklist_done_ratio
                    )  # Multiplier (0.0 to 1.0)

                    # d. Effective Delta (after checklist)
                    effective_delta = base_delta * checklist_mitigation

                    # e. CON Mitigation (uses pre-calculated self.user_con)
                    con_mitigation = max(0.1, 1.0 - (self.user_con / 250.0))

                    # f. Priority Multiplier
                    prio_map = {0.1: 0.1, 1.0: 1.0, 1.5: 1.5, 2.0: 2.0}
                    try:  # Handle potential non-numeric priority safely
                        priority_multiplier = prio_map.get(
                            float(priority_val), 1.0
                        )
                    except (ValueError, TypeError):
                        priority_multiplier = 1.0

                    # g. Calculate User HP Damage
                    # Formula: effective_delta * con_mitigation * priority_multiplier * 2.0
                    hp_mod = (
                        effective_delta
                        * con_mitigation
                        * priority_multiplier
                        * 2.0
                    )
                    dmg_user = round(hp_mod, 1)  # Round to 1 decimal place

                    # h. Calculate Party Damage (Boss Quest Only)
                    if self.is_on_boss_quest and self.boss_str > 0:
                        # Boss delta might adjust slightly for trivial tasks
                        boss_delta = effective_delta
                        if (
                            priority_multiplier < 1.0
                        ):  # Reduce damage for trivial tasks
                            boss_delta *= priority_multiplier
                        # Formula: boss_delta * boss_strength
                        dmg_party_unrounded = boss_delta * self.boss_str
                        dmg_party = round(
                            dmg_party_unrounded, 1
                        )  # Round to 1 decimal

                except Exception as e_dmg:
                    self.console.log(
                        f"Error calculating damage for Daily {task_instance.id}: {e_dmg}",
                        style="error",
                    )
                    dmg_user, dmg_party = 0.0, 0.0  # Reset on error

        elif isinstance(task_instance, Todo):
            # Calculate Todo status
            status = "grey"
            if task_instance.completed:
                status = "done"  # Mark completed Todos distinctly if needed
            elif task_instance.due_date:  # Has a due date
                status = "red" if task_instance.is_past_due else "due"
            # Else status remains 'grey' (no due date, not completed)
            task_instance._status = status

        elif isinstance(task_instance, Habit):
            task_instance._status = "habit"  # Simple status for habits
        elif isinstance(task_instance, Reward):
            task_instance._status = "reward"  # Simple status for rewards
        else:
            task_instance._status = (
                "unknown"  # Fallback for base Task or others
            )

        # --- 5. Assign Calculated Damage to Task Object ---
        # These attributes exist on the base Task class now, initialized to None
        task_instance.damage_user = dmg_user if dmg_user > 0 else None
        task_instance.damage_party = dmg_party if dmg_party > 0 else None

    # & - def _process_habit(...)
    def _process_habit(self, task_data: Dict) -> dict[str, Any]:
        """Processes Habit-specific fields."""
        processed = {}
        up, down = task_data.get("up", False), task_data.get("down", False)
        cup, cdown = task_data.get("counterUp", 0), task_data.get(
            "counterDown", 0
        )
        if up and down:
            processed["direction"], processed["counter"] = (
                "both",
                f"[ #A6E3A1]+{cup}[/] / [ #F38BA8]-{cdown}[/]",
            )
        elif up:
            processed["direction"], processed["counter"] = (
                "up",
                f"[ #A6E3A1]+{cup}[/]",
            )
        elif down:
            processed["direction"], processed["counter"] = (
                "down",
                f"[ #F38BA8]-{cdown}[/]",
            )
        else:
            processed["direction"], processed["counter"] = "none", "[dim]N/A[/]"
        processed["frequency"] = task_data.get("frequency", "daily")
        val = task_data.get("value", 0.0)
        processed["value"], processed["value_color"] = val, self._value_color(
            val
        )
        return processed

    # & - def _process_todo(...)
    def _process_todo(self, task_data: Dict) -> dict[str, Any]:
        """Processes To-Do-specific fields."""
        processed = {}
        deadline = task_data.get("date")
        processed["is_due"], processed["date"] = bool(deadline), deadline or ""
        if deadline:
            try:
                processed["_status"] = (
                    "red" if is_date_passed(deadline) else "due"
                )
            except Exception as e:
                self.console.log(
                    f"Error checking To-Do date '{deadline}' for task {task_data.get('id', 'N/A')}: {e}. Status grey.",
                    style="error",
                )
                processed["_status"] = "grey"
        else:
            processed["_status"] = "grey"
        processed["checklist"] = task_data.get("checklist", [])
        val = task_data.get("value", 0.0)
        processed["value"], processed["value_color"] = val, self._value_color(
            val
        )
        return processed

    # & - def _process_daily(...)
    def _process_daily(self, task_data: Dict) -> dict[str, Any]:
        """Processes Daily-specific fields, including damage."""
        processed = {}
        is_due, completed = task_data.get("isDue", False), task_data.get(
            "completed", False
        )
        checklist = task_data.get("checklist", [])
        next_due = task_data.get("nextDue", [])
        val = task_data.get("value", 0.0)

        status = "grey"
        if is_due:
            status = "success" if completed else "due"
        # Use 'success' for done
        processed["_status"] = status
        processed["checklist"] = checklist
        processed["date"] = (
            next_due[0] if isinstance(next_due, list) and next_due else ""
        )
        processed["is_due"] = is_due
        processed["streak"] = task_data.get("streak", 0)
        processed["value"], processed["value_color"] = val, self._value_color(
            val
        )
        print(self.boss_str)
        # --- Damage Calculation ---
        dmg_user, dmg_party = 0.0, 0.0
        if (
            is_due
            and not completed
            and not self.is_sleeping
            and self.user_stealth <= 0
        ):
            try:
                v_min, v_max = -47.27, 21.27
                c_val = max(v_min, min(val, v_max))
                delta = abs(math.pow(0.9747, float(c_val)))

                if isinstance(checklist, list):
                    check_ratio = self._calculate_checklist_done(checklist)
                    eff_delta = delta * 1.0 - check_ratio
                else:
                    eff_delta = delta

                con_mult = max(0.1, 1.0 - (float(self.user_con) / 250.0))
                prio = task_data.get("priority", 1.0)
                prio_map = {0.1: 0.1, 1.0: 1.0, 1.5: 1.5, 2.0: 2.0}
                prio_mult = (
                    prio_map.get(float(prio), 1.0)
                    if isinstance(prio, (int, float))
                    else 1.0
                )
                hp_mod = delta * con_mult * prio_mult * 2.0
                dmg_user = round(hp_mod * 10) / 10
                if self.is_on_boss_quest and self.boss_str > 0:

                    hp_boss = (
                        delta
                        * prio_mult
                        * 2.0
                        * self.user_data.get("stats").get("con", 0)
                    )
                    dmg_party = (hp_boss / 2) * self.boss_str
            except Exception as e_dmg:
                self.console.log(
                    f"Error calculating damage for Daily {task_data.get('id', 'N/A')}: {e_dmg}",
                    style="error",
                )
        if dmg_user > 0:
            processed["damage_to_user"] = dmg_user
        if dmg_party > 0:
            processed["damage_to_party"] = dmg_party
        return processed

    # & - def _process_reward(...)
    def _process_reward(self, task_data: Dict) -> dict[str, Any]:
        """Processes Reward-specific fields."""
        return {"value": task_data.get("value", 0)}

    # Cost

    # MARK: - Public Processing Methods

    # & - def process_single_task(...)
    def process_single_task(self, task_data: Dict) -> Optional[dict[str, Any]]:
        """Processes a single raw task into standardized format."""
        if not isinstance(task_data, dict) or not task_data.get("id"):
            self.console.log(
                f"Skipping invalid task data: {task_data}", style="warning"
            )
            return None
        task_id = task_data["id"]
        task_type = task_data.get("type")
        challenge = task_data.get("challenge", {})
        if not isinstance(challenge, dict):
            challenge = {}
        notes = task_data.get("notes", "")
        text = task_data.get("text", "")
        processed = {
            "id": task_id,
            "_type": task_type,
            "text": emoji_data_python.replace_colons(text or ""),
            "note": emoji_data_python.replace_colons(notes or ""),
            "priority": task_data.get("priority", 1.0),
            "attribute": task_data.get("attribute", "str"),
            "tags": task_data.get("tags", []),
            # Keep raw IDs
            "tag_names": self._process_task_tags(task_data),
            # Add names
            "created": task_data.get("createdAt", ""),
            "challenge_id": challenge.get("id", ""),
            "challenge_name": emoji_data_python.replace_colons(
                challenge.get("shortName", "")
            ),
        }

        type_processor = getattr(self, f"_process_{task_type}", None)
        if callable(type_processor):
            processed.update(type_processor(task_data))
        else:
            self.console.log(
                f"Unknown task type '{task_type}' for task {task_id}",
                style="warning",
            )
            val = task_data.get("value", 0.0)
            processed.update(
                {"value": val, "value_color": self._value_color(val)}
            )
        return processed

    # & - def process_and_categorize_all(...)
    def process_and_categorize_all(self) -> dict[str, Any]:
        """Fetches all tasks, processes, and categorizes them."""
        self.console.print("Fetching all tasks...", style="info")
        all_tasks_raw = []
        try:
            all_tasks_raw = self.api_client.get_tasks()
            # Returns list or []
            if not isinstance(all_tasks_raw, list):
                self.console.print(
                    f"Failed fetch: Expected list, got {type(all_tasks_raw)}.",
                    style="error",
                )
                all_tasks_raw = []
        except Exception as e:
            self.console.print(
                f"Fatal Error fetching tasks: {e}", style="error"
            )
            return {
                "data": {},
                "cats": {
                    "tasks": {},
                    "tags": [],
                    "broken": [],
                    "challenge": [],
                },
            }

        self.console.print(
            f"Processing {len(all_tasks_raw)} raw tasks...", style="info"
        )
        tasks_dict: dict[str, Dict] = {}
        cats_dict: dict[str, Any] = {
            "tasks": {
                "habits": [],
                "todos": {"due": [], "grey": [], "red": []},
                "dailys": {"success": [], "due": [], "grey": []},
                "rewards": [],
            },
            "tags": set(),
            "broken": [],
            "challenge": set(),
        }

        for task_data in all_tasks_raw:
            processed = self.process_single_task(task_data)
            if not processed:
                continue
            task_id = processed["id"]
            tasks_dict[task_id] = processed
            cats_dict["tags"].update(processed.get("tags", []))
            challenge = task_data.get("challenge", {})
            # Use raw data for broken flag
            if isinstance(challenge, dict):
                if challenge.get("broken"):
                    cats_dict["broken"].append(task_id)
                if challenge.get("id"):
                    cats_dict["challenge"].add(challenge.get("id"))
            t_type, t_status = processed.get("_type"), processed.get("_status")
            if t_type == "habit":
                cats_dict["tasks"]["habits"].append(task_id)
            elif t_type == "reward":
                cats_dict["tasks"]["rewards"].append(task_id)
            elif t_type == "todo":
                cats_dict["tasks"]["todos"].setdefault(
                    t_status or "grey", []
                ).append(task_id)
            elif t_type == "daily":
                cats_dict["tasks"]["dailys"].setdefault(
                    t_status or "grey", []
                ).append(task_id)

        cats_dict["tags"] = sorted(list(cats_dict["tags"]))
        cats_dict["challenge"] = sorted(list(cats_dict["challenge"]))
        self.console.print(
            "Task processing and categorization complete.", style="success"
        )
        return {"data": tasks_dict, "cats": cats_dict}

    # MARK: - File Saving (Optional)

    # & - def save_processed_data(...)
    def save_processed_data(
        self, processed_results: Dict, base_filename: str = "processed_output"
    ) -> None:
        """Saves processed task data and categories to separate JSON files."""
        if (
            not isinstance(processed_results, dict)
            or "data" not in processed_results
            or "cats" not in processed_results
        ):
            self.console.print(
                "Invalid processed data provided to save.", style="error"
            )
            return
        try:
            self.console.print("Saving processed data...", style="info")
            save_json(processed_results["data"], f"{base_filename}_data.json")
            save_json(processed_results["cats"], f"{base_filename}_cats.json")
        except Exception as e:
            self.console.print(
                f"Error saving processed files: {e}", style="error"
            )

# MARK: - User Stats Function

# & - def get_user_stats(...)

def get_user_stats(
api_client: HabiticaAPI,
cats_dict: dict[str, Any],
processed_tasks_dict: dict[str, dict[str, Any]],
user_data: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
"""Generates a dictionary of user statistics combined with task counts and potential damage.

    Uses pre-fetched user data if provided, otherwise fetches it. Calculates task
    counts from `cats_dict` and sums potential damage from `processed_tasks_dict`.

    Returns:
        Combined user/task statistics dict, or {} on critical error.
    """
    console.print("Calculating user stats...", style="info")
    if user_data is None:
        console.print(
            "User data not provided to get_user_stats, fetching...",
            style="info",
        )
        try:
            user_data = api_client.get_user_data()
        except Exception as e:
            console.print(
                f"Failed to fetch user data for stats: {e}", style="error"
            )
            user_data = None
    if not isinstance(user_data, dict) or not user_data:
        console.print(
            "Cannot calculate stats: Valid user data required.", style="error"
        )
        return {}
    if not isinstance(cats_dict, dict) or not cats_dict:
        console.print(
            "Cannot calculate stats: Valid categories data required.",
            style="error",
        )
        return {}
    if not isinstance(processed_tasks_dict, dict):
        console.print(
            "Cannot calculate stats: Valid processed tasks data required.",
            style="error",
        )
        return {}

    try:

        # --- Extract Data Safely ---
        stats = user_data.get("stats", {})
        party = user_data.get("party", {})
        prefs = user_data.get("preferences", {})
        auth = user_data.get("auth", {})
        ts = auth.get("timestamps", {})
        local_auth = auth.get("local", {})
        balance = user_data.get("balance", 0.0)
        gems = int(balance * 4) if balance > 0 else 0
        u_class_raw = stats.get("class", "warrior")
        u_class = "mage" if u_class_raw == "wizard" else u_class_raw
        last_login_utc = ts.get("loggedin")
        last_login_local = "N/A"
        if last_login_utc:
            local_dt = convert_to_local_time(last_login_utc)
            if local_dt:
                last_login_local = local_dt.isoformat(
                    sep=" ", timespec="minutes"
                )
            else:
                last_login_local = f"Error ({last_login_utc})"
        quest = party.get("quest", {})

        # --- Calculate Task Counts ---
        task_counts: dict[str, Any] = {}
        task_cats_data = cats_dict.get("tasks", {})
        if isinstance(task_cats_data, dict):
            for cat, data in task_cats_data.items():
                if isinstance(data, dict):
                    # dailys/todos
                    total = sum(
                        len(ids)
                        for ids in data.values()
                        if isinstance(ids, list)
                    )
                    task_counts[cat] = {
                        status: len(ids)
                        for status, ids in data.items()
                        if isinstance(ids, list)
                    }
                    task_counts[cat]["_total"] = total
                elif isinstance(data, list):
                    # habits/rewards
                    task_counts[cat] = len(data)
        else:
            console.print(
                "Invalid 'tasks' structure in cats_dict.", style="warning"
            )

        # --- Calculate Damage ---
        dmg_user, dmg_party = 0.0, 0.0
        due_dailies = (
            cats_dict.get("tasks", {}).get("dailys", {}).get("due", [])
        )
        for task_id in due_dailies:
            task = processed_tasks_dict.get(task_id)
            if isinstance(task, dict):
                dmg_user += float(task.get("damage_to_user", 0.0))
                dmg_party += float(task.get("damage_to_party", 0.0))

        # --- Assemble Final Dict ---
        output = {
            "username": local_auth.get("username", "N/A"),
            "class": u_class,
            "level": stats.get("lvl", 0),
            "hp": float(stats.get("hp", 0.0)),
            "maxHealth": stats.get("maxHealth", 50),
            "mp": float(stats.get("mp", 0.0)),
            "maxMP": stats.get("maxMP", 0),
            "exp": float(stats.get("exp", 0.0)),
            "toNextLevel": stats.get("toNextLevel", 0),
            "gp": float(stats.get("gp", 0.0)),
            "gems": gems,
            "stats": {
                "str": stats.get("str", 0),
                "int": stats.get("int", 0),
                "con": stats.get("con", 0),
                "per": stats.get("per", 0),
            },
            "sleeping": prefs.get("sleep", False),
            "day_start": prefs.get("dayStart", 0),
            "last_login_local": last_login_local,
            "quest_active": quest.get("active", False),
            "quest_key": quest.get("key"),
            "task_counts": task_counts,
            "broken_challenge_tasks": len(cats_dict.get("broken", [])),
            "joined_challenges_count": len(cats_dict.get("challenge", [])),
            "tags_in_use_count": len(cats_dict.get("tags", [])),
            "potential_daily_damage_user": round(dmg_user, 2),
            "potential_daily_damage_party": round(dmg_party, 2),
        }
        console.print("User stats calculation complete.", style="success")
        return output

    except Exception as e_stat:
        console.print(f"Error calculating user stats: {e_stat}", style="error")
        console.print_exception(show_locals=False)
        return {}

# Return empty dict on failure

--- END OF FILE cli/data_processor.py ---

--- START OF FILE cli/exports.py ---

# pixabit/exports.py

# MARK: - MODULE DOCSTRING

"""Provides functions for exporting various Habitica data structures to JSON files.

Includes functions to fetch specific data types (tags, raw tasks, full user data)
using the HabiticaAPI client and save them into well-formatted JSON files.
Uses the shared `save_json` utility.
"""

# MARK: - IMPORTS

from pathlib import Path
from typing import Any, Union

import emoji_data_python
import requests

from ..utils.display import console

# Use themed display

from ..utils.save_json import save_json

# For API error handling

# Local Imports

from .api import HabiticaAPI

# Use shared save utility

# MARK: - EXPORT FUNCTIONS

# --- Tag Exports ---

# & - def save_tags_into_json(...)

def save_tags_into_json(
api_client: HabiticaAPI, output_filename: Union[str, Path] = "tags_all.json"
) -> None:
"""Fetches all user tags and saves categorized (challenge/personal) to JSON."""
filepath = Path(output_filename) # Ensure Path object
console.print(f"ğŸ·ï¸ Fetching and saving tags to [file]'{filepath}'[/]...")
try:
tags_list = api_client.get_tags()
if not isinstance(tags_list, list):
console.print(
f"API Error: Expected list of tags, got {type(tags_list)}.",
style="error",
)
return
if not tags_list:
console.print("â„¹ï¸ No tags found in Habitica account.", style="info")
save_json({"challenge": {}, "personal": {}}, filepath) # Save empty structure
return

        category: dict[str, dict[str, str]] = {"challenge": {}, "personal": {}}
        processed_count, skipped_count = 0, 0
        for tag in tags_list:
            if not isinstance(tag, dict):
                console.print(
                    f"Skipping invalid item in tags list: {tag}",
                    style="warning",
                )
                skipped_count += 1
                continue
            tag_id = tag.get("id")
            if not tag_id:
                console.print(
                    f"Skipping tag with missing ID: {tag.get('name', 'Unnamed')}",
                    style="warning",
                )
                skipped_count += 1
                continue
            tag_name = tag.get("name", f"Unnamed_{tag_id[:6]}")

            # Categorize based on presence of 'challenge' key
            if tag.get("challenge"):
                category["challenge"][tag_id] = tag_name
            else:
                category["personal"][tag_id] = tag_name
            processed_count += 1

        console.print(
            f"Processed {processed_count} tags ({skipped_count} skipped)."
        )
        save_json(data=category, filepath=filepath)

    except requests.exceptions.RequestException as api_err:
        console.print(f"API Error fetching tags: {api_err}", style="error")
    except Exception as e:
        console.print(
            f"Unexpected error in save_tags_into_json: {e}", style="error"
        )

# --- Raw Task Exports ---

# & - def save_tasks_without_processing(...)

def save_tasks_without_proccessing( # Keep typo for consistency if called elsewhere
api_client: HabiticaAPI,
output_filename: Union[str, Path] = "tasks_raw.json",
) -> None:
"""Fetches all raw tasks, processes emojis in text, saves to JSON."""
filepath = Path(output_filename)
console.print(
f"ğŸ“ Fetching raw tasks (emoji processing) -> [file]'{filepath}'[/]..."
)
try:
raw_tasks = api_client.get_tasks()
if not isinstance(raw_tasks, list):
console.print(
f"API Error: Expected list of tasks, got {type(raw_tasks)}.",
style="error",
)
return

        console.print(f"Fetched {len(raw_tasks)} tasks. Processing emojis...")
        processed_count, skipped_count = 0, 0
        tasks_to_save = []
        for task in raw_tasks:
            if not isinstance(task, dict):
                console.print(
                    f"Skipping invalid item in tasks list: {task}",
                    style="warning",
                )
                skipped_count += 1
                continue

            # Process text and notes for emojis
            if "text" in task:
                task["text"] = emoji_data_python.replace_colons(
                    str(task.get("text", ""))
                )
            if "notes" in task:
                task["notes"] = emoji_data_python.replace_colons(
                    str(task.get("notes", ""))
                )
            tasks_to_save.append(task)
            processed_count += 1

        console.print(
            f"Emoji processing complete for {processed_count} tasks ({skipped_count} skipped)."
        )
        save_json(tasks_to_save, filepath)

    except requests.exceptions.RequestException as api_err:
        console.print(f"API Error fetching tasks: {api_err}", style="error")
    except Exception as e:
        console.print(f"Unexpected error saving raw tasks: {e}", style="error")

# --- Processed Task Exports ---

# & - def save_processed_tasks_into_json(...)

def save_processed_tasks_into_json(
processed_tasks_dict: dict[str, dict[str, Any]],
output_filename: Union[str, Path] = "tasks_processed.json",
) -> None:
"""Saves an already processed task dictionary to JSON."""
filepath = Path(output_filename)
console.print(
f"ğŸ’¾ Saving processed tasks dictionary -> [file]'{filepath}'[/]..."
)
if not isinstance(processed_tasks_dict, dict):
console.print(
f"Error: Invalid input `processed_tasks_dict` (must be dict), got {type(processed_tasks_dict)}.",
style="error",
)
return
if not processed_tasks_dict:
console.print(
"No processed tasks data provided. Saving empty file.", style="info"
)
save_json({}, filepath)
return
save_json(processed_tasks_dict, filepath)

# --- User Data Exports ---

# & - def save_all_userdata_into_json(...)

def save_all_userdata_into_json(
api_client: HabiticaAPI,
output_filename: Union[str, Path] = "user_data_full.json",
) -> None:
"""Fetches the full user data object (/user endpoint) and saves it to JSON."""
filepath = Path(output_filename)
console.print(f"ğŸ‘¤ Fetching full user data -> [file]'{filepath}'[/]...")
try:

        # get_user_data returns the 'data' part directly or None
        user_data_content = api_client.get_user_data()

        if user_data_content is None:
            console.print(
                "Error: Failed to fetch user data from API.", style="error"
            )
            return
        if not isinstance(user_data_content, dict):
            console.print(
                f"Error: Expected dict for user data, got {type(user_data_content)}.",
                style="error",
            )
            return

        save_json(user_data_content, filepath)

    except requests.exceptions.RequestException as api_err:
        console.print(f"API Error fetching user data: {api_err}", style="error")
    except Exception as e:
        console.print(f"Unexpected error saving user data: {e}", style="error")

--- END OF FILE cli/exports.py ---

--- START OF FILE cli/tag_manager.py ---

# pixabit/tag_manager.py

# MARK: - MODULE DOCSTRING

"""Provides TagManager class for managing Habitica tags and task attributes.

Enforces consistency rules (challenge vs. personal), ensures status tags
(poison), synchronizes attributes (STR, INT etc.) with tags, identifies/manages
unused tags. Relies on tag IDs from config and uses API client for modifications.
Checks config to enable/disable optional features gracefully.
"""

# MARK: - IMPORTS

from typing import Any, Optional, Set, Tuple

import requests

# Use themed display components

from ..utils.display import (
BarColumn,
Confirm,
Progress,
SpinnerColumn,
Table,
TextColumn,
TimeElapsedColumn,
TimeRemainingColumn,
box, # No track needed if using Progress
console,
)

# Local Imports

from .api import HabiticaAPI

# Import specific, configured tag IDs directly from config

from .config import ( # Use the generated map
ATTR_TAG_MAP,
CHALLENGE_TAG_ID,
NO_ATTR_TAG_ID,
NOT_PSN_TAG_ID,
PERSONAL_TAG_ID,
PSN_TAG_ID,
)

# MARK: - CLASS DEFINITION

class TagManager:
"""Manages consistency of tags and related attributes on tasks.

    Provides methods for bulk operations based on tags/attributes. Requires
    specific Tag IDs configured via `config.py`/.env. Checks config availability.
    """

    # & - def __init__(self, api_client: HabiticaAPI):
    def __init__(self, api_client: HabiticaAPI):
        """Initializes TagManager, loads configured tag IDs, checks status."""
        if not isinstance(api_client, HabiticaAPI):
            raise TypeError("`api_client` must be an instance of HabiticaAPI")

        self.api_client: HabiticaAPI = api_client
        self.console = console
        # Use themed console

        # --- Load Optional Tag IDs from Config ---
        self.challenge_tag: Optional[str] = CHALLENGE_TAG_ID
        self.personal_tag: Optional[str] = PERSONAL_TAG_ID
        self.psn_tag: Optional[str] = PSN_TAG_ID
        self.not_psn_tag: Optional[str] = NOT_PSN_TAG_ID
        self.no_attr_tag: Optional[str] = NO_ATTR_TAG_ID

        # Use the pre-built map from config.py
        self.attr_tag_map: dict[str, str] = ATTR_TAG_MAP
        self.attr_to_tag_map: dict[str, str] = {
            v: k for k, v in self.attr_tag_map.items()
        }

        self.console.log("TagManager initialized.", style="info")
        self._log_config_status()

    # & - def _log_config_status(self):
    def _log_config_status(self):
        """Logs the status of optional tag configurations."""
        status = []

        # Check if BOTH required tags for a feature are set
        status.append(
            f"Challenge/Personal: {'âœ… Configured' if self.challenge_tag and self.personal_tag else 'âŒ Off'}"
        )
        status.append(
            f"Poison Status: {'âœ… Configured' if self.psn_tag and self.not_psn_tag else 'âŒ Off'}"
        )

        # For attributes, check the map AND the no_attr tag
        status.append(
            f"Attributes: {'âœ… Configured' if self.attr_tag_map and self.no_attr_tag else 'âŒ Off'}"
        )
        self.console.log(
            f"Tag Feature Status - {', '.join(status)}", style="subtle"
        )

    # MARK: - Action Execution Helper

    # & - def _confirm_and_execute_actions(...)
    def _confirm_and_execute_actions(
        self, actions: list[Tuple[str, str, str]], description: str
    ) -> bool:
        """Confirms and executes a list of API actions with progress display.

        Handles 'add_tag', 'delete_tag', 'set_attribute', 'delete_tag_global'.

        Returns:
            bool: True if changes were attempted (regardless of errors), False if cancelled.
        """
        fix_count = len(actions)
        if fix_count == 0:
            self.console.print(
                f"[success]âœ… {description}: All conform. No actions needed.[/success]"
            )
            return False

        est_seconds = fix_count * (self.api_client.request_interval + 0.1)
        # Use API client interval
        est_time_str = (
            f"{est_seconds / 60:.1f} minutes"
            if est_seconds > 120
            else f"{est_seconds:.1f} seconds"
        )
        self.console.print(
            f"ğŸ” [warning]{description}:[/] Found [keyword]{fix_count}[/] action(s) needed. Est. time: {est_time_str}"
        )

        if not Confirm.ask(f"Apply these {fix_count} changes?", default=False):
            self.console.print(
                "[warning]âŒ Operation cancelled. No changes made.[/warning]"
            )
            return False

        # --- Execute with Progress Bar ---
        error_count = 0
        progress_cols = [
            # Use theme styles for progress
            TextColumn("[progress.description]{task.description}"),
            BarColumn(style="rp_surface", complete_style="rp_foam"),
            TextColumn(
                "[progress.percentage]{task.percentage:>3.0f}%", style="rp_foam"
            ),
            SpinnerColumn("dots", style="rp_iris"),
            TextColumn("â€¢ Elapsed:"),
            TimeElapsedColumn(),
            TextColumn("â€¢ Remain:"),
            TimeRemainingColumn(),
        ]
        with Progress(
            *progress_cols, console=self.console, transient=False
        ) as progress:
            batch_task_id = progress.add_task(description, total=fix_count)
            for i, (action, item_id, target) in enumerate(actions):
                progress.update(
                    batch_task_id,
                    description=f"{description} ({i+1}/{fix_count})",
                )
                try:
                    if action == "add_tag":
                        self.api_client.add_tag_to_task(item_id, target)
                    elif action == "delete_tag":
                        self.api_client.delete_tag_from_task(item_id, target)
                    elif action == "set_attribute":
                        self.api_client.set_attribute(
                            task_id=item_id, attribute=target
                        )
                    elif action == "delete_tag_global":

                        # CRITICAL: Assumes global delete implemented in API client
                        self.api_client.delete_tag(item_id)
                    # Calls DELETE /tags/{tagId}
                    else:
                        progress.console.print(
                            f"\n[warning]âš ï¸ Unknown action '{action}' for item {item_id}. Skipping.[/]"
                        )
                        error_count += 1
                except requests.exceptions.RequestException as e:
                    progress.console.print(
                        f"\n[error]âŒ API Error ({action} on {item_id}): {e}[/]"
                    )
                    error_count += 1
                except Exception as e:
                    progress.console.print(
                        f"\n[error]âŒ Unexpected Error ({action} on {item_id}): {e}[/]"
                    )
                    error_count += 1
                finally:
                    progress.update(batch_task_id, advance=1)

        # time.sleep(0.05)
        # Small delay optional

        # --- End Progress ---
        self.console.rule(style="rp_overlay")
        if error_count == 0:
            self.console.print(
                f"[success]âœ… {description}: Completed successfully![/success]"
            )
        else:
            self.console.print(
                f"[warning]âš ï¸ {description}: Completed with {error_count} error(s).[/warning]"
            )
        self.console.rule(style="rp_overlay")
        return True

    # Changes were attempted

    # MARK: - Tag Consistency Methods

    # & - def sync_challenge_personal_tags(...)
    def sync_challenge_personal_tags(
        self, processed_tasks: dict[str, dict[str, Any]]
    ) -> bool:
        """Ensures tasks have mutually exclusive challenge/personal tags."""
        description = "Challenge/Personal Tag Sync"
        if not self.challenge_tag or not self.personal_tag:
            self.console.print(
                f"[info]â„¹ï¸ Skipping '{description}': Tags not configured.[/info]"
            )
            return False
        if not isinstance(processed_tasks, dict):
            self.console.print(
                f"[error]âŒ Skipping '{description}': Invalid input.[/error]"
            )
            return False

        actions: list[Tuple[str, str, str]] = []
        for task_id, task_data in processed_tasks.items():
            if not isinstance(task_data, dict):
                continue
            tags = set(task_data.get("tags", []))
            # Use raw tags list from processed data
            is_challenge = bool(task_data.get("challenge_id"))

            # Rule 1a: Challenge task MUST have challenge_tag
            if is_challenge and self.challenge_tag not in tags:
                actions.append(("add_tag", task_id, self.challenge_tag))

            # Rule 1b: Challenge task MUST NOT have personal_tag
            if is_challenge and self.personal_tag in tags:
                actions.append(("delete_tag", task_id, self.personal_tag))

            # Rule 2a: Personal task MUST have personal_tag
            if not is_challenge and self.personal_tag not in tags:
                actions.append(("add_tag", task_id, self.personal_tag))

            # Rule 2b: Personal task MUST NOT have challenge_tag
            if not is_challenge and self.challenge_tag in tags:
                actions.append(("delete_tag", task_id, self.challenge_tag))

        return self._confirm_and_execute_actions(actions, description)

    # & - def ensure_poison_status_tags(...)
    def ensure_poison_status_tags(
        self, processed_tasks: dict[str, dict[str, Any]]
    ) -> bool:
        """Ensures tasks have either psn_tag or not_psn_tag, defaulting to not_psn_tag."""
        description = "Poison Status Tag Check"
        if not self.psn_tag or not self.not_psn_tag:
            self.console.print(
                f"[info]â„¹ï¸ Skipping '{description}': Tags not configured.[/info]"
            )
            return False
        if not isinstance(processed_tasks, dict):
            self.console.print(
                f"[error]âŒ Skipping '{description}': Invalid input.[/error]"
            )
            return False

        actions: list[Tuple[str, str, str]] = []
        for task_id, task_data in processed_tasks.items():
            if not isinstance(task_data, dict):
                continue
            tags = set(task_data.get("tags", []))
            has_psn, has_not_psn = (
                self.psn_tag in tags,
                self.not_psn_tag in tags,
            )

            # Add default NOT_PSN if neither is present
            if not has_psn and not has_not_psn:
                actions.append(("add_tag", task_id, self.not_psn_tag))

        # Optional: If both present, remove NOT_PSN (assume PSN takes priority)

        # elif has_psn and has_not_psn: actions.append(("delete_tag", task_id, self.not_psn_tag))

        return self._confirm_and_execute_actions(actions, description)

    # & - def sync_attributes_to_tags(...)
    def sync_attributes_to_tags(
        self, processed_tasks: dict[str, dict[str, Any]]
    ) -> bool:
        """Synchronizes task 'attribute' field with configured attribute tags."""
        description = "Attribute Sync (Field <-> Tags)"
        if not self.attr_tag_map or not self.no_attr_tag:
            self.console.print(
                f"[info]â„¹ï¸ Skipping '{description}': Attribute/NoAttr tags not fully configured.[/info]"
            )
            return False
        if not isinstance(processed_tasks, dict):
            self.console.print(
                f"[error]âŒ Skipping '{description}': Invalid input.[/error]"
            )
            return False

        actions: list[Tuple[str, str, str]] = []
        all_attr_tags: Set[str] = set(self.attr_tag_map.keys())

        for task_id, task_data in processed_tasks.items():
            if not isinstance(task_data, dict):
                continue
            tags: Set[str] = set(task_data.get("tags", []))
            current_attribute: Optional[str] = task_data.get("attribute")
            present_attr_tags: Set[str] = tags.intersection(all_attr_tags)
            num_present = len(present_attr_tags)
            has_no_attr_tag = self.no_attr_tag in tags

            if num_present > 1:
                # Conflict -> Apply NO_ATTR
                if not has_no_attr_tag:
                    actions.append(("add_tag", task_id, self.no_attr_tag))
                for tag in present_attr_tags:
                    actions.append(("delete_tag", task_id, tag))

                # Reset attribute field to default 'str' if it had a specific one
                if current_attribute and current_attribute != "str":
                    actions.append(("set_attribute", task_id, "str"))
            elif num_present == 1:
                # Single ATTR tag -> Ensure field matches, remove NO_ATTR
                attr_tag = present_attr_tags.pop()
                correct_attribute = self.attr_tag_map[attr_tag]
                if has_no_attr_tag:
                    actions.append(("delete_tag", task_id, self.no_attr_tag))
                if current_attribute != correct_attribute:
                    actions.append(
                        ("set_attribute", task_id, correct_attribute)
                    )
            else:
                # No ATTR tags -> Ensure NO_ATTR tag, ensure field is 'str' (default)
                if not has_no_attr_tag:
                    actions.append(("add_tag", task_id, self.no_attr_tag))

                # If attribute field currently has a non-default value without a tag, reset it
                if current_attribute and current_attribute != "str":
                    actions.append(("set_attribute", task_id, "str"))

        return self._confirm_and_execute_actions(actions, description)

    # MARK: - Utility / Other Tag Methods

    # & - def add_or_replace_tag_based_on_other(...)
    def add_or_replace_tag_based_on_other(
        self,
        tasks_dict: dict[str, dict[str, Any]],
        find_tag_id: str,
        add_tag_id: str,
        remove_original: bool = False,
    ) -> bool:
        """Adds `add_tag_id` if `find_tag_id` exists. Optionally removes `find_tag_id`."""
        if not find_tag_id or not add_tag_id:
            self.console.print(
                "[error]âŒ Error: Both 'find_tag_id' and 'add_tag_id' must be provided.[/error]"
            )
            return False
        if not isinstance(tasks_dict, dict):
            self.console.print(
                "[error]âŒ Error: Invalid `tasks_dict` input.[/error]"
            )
            return False

        actions: list[Tuple[str, str, str]] = []
        mode = "Replacing" if remove_original else "Adding"

        # Use styles for tag IDs in description
        action_desc = f"{mode} tag '[rp_foam]{add_tag_id}[/]' based on '[rp_rose]{find_tag_id}[/]'"

        for task_id, task_data in tasks_dict.items():
            if not isinstance(task_data, dict):
                continue
            tags = set(task_data.get("tags", []))
            if find_tag_id in tags:
                if add_tag_id not in tags:
                    actions.append(("add_tag", task_id, add_tag_id))
                if remove_original and find_tag_id != add_tag_id:
                    actions.append(("delete_tag", task_id, find_tag_id))

        return self._confirm_and_execute_actions(actions, action_desc)

    # & - def find_unused_tags(...)
    def find_unused_tags(
        self, all_tags: list[dict[str, Any]], used_tag_ids: Set[str]
    ) -> list[dict[str, Any]]:
        """Identifies tags not present in the `used_tag_ids` set."""
        unused_tags: list[dict[str, Any]] = []
        self.console.print("ğŸ” Finding unused tags...", style="info")

        if not isinstance(used_tag_ids, set):
            self.console.print(
                "[warning]âš ï¸ `used_tag_ids` not a set, converting for efficiency.[/warning]"
            )
            try:
                used_tag_ids = set(used_tag_ids)
            except TypeError:
                self.console.print(
                    "[error]âŒ Invalid `used_tag_ids`. Cannot find unused tags.[/error]"
                )
                return []
        if not isinstance(all_tags, list):
            self.console.print("[error]âŒ Invalid `all_tags` list.[/error]")
            return []

        for tag in all_tags:
            if not isinstance(tag, dict):
                continue
            tag_id = tag.get("id")
            if tag_id and tag_id not in used_tag_ids:
                unused_tags.append(
                    {"id": tag_id, "name": tag.get("name", "[dim]N/A[/dim]")}
                )

        self.console.print(
            f"[success]âœ… Found {len(unused_tags)} potentially unused tags.[/success]"
        )
        return unused_tags

    # & - def delete_unused_tags_interactive(...) -> bool:
    def delete_unused_tags_interactive(
        self, all_tags: list[dict[str, Any]], used_tag_ids: Set[str]
    ) -> bool:
        """Finds unused tags and interactively asks user to delete them globally."""
        description = "Deleting Unused Tags"
        unused = self.find_unused_tags(all_tags, used_tag_ids)
        if not unused:
            self.console.print(
                f"[success]âœ… {description}: No unused tags found.[/success]"
            )
            return False

        # --- Display ---
        self.console.print(
            "\n[warning]--- Potentially Unused Tags ---[/warning]"
        )
        table = Table(
            title="Unused Tags", box=box.ROUNDED, border_style="warning"
        )
        table.add_column("Num", style="subtle", width=4)
        table.add_column("Name", style="rp_foam")
        table.add_column("ID", style="rp_rose")
        for i, tag in enumerate(unused):
            table.add_row(str(i + 1), tag["name"], tag["id"])
        self.console.print(table)

        # --- Confirmation & Action ---
        if Confirm.ask(
            "\n[error]Delete ALL[/] listed unused tags permanently from Habitica?\n"
            "[warning]âš ï¸ This action is IRREVERSIBLE and deletes the tag globally, not just from tasks![/]",
            default=False,
        ):

            # Prepare actions using 'delete_tag_global' type
            actions = [
                ("delete_tag_global", tag["id"], tag["id"]) for tag in unused
            ]
            if actions:
                self.console.print(
                    "[warning]Proceeding with global tag deletion...[/warning]"
                )
                return self._confirm_and_execute_actions(actions, description)
            else:
                self.console.print(
                    f"[warning]âš ï¸ {description}: No delete actions prepared.[/warning]"
                )
                return False
        # No action attempted
        else:
            self.console.print(
                f"[warning]âŒ {description}: No tags were deleted.[/warning]"
            )
            return False

# --- End of TagManager class ---

--- END OF FILE cli/tag_manager.py ---
