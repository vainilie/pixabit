# pixabit/auth_file.py
"""
Manages the creation and verification of the application's .env configuration file.

This module provides functions to interactively create a `.env` file containing
essential credentials and settings (like Habitica User ID, API Token, and specific
Tag IDs) using prompts and confirmations from the Rich library (via the
`utils.display` helper module). It also includes a function to check if the
`.env` file exists and trigger its creation if it's missing.

Functions:
    check_env_file(filename): Checks for the existence of the env file and
                              prompts for creation if missing.
    create_env_file(filename): Interactively creates or overwrites the env file.

Constants:
    DEFAULT_ENV_FILE (str): The default filename ".env".
"""

import os.path

from .utils.display import Confirm, Prompt, console, print

# % ── Constants ────────────────────────────────────────────────────────────────


DEFAULT_ENV_FILE = ".env"  # Default name for the environment configuration file


# % ── Core Functions ───────────────────────────────────────────────────────────


def create_env_file(filename: str = DEFAULT_ENV_FILE) -> None:
    """
    Interactively creates or overwrites a .env file with credentials and settings.

    Prompts the user for Habitica User ID, API Token (hidden input), and specific
    Tag IDs using Rich prompts. Confirms before overwriting an existing file.
    If the user declines interactive help, it creates a file with placeholder values.

    The resulting file will have the format:
        HABITICA_USER_ID="value"
        HABITICA_API_TOKEN="value"
        CHALLENGE_TAG_ID="value"
        OWNED_TAG_ID="value"

    Args:
        filename (str): The path/name of the .env file to create or overwrite.
                        Defaults to DEFAULT_ENV_FILE (".env").

    Returns:
        None

    Raises:
        IOError: If there's an error writing the file to disk.
        ImportError: (Implicitly) If Rich components cannot be imported.
    """
    # Check for existing file and confirm overwrite
    if os.path.exists(filename):
        if not Confirm.ask(
            f"The file [b cyan]{filename}[/] already exists. Overwrite it?",
            default=False,
        ):
            print(f"Operation cancelled. Keeping existing file [b cyan]{filename}[/].")
            return  # Exit function, do not overwrite

    print(f"Preparing to create/update [b cyan]{filename}[/]...")

    # Ask if user wants interactive help filling the file
    if Confirm.ask(
        "\nDo you want help filling the configuration file interactively?", default=True
    ):
        print(
            "Please provide the following details (find them in Habitica's Settings > API):"
        )
        input_userid = Prompt.ask(
            "  Enter your [b yellow]Habitica User ID[/]",
            default="YOUR_HABITICA_USER_ID_HERE",
        )
        input_apitoken = Prompt.ask(
            "  Enter your [b yellow]Habitica API Token[/]",
            default="YOUR_API_TOKEN_HERE",
            password=True,  # Hide the token input
        )
        print(
            "\nPlease provide the following Tag IDs (create tags in Habitica if needed, then find their IDs):"
        )
        print(
            "You can often find a Tag's ID in the URL when viewing/editing it on the Habitica website."
        )
        input_challenge_tag = Prompt.ask(
            "  Enter the [b yellow]Tag ID[/] for marking 'Challenge Tasks'",
            default="YOUR_CHALLENGE_TAG_ID_HERE",
        )
        input_owned_tag = Prompt.ask(
            "  Enter the [b yellow]Tag ID[/] for marking 'Owned Tasks'",
            default="YOUR_OWNED_TAG_ID_HERE",
        )
    else:
        # If they decline help, create the file with placeholders for manual editing
        print("\nOkay, creating file with placeholder values for you to edit manually.")
        input_userid = "YOUR_HABITICA_USER_ID_HERE"
        input_apitoken = "YOUR_API_TOKEN_HERE"
        input_challenge_tag = "YOUR_CHALLENGE_TAG_ID_HERE"
        input_owned_tag = "YOUR_OWNED_TAG_ID_HERE"

    # ─── Build The Content Of The Env File ────────────────────────────────
    # Using quotes ensures values with spaces (unlikely here, but good practice) are handled.
    env_content = f"""# Habitica Credentials and Settings
# Generated by pixabit setup script on {__import__('datetime').datetime.now().isoformat()}

HABITICA_USER_ID="{input_userid}"
HABITICA_API_TOKEN="{input_apitoken}"

# Specific Tag IDs (Create these tags in Habitica and find their IDs)
CHALLENGE_TAG_ID="{input_challenge_tag}"
OWNED_TAG_ID="{input_owned_tag}"
""".strip()  # .strip() removes leading/trailing whitespace from the multiline string

    # --- Write the content to the .env file ---
    try:
        with open(filename, "w", encoding="utf-8") as envfile:
            envfile.write(
                env_content + "\n"
            )  # Add a trailing newline for POSIX compatibility
        print(
            f"\n[b #8ccf7e]:heavy_check_mark: File [b cyan]{filename}[/] created/updated successfully."
        )
        print(
            f"[b yellow]IMPORTANT:[/] Ensure [b cyan]{filename}[/] is in your [b].gitignore[/] to avoid committing secrets!"
        )
    except IOError as e:
        print(f"[bold red]:x: Error writing file '{filename}': {e}[/]")
        # Consider re-raising or exiting if this error is critical
        # raise # Or sys.exit(1)


# % ── Helper Entry Functions ───────────────────────────────────────────────────


def check_env_file(filename: str = DEFAULT_ENV_FILE) -> None:
    """
    Checks if the specified .env configuration file exists and prompts to create it if not.

    This function serves as a preliminary check, typically run at the start of
    scripts that depend on the .env file. If the file is missing, it calls
    `create_env_file` to guide the user through creation.

    Args:
        filename (str): The path/name of the .env file to check.
                        Defaults to DEFAULT_ENV_FILE (".env").

    Returns:
        None
    """
    print(f"Checking for configuration file: [b cyan]{filename}[/]")
    if not os.path.exists(filename):
        print(f":warning: File [b cyan]{filename}[/] not found.")
        # Offer to create it
        if Confirm.ask(
            f"Do you want to create the [b cyan]{filename}[/] configuration file now?",
            default=True,
        ):
            create_env_file(filename)
        else:
            print(
                "Skipping .env file creation. Application might not run correctly without it."
            )
    else:
        print(
            f"[b #8ccf7e]:heavy_check_mark: Configuration file [b cyan]{filename}[/] found."
        )


# % ── Example Usage ────────────────────────────────────────────────────────────

# Typically, you would call check_env_file() from your main script
# or configuration loading module before trying to load environment variables.

# if __name__ == "__main__":
#     print("[bold blue]Running .env file check and creation utility...[/]")
#     check_env_file()
#     print("[bold blue]Utility finished.[/]")
